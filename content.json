{"meta":{"title":"GobYang","subtitle":null,"description":"","author":"GobYang","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2016-12-24T08:15:59.000Z","updated":"2017-01-06T05:34:51.604Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Hi,我是GobYang,是一个非科班的程序员，目前主要是PHP开发相关的工作。 工作中总是会遇到一些问题，有时候会各种搜索、填坑找到解决办法，然后复制或记录在记事本上面，久了多了都忘了，总感觉不实在，所以希望通过博客笔记形式加深印象记录在这里。 此博客是基于NodeJS的博客框架-Hexo构建而成,感谢开源大大们! 联系方式：社交：Weibo Email：gobyang#gmail.com Github：github"},{"title":"tags","date":"2016-12-24T08:03:07.000Z","updated":"2016-12-24T08:04:31.862Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Openresty中获取和设置cookie","slug":"Openresty中获取和设置cookie","date":"2016-12-24T14:27:52.000Z","updated":"2017-01-04T09:30:53.046Z","comments":true,"path":"2016/12/24/Openresty中获取和设置cookie/","link":"","permalink":"http://yoursite.com/2016/12/24/Openresty中获取和设置cookie/","excerpt":"","text":"1：获取cookielocal cookie_xx_value = ngx.var.cookie_xx 2：设置cookie因为cookie的过期时间格是林尼治时间需要注意转下。 12local expires = 3600 * 24 -- cookie expires = 1 dayngx.header[\"Set-Cookie\"] = \"hello=world; Path=/; Expires=\" .. ngx.cookie_time(ngx.time() + expires) 如果想同时设置多个cookie，可以传一个table 1234567local expires = 3600 * 24 -- cookie expires = 1 daylocal cookie_table = &#123;\"hello=world; Path=/;Domain=/; Expires=\" .. ngx.cookie_time(ngx.time() + expires),\"hello2=world2; Path=/;Domain=/; Expires=\" .. ngx.cookie_time(ngx.time() + expires),\"hello3=world3; Path=/;Domain=/; Expires=\" .. ngx.cookie_time(ngx.time() + expires)&#125;ngx.header[\"Set-Cookie\"] = cookie_table 更多cookie相关可以参考wikipedia:https://en.wikipedia.org/wiki/HTTP_cookie 也可以直接使用github上面分享的lua的cookie封装好的库。","categories":[],"tags":[{"name":"Openresty","slug":"Openresty","permalink":"http://yoursite.com/tags/Openresty/"},{"name":"Cookie","slug":"Cookie","permalink":"http://yoursite.com/tags/Cookie/"}]},{"title":"Openresty中使用lua的mongodb库，使用连接池节省连接认证时间","slug":"Openresty中使用lua的mongodb库，使用连接池节省连接认证时间","date":"2016-11-20T01:36:37.000Z","updated":"2017-01-20T02:40:34.616Z","comments":true,"path":"2016/11/20/Openresty中使用lua的mongodb库，使用连接池节省连接认证时间/","link":"","permalink":"http://yoursite.com/2016/11/20/Openresty中使用lua的mongodb库，使用连接池节省连接认证时间/","excerpt":"","text":"因为服务器的mongodb开启了auth认证的，所以每次连接都要验证密码，测试了下GitHub上面的几个lua的mongodb库，无论是官方的mongorover，还是纯的lua库：lua-resty-mongol3，一个简单的insert操作都比php耗费的时间更长，如果业务用lua来做的优势就没有那么明显了，单纯的不认证的insert操作lua的优势很是明显的，所以要么取消认证，要么就是可以结合openresty的连接池。而且发现使用连接池后，纯的lua mongodb库竟然比mongorover更快。 下面是动态判断该连接是否是连接池里面的一些判断，把连接与认证封装在一起,减少不必要认证次数。同时修改了仓库的源码，以支持支持自定义连接池，这样可以让不同 用户名、密码、数据库 的连接分开，不相互干扰。 新建一个lua文件，只做连接操作。 local mongo = require “resty.mongol” local _M = {} --把连接与认证封装在一起,减少不必要认证次数 local function connect(config) local db = mongo:new() if not db then return nil,nil, &quot;db not initialized&quot; end if config.host == nil or config.host == &apos;&apos; or config.port == nil or config.port == &apos;&apos; or config.database == nil or config.database == &apos;&apos; then return nil,nil, &quot;host,port,database can&apos;t empty&quot; end local user = config.user if(user == nil or user == &apos;&apos;) then user = &apos;&apos; end --支持自定义连接池，这样可以让不同 用户名、密码、数据库 的连接分开，不相互干扰，mongol库本身是没有实现的，所以修改了源码 local pool = user .. &quot;:&quot; .. config.database .. &quot;:&quot; .. config.host .. &quot;:&quot; .. config.port local ok, err = db:connect(config.host, config.port, {pool = pool}) if not ok then return nil,nil,err end --选择数据库 local select_db = db:new_db_handle(config.database) --获取连接池里面的已经auth过连接的数量 local times,err =db:get_reused_times() if((times == 0 or times == nil) and #user &gt; 0) then ok,err = select_db:auth_scram_sha1(config.user,config.password) if not ok then return nil,nil,err end end return db,select_db,nil end return _M","categories":[],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"},{"name":"Openresty","slug":"Openresty","permalink":"http://yoursite.com/tags/Openresty/"},{"name":"Lua","slug":"Lua","permalink":"http://yoursite.com/tags/Lua/"}]},{"title":"Composer与__autoload自动加载冲突问题","slug":"Composer与-autoload自动加载冲突问题","date":"2016-11-04T08:53:08.000Z","updated":"2017-01-04T08:57:28.529Z","comments":true,"path":"2016/11/04/Composer与-autoload自动加载冲突问题/","link":"","permalink":"http://yoursite.com/2016/11/04/Composer与-autoload自动加载冲突问题/","excerpt":"最近改一些旧的项目遇到的一个有意思的问题。一个项目从入口文件进来，定义了自动加载函数__autoload()1234function __autoload($className)&#123; $class = $className . &apos;.class.php&apos;; require_once(CLASS_DIR.$class);&#125;","text":"最近改一些旧的项目遇到的一个有意思的问题。一个项目从入口文件进来，定义了自动加载函数__autoload()1234function __autoload($className)&#123; $class = $className . &apos;.class.php&apos;; require_once(CLASS_DIR.$class);&#125; 然后这个旧的项目在程序某个操作类下面引入了composer来自动加载。1234567891011121314151617181920&lt;?phprequire BASIC_PATH.&apos;vendor/autoload.php&apos;;print_r(spl_autoload_functions());class Testtest&#123; public function __construct($upload_type,$act_id,$img_name=&apos;&apos;)&#123; print_r(spl_autoload_functions()); echo &apos;&lt;br/&gt;&lt;br/&gt;&apos;; $client = new MongoDB\\Client($GLOBALS[&apos;config&apos;][&apos;mongodb_loho&apos;]); var_dump($client); echo &apos;&lt;br/&gt;&lt;br/&gt;&apos;; $upload = new Upload(); var_dump($upload); echo &apos;&lt;br/&gt;&lt;br/&gt;&apos;; $client2 = new MongoDB\\Client($GLOBALS[&apos;config&apos;][&apos;mongodb_loho&apos;]); var_dump($client2); echo &apos;&lt;br/&gt;&lt;br/&gt;&apos;; $upload2 = new Upload(); var_dump($upload2); &#125;&#125; 打印结果如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657Array( [0] =&gt; Array ( [0] =&gt; Composer\\Autoload\\ClassLoader Object ( [prefixLengthsPsr4:Composer\\Autoload\\ClassLoader:private] =&gt; Array ( [M] =&gt; Array ( [MongoDB\\] =&gt; 8 ) ) [prefixDirsPsr4:Composer\\Autoload\\ClassLoader:private] =&gt; Array ( [MongoDB\\] =&gt; Array ( [0] =&gt; E:\\UPUPW_NP5.5_64\\htdocs\\tupian\\vendor/mongodb/mongodb/src ) ) [fallbackDirsPsr4:Composer\\Autoload\\ClassLoader:private] =&gt; Array ( ) [prefixesPsr0:Composer\\Autoload\\ClassLoader:private] =&gt; Array ( ) [fallbackDirsPsr0:Composer\\Autoload\\ClassLoader:private] =&gt; Array ( ) [useIncludePath:Composer\\Autoload\\ClassLoader:private] =&gt; [classMap:Composer\\Autoload\\ClassLoader:private] =&gt; Array ( ) [classMapAuthoritative:Composer\\Autoload\\ClassLoader:private] =&gt; [missingClasses:Composer\\Autoload\\ClassLoader:private] =&gt; Array ( ) ) [1] =&gt; loadClass ))Array( [0] =&gt; __autoload)&lt;br/&gt;&lt;br/&gt;MongoDB\\Client.class.php 我们会发现，上面的代码，进行到构造函数里面的时候，打印出返回所有已注册的__autoload()函数的时候，只有入口文件定义的，这是为什么呢?按理说使用了require包含的类库文件作用是全局的，手册上面有：When a file is included, the code it contains inherits the variable scope of the line on which the include occurs. Any variables available at that line in the calling file will be available within the called file, from that point forward. However, all functions and classes defined in the included file have the global scope!使用get_included_files()函数打印出来的时候也是看得到的。然后在在网上搜索了下，这篇文章恰好能够解释：http://www.jb51.net/article/31279.htm 把require BASIC_PATH.’vendor/autoload.php’;放在外面，使用spl_autoload_functions函数打印的时候，发现并没有把composer的加入到类里面，估计是scope的问题，程序执行到这里，发现已经定义了全局的自动加载函数__autoload，就执行执行这个自动加载的函数，然后找不到直接抛出一个严重错误，中断执行，但是在构造函数开头添加一句：1spl_autoload_register(&apos;__autoload&apos;); 把定义的全局构造函数加入到全局变量autoload_functions的hash table中，就既可以自动找到composer引入的类，又可以自动找到全局的autoload定义的类。从而实现自动加载。 加入把文件开头包含composer的入口文件移动到构造函数里面，就会发现全局的自动加载的函数的类找不到了，因为：__autoload 方法在 spl_autoload_register 后会失效，因为 autoload_func 函数指针已指向 spl_autoload 方法。 解决办法也是：1spl_autoload_register( &apos;__autoload&apos; ); 把__autoload 方法加入 autoload_functions list","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"},{"name":"Composer","slug":"Composer","permalink":"http://yoursite.com/tags/Composer/"}]},{"title":"PHP遍历某个目录下面的文件并使用多进程记录到数据库的几种方法比较","slug":"PHP遍历某个目录下面的文件并使用多进程记录到数据库的几种方法比较","date":"2016-10-10T08:00:30.000Z","updated":"2016-12-24T16:06:13.618Z","comments":true,"path":"2016/10/10/PHP遍历某个目录下面的文件并使用多进程记录到数据库的几种方法比较/","link":"","permalink":"http://yoursite.com/2016/10/10/PHP遍历某个目录下面的文件并使用多进程记录到数据库的几种方法比较/","excerpt":"最近工作需要写一个脚本去跑某个目录下面的文件然后记录到数据库，比较了下三种遍历目录的方法. 打印了测试目录weixin下面有多少文件,文件一共3千多，层级深度还是比较深的。","text":"最近工作需要写一个脚本去跑某个目录下面的文件然后记录到数据库，比较了下三种遍历目录的方法. 打印了测试目录weixin下面有多少文件,文件一共3千多，层级深度还是比较深的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?php/* * php import.php xxx目录 比如：php import.php images * 此目录是跟脚本同级顶级的目录 */$t1 = microtime(true);define('BASIC_PATH',P(dirname(__FILE__)).'/');if(empty($argv))&#123; exit(\"请在命令行执行此脚本\\n\");&#125;if(count($argv) &lt;= 1 || empty($argv[1]))&#123; exit(\"请输入需要导入的文件夹,比如php import.php images\\n\");&#125;//默认只取第一个参数，暂不多个文件夹处理$need_import_dir = BASIC_PATH.$argv[1];//调用法1getFiles1($need_import_dir);//调用法2getFiles2($need_import_dir);//调用法3$directory = new RecursiveDirectoryIterator($need_import_dir);getFiles3($directory);$t2 = microtime(true);echo '耗时'.round($t2-$t1,3).\"秒\\n\";//自定义函数function P($path)&#123;return str_replace('\\\\','/',$path);&#125;//法1：传统遍历目录function getFiles1($dir)&#123; if(!is_dir($dir))&#123; exit('不是dir'); &#125; $handle = opendir($dir); if($handle)&#123; while(false !== ($file = readdir($handle)))&#123; if($file != '.' &amp;&amp; $file != '..')&#123; $filename = $dir.\"/\".$file; if(is_file($filename))&#123; echo 'File path = '.$filename.\"\\n\"; &#125;else&#123; getFiles1($filename); &#125; &#125; &#125; closedir($handle); &#125;&#125;//法2：迭代器遍历目录,并将这个树形结构的迭代器展开为一维结构function getFiles2($dir)&#123; $directory = new RecursiveDirectoryIterator($dir,RecursiveDirectoryIterator::SKIP_DOTS); $ierator = new RecursiveIteratorIterator($directory,RecursiveIteratorIterator::LEAVES_ONLY); foreach($ierator as $fileinfo)&#123; echo 'File path = ' .$fileinfo-&gt;getPathname(). \"\\n\"; &#125;&#125;//法3：迭代器+递归函数遍历目录，$dir为RecursiveDirectoryIterator迭代器对象function getFiles3($dir)&#123; for(;$dir-&gt;valid();$dir-&gt;next())&#123; if($dir-&gt;isDir() &amp;&amp; !$dir-&gt;isDot()) &#123; if($dir-&gt;haschildren()) &#123; getFiles3($dir-&gt;getChildren()); &#125; &#125;elseif($dir-&gt;isFile())&#123; echo 'File path = '.$dir-&gt;getPathName().\"\\n\"; &#125; &#125;&#125; 法1：测试打印了几次，耗时分别在0.048,0.062,0.078法2：测试打印了几次，耗时分别在0.092，0.103，0.151，0.065法3：测试打印了几次，耗时分别在0.037，0.044，0.039,0.045 法2：主要是使用了迭代器RecursiveIteratorIterator,作用是把多维的树形数组转成一维，耗时较多 法1相对法3，传统的不断打开文件句柄也会耗时些 所以建议还是使用法3，关于SPL（PHP标准类库）的了解文章：文章地址 在编码中我们可以多使用SPL标准类库提供给我们的类，告别一些传统的方法，使用一些新的解决方法和思维。 现在已经能够遍历出某个目录下面的所有文件了。如果还想追求速度，可以使用多进程pcntl相关函数来完成。我其中使用了LimitIterator这个迭代器来控制每个进程的处理的遍历出来文件的偏移，这样子来加快任务处理速度，进程的数量我是通过命令find weixin -type f -print | wc -l查看目录下面的文件个数计算的来设置每个进程处理文件个数偏移的。12345678910111213141516171819202122232425262728//$need_import_dir需要导入文件的目录$directory = new RecursiveDirectoryIterator($need_import_dir,RecursiveDirectoryIterator::SKIP_DOTS);$ierator = new RecursiveIteratorIterator($directory,RecursiveIteratorIterator::LEAVES_ONLY);//PHP多进程for ($i = 0; $i &lt; 2; $i++) &#123; $pid = pcntl_fork(); if ($pid == -1) &#123; echo \"Could not fork!\\n\"; exit(1); &#125; if (!$pid) &#123; echo \"child process $i running\\n\"; $offset = $i*1800; $limit_iterator = new LimitIterator($ierator,$offset,1800); foreach($limit_iterator as $file=&gt;$fileinfo)&#123; //传文件路径，记录到数据库 recordFile($fileinfo-&gt;getPathname()); &#125; //子进程执行完毕之后就退出，以免继续fork出新的子进程 exit($i); &#125; usleep(1);//歇一微秒避免并发记录&#125;//等待子进程执行完毕，避免出现僵尸进程while (pcntl_waitpid(0, $status) != -1) &#123; $status = pcntl_wexitstatus($status); echo \"Child $status completed\\n\";&#125; 这样子处理速度直接快接近一半了。也可以不用上面的方法，可以使用法3把所有文件路径跑出来存到一个数组里面，再创建多个进程通过数组偏移来处理。1234567891011121314151617181920212223242526$directory = new RecursiveDirectoryIterator($need_import_dir,RecursiveDirectoryIterator::SKIP_DOTS);//把法3改成返回一个数组里面存着所有的文件$total_files = getFiles3($directory);$chunk_size = 1800;//分割下，每个数组大小可以具体设置。$chunk_list = array_chunk($total_files,$chunk_size);//PHP多进程for ($i = 0; $i &lt; count($chunk_list); $i++) &#123; $pid = pcntl_fork(); if ($pid == -1) &#123; echo \"Could not fork!\\n\"; exit(1); &#125; if (!$pid) &#123; foreach($chunk_list[$i] as $value)&#123; recordFile($value); &#125; //子进程执行完毕之后就退出，以免继续fork出新的子进程 exit($i); &#125; usleep(1);&#125;//等待子进程执行完毕，避免出现僵尸进程while (pcntl_waitpid(0, $status) != -1) &#123; $status = pcntl_wexitstatus($status); echo \"Child $status completed\\n\";&#125; 经过测试还是第一种通过LimitIterator迭代器偏移开启两个进程更快一些。 ——————2016-10-10","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"修改mongodb3.x版本的auth认证方式为2.x版本的认证方式","slug":"mongodb3.x版本的auth认证方式为2.x版本的认证方式","date":"2016-10-01T05:02:30.000Z","updated":"2016-12-24T15:57:35.457Z","comments":true,"path":"2016/10/01/mongodb3.x版本的auth认证方式为2.x版本的认证方式/","link":"","permalink":"http://yoursite.com/2016/10/01/mongodb3.x版本的auth认证方式为2.x版本的认证方式/","excerpt":"","text":"最近在用openresty的做一些任务，其中在使用mongo的Lua库的时候，因为mongodb开启了auth，需要账号密码才能连接。 mongodb 2.xx的认证方式，使用的是md5加密,认证耗时更短，如果使用3.xx认证处耗时很严重在lua中。 怎么改呢？ mongo改验证方式：1、停mongodb,2、以不验证模式启动3、删除原有用户名密码4、use admin;db.system.version.insert({“_id”:”authSchema”,”currentVersion”:3})5、新增用户名密码！6、停mongodb7、以验证方式启动mongdb 如果insert不行就update","categories":[],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"}]},{"title":"内部微信授权code解决多个域名的脚本","slug":"内部微信授权code解决多个域名的脚本","date":"2016-03-25T15:42:04.000Z","updated":"2016-12-24T15:46:02.105Z","comments":true,"path":"2016/03/25/内部微信授权code解决多个域名的脚本/","link":"","permalink":"http://yoursite.com/2016/03/25/内部微信授权code解决多个域名的脚本/","excerpt":"","text":"内部调用微信授权脚本－解决一个域名想授权多个域名获取微信授权code123456789101112131415161718192021222324252627282930&lt;?php$access_key = &apos;123qwe&apos;;$innder_key = $_GET[&apos;inner_key&apos;];//内部调用if (isset($inner_key) &amp;&amp; !empty($inner_key)) &#123; if ($inner_key != sha1($access_key)) &#123; exit(&apos;access error!&apos;); &#125; $current_url = &apos;http://www.xxx.com/code.php&apos;; $redirect_uri = $current_url.&apos;?url=&apos;.urlencode($_GET[&apos;redirect_url&apos;]); $oauth_url = getOauthRedirect($redirect_uri); header(&apos;Location:&apos;.$oauth_url); return;&#125;//微信授权回调if(isset($_GET[&apos;code&apos;]))&#123; $url = urldecode($_GET[&apos;url&apos;]); $new_url = $url.&apos;&amp;code=&apos;.$_GET[&apos;code&apos;]; header(&apos;Location:&apos;.$new_url); return;&#125;/** * oauth 授权跳转接口 * @param string $callback 回调URI * @return string 返回 用户同意授权，获取code的URL 外部调用直接header重定向这个链接 */function getOauthRedirect($callback, $state = &apos;&apos;, $scope = &apos;snsapi_base&apos;) &#123; $appid = &apos;xxxx&apos;;//微信公众号服务号的appid return &apos;https://open.weixin.qq.com/connect/oauth2/authorize?appid=&apos; . $appid . &apos;&amp;redirect_uri=&apos; . urlencode($callback) . &apos;&amp;response_type=code&amp;scope=&apos; . $scope . &apos;&amp;state=&apos; . $state . &apos;#wechat_redirect&apos;;&#125;","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"},{"name":"微信公众号","slug":"微信公众号","permalink":"http://yoursite.com/tags/微信公众号/"}]},{"title":"Github的SSH和HTTPS记住账号密码方法","slug":"Github的SSH和HTTPS记住账号密码方法","date":"2015-12-24T07:58:08.000Z","updated":"2016-12-24T08:43:17.484Z","comments":true,"path":"2015/12/24/Github的SSH和HTTPS记住账号密码方法/","link":"","permalink":"http://yoursite.com/2015/12/24/Github的SSH和HTTPS记住账号密码方法/","excerpt":"其实关于这两种认证方式也是适用于Gitlab等相关git.很多时候，我们在打算克隆一个仓库到本地的时候，有两种方式可以选择，即：SSH和HTTPS.克隆还好，但是需要推送的时候，也许会遇到权限，需要账号密码啊。 通过HTTPS方式克隆的代码到本地如果遇到：1error: The requested URL returned error: 403 Forbidden while accessing 这是权限问题，可以修改.git/config文件追加用户名和密码，也可以直接敲下面命令：1git remote set-url origin https://youruser:password@github.com/user/repo.git","text":"其实关于这两种认证方式也是适用于Gitlab等相关git.很多时候，我们在打算克隆一个仓库到本地的时候，有两种方式可以选择，即：SSH和HTTPS.克隆还好，但是需要推送的时候，也许会遇到权限，需要账号密码啊。 通过HTTPS方式克隆的代码到本地如果遇到：1error: The requested URL returned error: 403 Forbidden while accessing 这是权限问题，可以修改.git/config文件追加用户名和密码，也可以直接敲下面命令：1git remote set-url origin https://youruser:password@github.com/user/repo.git 其实更常用的是SSH的方式来推送代码： 首先需要生成 SSH Keys，需要用到 ssh-keygen 命令。1ssh-keygen -t rsa -C &quot;xxx@qq.com&quot; -f ~/.ssh/git-github 简单介绍下参数含义： -t 指定密钥类型，默认即 rsa ，可以省略-C 设置注释文字，比如你的邮箱-f 指定密钥文件存储文件名，会生成 git-github 和 git-github.pub 两个密钥文件 回车后，遇到提示输入 yes 即可，剩下一路回车，密钥文件就在指定路径下生成了。 接下来就去git管理界面的设置里面将 SSH 公钥添加到 Github设置里面把git-github.pub公钥的内容复制进去添加就行了。 本地添加SSH别名如果本机有其它密钥，连接 github 时可能不会自动使用刚生成的密钥，需要设置别名： $ sudo vi ~/.ssh/config加入类似的一段代码： 12345host git-github user git hostname github.com port 22 identityfile ~/.ssh/git-github 保存退出。 测试连接1ssh -T git-github Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 表示设置的 SSH Keys 认证通过，但 Github 不提供 shell 访问。此时就可以正常使用 Github 了。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"JS如何判断一个页面是否已经打开?","slug":"JS如何判断一个页面是否已经打开","date":"2015-01-23T07:18:28.000Z","updated":"2016-12-24T09:18:49.352Z","comments":true,"path":"2015/01/23/JS如何判断一个页面是否已经打开/","link":"","permalink":"http://yoursite.com/2015/01/23/JS如何判断一个页面是否已经打开/","excerpt":"一种是刷新之后又会重新打开页面：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var objWin; function openPage() &#123; var target = &quot;http://www.baidu.com&quot;; //判断是否打开 if (objWin == null || objWin.closed) &#123; objWin = window.open(target); &#125; else &#123; objWin.location.replace(target); &#125; //objWin.focus(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;javascript:openPage();&quot;&gt;打开页面&lt;/a&gt; &lt;/body&gt;&lt;/html&gt;","text":"一种是刷新之后又会重新打开页面：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var objWin; function openPage() &#123; var target = &quot;http://www.baidu.com&quot;; //判断是否打开 if (objWin == null || objWin.closed) &#123; objWin = window.open(target); &#125; else &#123; objWin.location.replace(target); &#125; //objWin.focus(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;javascript:openPage();&quot;&gt;打开页面&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 一种更完美一点的方案(刷新之后也不会再重新打开)： index.html 12345678910&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;open&quot; onclick=&quot;window.open(&apos;proxy.html&apos;,&apos;tag&apos;)&quot;&gt;&lt;/body&gt;&lt;/html&gt; proxy.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;target页面&lt;/title&gt; &lt;script&gt; if(window.parent.name!=&quot;msg&quot;) &#123; window.location.href=&quot;target.html&quot;;//这才是你的显示页面 &#125; else &#123; window.parent.focus(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;proxy&lt;/body&gt;&lt;/html&gt; target.html 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;target页面&lt;/h3&gt;&lt;script&gt; window.name=&quot;msg&quot;;&lt;/script&gt;message page&lt;iframe src=&quot;&quot; name=&quot;tag&quot; style=&quot;display:none&quot;&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"linux学习之用户管理","slug":"linux学习之用户管理","date":"2014-03-20T12:14:09.000Z","updated":"2016-12-24T15:24:18.471Z","comments":true,"path":"2014/03/20/linux学习之用户管理/","link":"","permalink":"http://yoursite.com/2014/03/20/linux学习之用户管理/","excerpt":"用户配置文件用户管理简介 .越是对服务器安全性要求高的服务器，越需要建立合理的用户权限等级制度和服务器操作规范 .在linux中主要是通过用户配置文件来查看和修改用户信息","text":"用户配置文件用户管理简介 .越是对服务器安全性要求高的服务器，越需要建立合理的用户权限等级制度和服务器操作规范 .在linux中主要是通过用户配置文件来查看和修改用户信息 用户信息文件/etc/passwdvim /etc/passwd如果不知道这个文件是干什么的 可以执行 man 5 passwd 查看帮助用户很多：如 root:x:0:0:root:/root:/bin/bash 第1个字段：用户名称 第2个字段：密码标志 （直接一个x 并没有直接列出密码 而是放在了/etc/shadow下面 原因/etc/passwd 各个用户都是可读的，就可能被暴力拆解 而/etc/shadow也是通过加密的 只有管理员有权限！） 第3个字段：UID（用户ID） 0:超级用户 1-499系统用户（伪用户）500-65535：普通用户 第4个字段：GID（用户初始组ID） 组：相同类型的集合 初始组：linux用户一建立就默认属于一个组 跟window不一样 window每添加一个用户就会放入到user组里面。而linux你创建一个user1就会创建一个跟用户名相同名的user1用户组。每个用户必须要有一个初始组且只能有一个。建议：虽然初始组能够改，但并不建议改，原因：改了初始组把所建立的文件搞糊涂！ 附加组：指用户可以加入多个其他的用户组，并拥有这些组的权限，附加组可以有多个。 第5个字段：用户说明 第6个字段：家目录 普通用户：/home/用户名 超级用户：/root/ 第7个字段：登录之后的Shell Shell 就是Linux的命令解释器 在/etc/passwd当中，除了标准Shell是/bin/bash之外，还可以写如/sbin/nologin 影子文件/etc/shadow实际就是 /etc/passwd的影子文件 只是权限更低 都是000000000例如： root:$6$JmdhYiD4y7zwPiMu$kq9iu9C.0on1X1Ia14QZslgSWRy1pK8sQsVmCauGykqOFAyawpvFkaVM83nuqum4oJ92Y3sPPIXlpw5Fksp3m/:16326:0:99999:7:::第一个字段：用户名第二个字段：加密密码 加密算法升级为SHA512散列加密算法 如果密码位是“!!”或“*”代表没有密码，不能登录第三个字段：密码最后一次修改日期 使用1970年1月1日作为标准时间，每过一天时间戳加1第四个字段：两次密码的修改间隔时间（和第3个字段相比）第五个字段：密码有效期（和第3个字段相比）第六个字段：密码修改到期前的警告天数（和第5字段相比）第七个字段：密码过期后的宽限天数（和第五个字段相比） 0:代表密码过期后立即失效 1:代表密码永远不会失效第八个字段：账号失效时间 要用时间戳表示 把时间戳换算为日期 date -d “1970-01-01 16066 days” 把日期换算为时间戳 echo $((date –date=”2014/01/06” +%s)/86400+1)第九个字段：保留 组信息文件/etc/group和组密码文件/etc/gshadow组信息文件/etc/group 例如：root:x:0: 第一个字段：组名 第二个字段：组密码标志 第三个字段：GID 第四个字段：组中附加用户 组密码文件/etc/gshadow 第一个字段：组名 第二个字段：组密码 第三个字段：组管理员用户名 第四个字段：组中附加用户 用户管理相关文件用户的家目录普通用户：/home/用户名，所有者和所属组都是此用户，权限是700 超级用户：/root/ 所有者和所属组都是root用户，权限是550 如果你想把普通用户变为超级用户 家目录并不会修改 只是权限变为了超级权限。 普通用户变为超级用户的方法：修改用户信息文件/etc/passwd 把uid变为0 这样我们再登录的时候就会发现输入命令前面如果是#就说明是超级用户 如果是$就是普通用户 用户的邮箱/var/spool/mail/用户名 是不是和我们用的QQ邮箱一样呢？QQ邮箱之所以能够转发是靠QQ自带的服务器进行转发，linux虽然可以作为客户端收发邮件，但是也要依赖服务器去发送邮件。QQ邮箱有专门的服务器去发送邮件，在linux中用户之间可以传递邮件，利用linux的内存直接转发，每个用户都有邮箱，我们用的只是邮箱的客户端，并没有搭建服务器。 用户模板目录/etc/skel 在用户家目录执行 ls -a 会发现出现了一些隐藏文件，这是在用户创建的时候自动创建的。这些自动创建的文件是从/etc/skel自动拷贝过去的。如果我想让所有用户一添加就在家目录出现某个文件，比如你登陆的我的系统要遵守xx规则，几点关机，警告信息...等等。只需要在/etc/skel下面添加文件就行了！ 用户管理命令用户添加命令 useradd 格式：useradd [选项] 用户名 选项： -u UID： 手工指定用户的UID号 -d 家目录： 手工指定用户的家目录 -c 用户说明： 手工指定用户的说明 -g 组名： 手工指定用户的初始组 -G 组名： 指定用户的附加组 -s shell: 手工指定用户的登录shell 。默认是/bin/bash 设置用户默认值的文件 /etc/default/useradd 和 /etc/login.defs 修改用户密码 passwd passwd [选项] 用户名 选项： -S 查询用户密码的密码状态。仅root用户可用。 eg: passwd -S qingwa qingwa PS 2014-09-14 0 99999 7 -1 #用户名密码设定时间2014-09-14 密码修改间隔时间（0）密码有效期（99999） #警告时间（7） 密码不失效（-1） 实际上就跟 /etc/shadow里面看到的一样 -l 暂时锁定用户。仅root用户可用。在密码前面加上!! 让其密码失效 -u 解锁用户。仅root用户可用。 –stdin 可以通过管道符输出的数据作为用户的密码 echo “123” | passwd –stdin qingwa 管道符:直接将前面的输出作为后面的输入 修改用户信息 usermodusermod -c &quot;test user&quot; lamp #修改用户的说明 usermod -G root lamp #把lamp用户加入root组 usermod -L lamp #锁定用户 usermod -U lamp #解锁用户 修改用户密码状态 chage chage [选项] 用户名 选项： -l 列出用户的详细密码状态 -d 日期 修改密码最后一次更改日期（shadow第3字段） -m 天数 两次密码修改间隔（shadow第4字段） -M 天数 密码有效期（shadow第5字段） -W 天数 密码过期前警告天数（shadow第6字段） -I 天数 密码过后宽限天数（shadow第7字段） -E 日期 账号失效时间（shadow第8字段） 因为选项过多直接修改vim /etc/shadow文件就行了 常用的一个：chage -d 0 qingwa #这个命令其实是把密码修改日期归0了 这样用户一登陆就要修改密码 删除用户 userdel userdel [-r] 用户名 选项： -r 删除用户的同时删除用户家目录 id 用户名 #查看用户的uid 组id 用户切换命令 susu [选项] 用户名 选项： - #选项只使用“-”代表连带用户的环境变量一起切换 -c 命令 #仅执行一次命令，而不切换用户身份 eg: su - root #切换成root su - root -c &quot;useradd qinwa&quot; 不切换成root，但是执行useradd命令添加qingw用户 用户组管理命令添加用户组groupadd [选项] 组名 选项：-g GID #指定组ID 修改用户组groupmod [选项] 组名 -g GID #修改组ID -n 新组名 #修改组名 eg:groupmod -n testgrp group1 #把组名group1修改为testgrp 删除用户组groupdel 组名 把用户添加入组或从组中删除gpasswd 选项 组名 选项：-a 用户名 #把用户加入组 -d 用户名 #把用户从组中删除","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"linux学习之权限管理","slug":"linux学习之权限管理","date":"2014-03-19T15:03:47.000Z","updated":"2016-12-24T15:10:27.370Z","comments":true,"path":"2014/03/19/linux学习之权限管理/","link":"","permalink":"http://yoursite.com/2014/03/19/linux学习之权限管理/","excerpt":"ACL权限1：ACL权限简介和开启A：不再考虑身份。用户或用户组直接拿过来给它改权限 B：查看分区ACL权限是否开启 dumpe2fs -h /dev/sda3 #dump2fs命令是查询指定分区详细文件系统信息的命令 选项：-h 仅显示超级块中信息，而不显示磁盘块组的详细信息 (步骤1：df -h #查看当前系统分区使用情况，容量，已用，可用，挂载点，找到用户所在分区。) (步骤2：dumpe2fs -h /dev/sda3) C：临时开启分区ACL权限 mount -o remount,acl / #重新挂载根分区，并载入acl权限 D：永久开启分区ACL权限 步骤1：vi /etc/fstab #加入acl UUID=c2cq6f57-b15c-43ea-bca0-f239083d8bd2 / ext4 defaults,acl 1 1 #defaults后面加了一个acl 步骤2：mount -o remount / #重新挂载文件系统或重启动系统，使修改生效","text":"ACL权限1：ACL权限简介和开启A：不再考虑身份。用户或用户组直接拿过来给它改权限 B：查看分区ACL权限是否开启 dumpe2fs -h /dev/sda3 #dump2fs命令是查询指定分区详细文件系统信息的命令 选项：-h 仅显示超级块中信息，而不显示磁盘块组的详细信息 (步骤1：df -h #查看当前系统分区使用情况，容量，已用，可用，挂载点，找到用户所在分区。) (步骤2：dumpe2fs -h /dev/sda3) C：临时开启分区ACL权限 mount -o remount,acl / #重新挂载根分区，并载入acl权限 D：永久开启分区ACL权限 步骤1：vi /etc/fstab #加入acl UUID=c2cq6f57-b15c-43ea-bca0-f239083d8bd2 / ext4 defaults,acl 1 1 #defaults后面加了一个acl 步骤2：mount -o remount / #重新挂载文件系统或重启动系统，使修改生效 2：查看与设定ACL权限 A：查看ACL命令 getfacl 文件名 #查看ACL权限 B:设定ACL权限 setfacl 选项 文件名 选项：-m 设定ACL权限 给用户设置ACL权限 setfacl -m u:qingwa:rx /project/ 给用户组设定ACL权限 setfacl -m g:xxgroup:rwx project/ -x 删除指定的ACL权限 setfacl -x g:xxgroup /project/ #删除xxgroup在project下面的ACL权限 -b 删除所有的ACL权限 setfacl -b /project/ #会删除在project下面所有用户用户组的ACL权限 -d 设定默认的ACL权限 -k 删除默认ACL权限 -R 递归设定ACL权限 3:最大有效权限与删除ACL权限最大有效权限maskmask是用来指定最大有效权限的。如果我给用户赋予了ACL权限，是需要和mask的权限“相与”才能得到用户的真正权限。(相与—相当于逻辑的与 一个为假就都为假) 4：默认ACL权限和递归ACL权限递归是父目录在设定ACL权限时，所有的子文件和子目录也会拥有相同的ACL权限。setfacl -m u:用户名:权限 -R 文件名 默认ACL权限默认ACL权限的作用是如果给父目录设定了ACL权限，那么父目录中所有新建的子文件都会继承父目录的ACL权限。setfacl -m d:u用户名：权限 文件名 文件特殊权限1: SetUIDSetUID的功能 .只有可以执行的二进制程序才能设定SUID权限 .命令执行者要对该程序拥有x（执行）权限 .命令执行者在执行该程序时获得该程序文件宿主的身份（在执行程序的过程中灵魂附体为文件的属主） .SetUID权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效。 ---设置SUID--- 4代表SUID - chmod 4755 文件名 - chmod u+s 文件名 ---取消SUID--- - chmod 755 文件名 - chmod u-s 文件名 ---危险的SetUID--- .关键目录应该严格控制写权限，比如“/”、“/usr”等。 .用户的密码设置要严格遵守密码三原则。 .对系统中默认应该是具有SetUID权限的文件作一列表，定时检查有没有这之外的文件被设置了SetUID权限。 2: SetGIDSetGID针对文件的作用 .只有可执行的二进制程序才能设置SGID权限 .命令执行者要对该程序拥有x(执行)权限 .命令执行在执行程序的时候，组身份升级为该程序文件的属组 .SetGID权限同样只在该程序执行过程中有效，也就是说组身份改变只在程序执行过程中有效 SetGID针对目录的作用 .普通用户必须对此目录拥有r和x权限，才能进入此目录 .普通用户在此目录中的有效组会变成此目录的属组 .若普通用户对此目录拥有w权限时，新建的文件的默认属组是这个目录的属组 --设定SetGID-- 2代表SGID -chmod 2755 文件名 -chmod g+s 文件名 3: Sticky BITSBIT粘着位作用 .粘着位目前只对目录有效 .普通用户对该目录拥有w和x权限，即普通用户可以在此目录拥有写入权限 .如果没有粘着位，因为普通用户拥有w权限，所以可以删除此目录下所有文件，包括其他用户建立的文件。一旦赋予了粘着位，除了root可以删除所有文件，普通用户就算拥有w权限，也只能删除自己建立的文件，但是不能删除其他用户建立的文件。 设置与取消粘着位 1代表SBIT 设置粘着位 .chmod 1755 目录名 .chmod o+t 目录名 取消粘着位 .chmod 777 目录名 .chmod o-t 目录名 文件系统属性chattr权限chattr[+-=][选项]文件或目录名 +：增加权限 -：删除权限 =：等于某权限 选项： i:如果对文件设置i属性，那么不允许对文件进行删除，改名，也不能添加和修改数据；如果对目录设置i属性，那么只能修改目录下文件的数据，但不允许建立和删除文件。 a:如果对文件设置a属性，那么只能在文件中增加数据，但是不能删除也不能修改数据；如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许删除。 2、查看文件系统属性：lsattr 选项 文件名 选项：-a 显示所有文件和目录 -d若目标是目录，仅列出目录本身的属性，而不是子文件的。 系统命令sudo权限1：-root把本来只能超级用户执行的命令赋予普通用户执行-sudo的操作对象是系统命令2：sudo使用visudo #需要超级管理员执行这个命令 实际修改的是/etc/sudoers文件","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"linux学习笔记之常用命令之目录处理命令","slug":"linux学习笔记之常用命令之目录处理命令","date":"2014-03-18T10:35:29.000Z","updated":"2016-12-24T14:25:27.253Z","comments":true,"path":"2014/03/18/linux学习笔记之常用命令之目录处理命令/","link":"","permalink":"http://yoursite.com/2014/03/18/linux学习笔记之常用命令之目录处理命令/","excerpt":"————————常用命令————— 1文件处理命令 1.1命令格式与目录处理命令 1.2目录处理命令 1.3文件处理命令 1.4链接命令 2权限管理命令 3文件搜索命令 4帮助命令 5用户管理命令 6压缩解压命令 7网络命令 8关机重启命令","text":"————————常用命令————— 1文件处理命令 1.1命令格式与目录处理命令 1.2目录处理命令 1.3文件处理命令 1.4链接命令 2权限管理命令 3文件搜索命令 4帮助命令 5用户管理命令 6压缩解压命令 7网络命令 8关机重启命令 1、文件处理命令1.1 命令格式：命令 [-选项][参数] 方括号是可选的 例：ls -la /etc 说明： 1、个别命令使用不遵循此格式 2、当有多个选项时，可以写在一起 -l a—&gt;-la 3、简化选项与完整选项 -a等于–all linux简化的习惯一个- 完整的得用两个– 1.2 目录处理命令：ls 英文原意：list命令所在路径：/bin/ls执行权限：所有用户功能描述：显示目录文件 语法：ls 选项[-ald][文件或目录] -a 显示所有文件，包括隐藏文件 [all] -l 详细信息显示 [long] -h 人性化显示把文件大小显示为KB MB [human] -d 查看目录属性 [directory] -i 查看文件的i节点,可以理解为系统会给每个文件一个ID号 [inode] 任何一个文件的详细信息： -rw-r--r-- 文件类型：- 二进制文件 d 目录[directory] l 软链接文件[link] rw- r-- r-- u g o u所有者 g所有组 o其他人 (在上面rw-三个一组) r读 w写 x执行 mkdir 英文原意：make directories命令所在路径：/bin/mkdir执行权限：所有用户语法：mkdir-p[目录名]功能描述：创建根目录 -p递归创建 范例：mkdir -p /tmp/Japan/boduo mkdir /tmp/Japan/longze/tmp/Japan/canjing 这个会报错 应该如果不-p递归 你在一个本来不存在的目录里面再去创建目录 肯定是不行的 cd 英文原意：change directory;命令所在路径：shell内置命令；执行权限：所有用户；语法：cd[目录]；功能描述：切换目录 范例：cd /tem/Japan/boduo切换到指定目录 cd .. 回到上一级目录 rmdir 英文原意：remove empty directories命令所在路径：/bin/rmdir执行权限：所有用户语法：rmdir[目录名]功能描述：删除空目录 如果不为空得用rm -r xxx 范例：rmdir /tmp/Japan/boduo cp 英文原意：copy ; 命令所在路径：/bin/cp ；执行权限：所有用户;语法：cp -rp [原文件或目录][目标目录] -r 复制目录 -p 保留文件属性功能描述：复制文件或目录(可以同时复制多个文件或目录 只要指定目标位置) 例子：mv -r /tmp/Japan /root/riben 把tmp目录下面的Japan复制到root目录下面并且更改名字为riben mv 英文原意：move命令所在路径:/bin/mv执行权限：所有用户；语法：mv[原文件或目录][目标目录]功能描述:剪切文件或改名 例子：mv /tmp/Japan /root/riben 把tmp目录下面的Japan剪切到root目录下面并且更改名字为riben 改名: cd /root mv Japan riben 如果在当前目录下面mv不就是在改名么！ rm英文原意：remove命令所在路径:/bin/rm执行权限：所有用户语法：rm -rf[文件或目录] -r 删除目录 -f 强制执行功能描述:删除文件 rm grub.config 1.3 文件处理命令 touch命令所在路径:/bin/touch执行权限：所有用户语法：touch[文件名]功能描述：创建空文件 范例：touch Japanlovestory.list //在当前路径下面创建文件 touch /root/Japanlovestory.list //如果加了完整路径则在root路径下面创建一个空文件 linux中并不像window中对特殊符号不允许 但是建议在Linux中也别用 另外注意空格： touch program files 因为在window中可以在文件命名的时候 中间去敲一个空格 但是注意！！这条命令会创建两个文件 program files 如果真的需要创建一个“program files”的文件，可以用引号引起来 touch &quot;program files&quot; 虽然可以敲一个空白符 但是并不建议这么做，因为在以后查找的时候 会产生很多麻烦 cat命令所在路径：/bin/cat执行权限：所有用户语法：cat[文件名]功能描述：显示文件内容 -n显示行号 范例：cat /etc/issue cat -n /etc/services 此命令并适合浏览很长很长的文件！要用more tac命令所在路径：/usr/bin/tac执行权限：所有用户语法：tac [文件名]功能描述：显示文件内容（反向列示）—反过来倒着显示 但是并不支持显示行号 范例：tac /etc/services more命令所在路径：/bin/more执行权限：所有用户语法：more [文件名] 空格或者f 翻页 enter 换行 q或Q 退出功能描述：分页显示文件内容 范例：more /etc/services不足：只可以按往下面翻页 不能往上面翻页 所以得用：less less命令所在路径：/usr/bin/less执行权限：所有用户 语法：less [文件名] pageup向上翻页 空格或者f 翻页 enter 换行 向上方向箭头 上面一行 q或Q 退出 /xxx 搜索关键词xxx n向下切换搜索的结果所在位置[next]功能描述：分页显示文件内容（可向上翻页 并且可以查找） 范例：less /etc/services head命令所在路径：/usr/bin/head执行权限：所有用户语法：head [文件名]功能描述：显示文件前面几行 -n指定行数 范例：head -n 20 /etc/services如果你不指定行号，会默认显示10行。 tail命令所在路径：/usr/bin/tail执行权限：所有用户语法：tail [文件名]功能描述：显示文件后面几行 -n指定行数 -f动态显示文件末尾内容 常用来监控日志 因为它会动态显示 范例：tail -n 18 /etc/services如果你不指定行号，会默认显示10行。 1.4链接命令 ln英文原意：link命令所在路径：/bin/ln执行权限：所有用户 语法：ln -s [原文件][目标文件] -s 创建软链接功能描述：生成链接文件 范例：ln -s /etc/issue /tmp/issue.soft 创建文件/etc/issue的软链接/tmp/issue.soft ln /etc/issue /tmp/issue.hard 创建文件/etc/issue的硬链接/tmp/issue.hard 硬链接没有 -s选项 软链接特征：类似windows快捷方式 1：lrwxrwxrwx l开头表示文件类型为软链接 软链接所有用户的文件权限均为可读可写可执行 2：文件大小 当我们创建一个软链接的时候 跟原文件相比 大小相比原文件小很多，因为它只是一个符号链接 3：/tmp/issue.soft -&gt; /etc/issue 箭头指向源文件 什么时候用软链接即什么时候在window中用快捷方式 硬链接特征： 1：拷贝 cp-p + 同步更新 echo &quot;www.thaibl.com&quot; &gt;&gt; /etc/issue (相当于拷贝并保留原文件属性（最后修改时间，大小，内容）外加同步更新,就算一个文件删除了，另外一个依然存在) 2：通过i节点识别。 当给某个文件创建一个硬链接的时候 我们会发现硬链接文件的节点跟原文件的节点一样。[所以才会实时更新][ls -i] 3：不能跨分区 比如不能把都在 /tmp目录下面的文件 创建到/bin目录下面去 而软链接没有这个限制 4：不能针对目录使用[不能跟某个目录创建硬链接，而软链接没有这个限制] 2、权限管理命令 代表字符 权限 对文件的含义 对目录的含义 r 读权限 可以查看文件的内容 可以列出目录中的内容 w 写权限 可以修改文件内容 可以在目录中创建删除文件 x 执行权限 可以执行文件 可以进入目录 注意：对所属用户来说 一个文件是否有删除权限，要看文件所在的目录是否有写权限假如我们在 root下面创建一个temp目录 然后touch /temp/testfile 然后chmod 777 /temp 再去创建useradd qingwa passwd qingwa 创建一个普通用户qingwa之后再去登录，执行rw /temp/testfile 由于我们设置了temp目录对普通用户来说也是有写的权限，所以能删除！！ chmod命令英文原意：change the permissions mode of a file命令所在路径：/bin/chmode执行权限：所有用户 语法： 一、chmod [{ugoa}{+-=}{rwx}][文件或目录] //u所有者 g所有组 o其他人 +增加权限 -减少权限 =不管你之前有什么权限，现在必须是这个权限 rwx可读可写可执行 例子：chmod u+x /tmp/test.html 即给test.html 所有者增加x可执行的权限 chmod g+x,o-r /tmp/text/html 可以给多个用户修改多个权限，用逗号隔开就行了 二、[mode=421][文件或目录] -------通常用这个 //权限的数字表示,r--4 w---2 x---1 rwxrw-r-- 7 6 4 例子：假如我们想要这个权限640 rw-r----- 可以这样：chmod 640 /tmp/test.html 三、-R 递归修改 假如在tmp/a/b thmod -R 777 /tmp/a 因为是递归修改 我们ls -lh的时候会发现b目录的权限也会被递归修改为777 功能描述：改变文件或目录权限 chown命令英文原意：change file ownership命令所在路径：/bin/chown执行权限：所有用户语法：chown[用户][文件或目录]功能描述：改变文件或目录的所有者 范例：chown qingwa yang //改变文件qingwa的所有者为yang chgrp命令英文原意：change file group ownership命令所在路径：/bin/chgrp执行权限：所有用户语法：chgrp[用户组][文件或目录]功能描述：改变文件或目录的所属组 范例：chgrp lampbrother fengjie //改变文件fengjie的所属组为lampbrother [groupadd 添加用户组] umask英文原意:the user file-creation mask命令所在路径:Shell内置命令执行权限：所有用户语法：umask [-S] -S 以rwx形式显示新建文件缺省权限功能描述：显示、设置文件的缺省权限范例：umask -S注意：linux中创建一个新文件默认是rw-r–r–出于安全考虑是不让新建的文件有可执行的权限644假如我想修改默认新建文件的权限，就是以后创建的新文件的权限为rwxr-xr– 754需要这么做：777-754=023umask 023以后新建的文件的权限就是：rwxr-xr– 754 3、文件搜索命令 在linux中，最重要的事情不是搜索你能找得到文件，而是应该规划好目录结构，放好位置，因为搜索会很占用系统资源，如果在服务器访问高发期间，小心崩溃。 find命令所在路径：/bin/find执行权限：所有用户语法：find [搜索范围][匹配条件]功能描述：文件搜索 A：find /etc -name init 在目录/etc中查找文件名为 init [-iname不区分大小写] B：find /etc -size +204800 在目录/etc下查找大于100M的文件 +n 大于 -n小于 n等于 注意：在linux中得换算为数据块 1数据块等于512字节即0.5k--100M=102400kb=204800kb C：find / -user qingwa 在根目录下面查找所有者为qingwa的文件 -group根据所属组查找 D：find /etc -cmin -5 在/etc下查找5分钟内被修改过属性的文件和目录 -amin 访问时间[access] -cmin 文件属性[change] -mmin 文件内容[modify] +xx表示超过时间 -xx表示多少时间以内 E：find /etc -size +163840 -a -size -204800 在/etc下查找大于80MB小于100MB的文件 -a两个条件同时满足 [and] -o两个条件满足任意一个即可 F：find /etc -name inittab -exec ls -l {}\\; 在/etc下查找inittab文件并显示其详细信息 -exec/ok 命令 {}\\; 对搜索结果执行操作 G：-type根据文件类型查找 f文件 d目录 l软链接文件 H: 根据i节点查找 find . -inum 31531 -exec rm {}\\;查找节点为31531的文件并立即执行删除命令 locate命令所在路径：/usr/bin/locate执行权限：所有用户语法：locate 文件名功能描述：在文件资料库中查找文件 范例：locate inittab -i 选项不区分大小写 注意1：locate搜索速度很快 相当于window那个everything那个软件。原因是：用locate locate 会得到很多行信息，系统会定期把信息存放到mlocate.db文件里，不像find会在某个分区某个文件去查找，只需要搜索mlocate.db这个文件就行了。 但是有一个问题，新建的文件实际上是没有被收录到这个文件里的，所以用locate去查找的时候，是查找不了的。解决办法：执行下update命令 回去更新这个文件资料库，再去查找就会找到了。 注意2：locate是无法找到临时目录下面的文件的 比如/tmp which命令所在路径：/usr/bin/which执行权限：所有用户语法：which命令功能描述：搜索命令所在目录及别名信息 范例：which ls whereis 命令所在路径：/usr/bin/whereis执行权限：所有用户语法：whereis [命令名称]功能描述：搜索命令所在目录及帮助文档路径 范例：whereis ls grep命令所在路径：/bin/grep执行权限：所有用户语法：grep -iv[指定字串][文件]功能描述：在文件中搜寻字串匹配的行并输出 -i 不区分大小写 -v 排除指定字串 范例:grep -i mysql /root/install.log 在/root/install.log文件中不区分大小写的查找mysql grep -v ^# /etc.initab排除以#开头的行的字符串 4、帮助命令 man英文原意：manual命令所在路径：/usr/bin/man执行权限：所在用户语法：man[命令或配置文件]功能描述：获得帮助信息 范例：man ls 查看ls命令的帮助信息 man services 查看配置文件services的帮助信息 man 5 passwd 查看用户信息 Linux中,执行man命令查询帮助文档时,是以vi形式打开帮助文档,所以退出时应该键入:q命令 whatis 命令查看到命令简短的介绍信息[该命令是干什么的] apropos 配置文件的名称查看配置文件的简短信息 技巧：命令 –help 会把该命令常见的选项列出来 touch –help info 跟 man差不多也是显示帮助信息 help命令所在路径：Shell内置命令执行权限：所有用户语法：help命令功能描述：获得Shell内置命令的帮助信息范例：help umask 查看umask命令的帮助信息 用which找不到的命令都是Shell内置命令 5、用户管理命令 useradd 命令所在路径：/usr/sbin/useradd执行权限：root语法：useradd用户名功能描述：添加新用户 范例：useradd qingwa passwd命令所在路径：/usr/bin/passwd执行权限：所有用户语法：passwd用户名功能描述：设置用户密码 范例 passwd amdin888 普通用户只能更改自己的密码 而root可以更改所有用户的密码 who命令所在路径：/usr/bin/who执行权限：所有用户语法：who功能描述：查看登录用户信息 范例：who 显示规则：登录用户名 登录终端 tty本地终端 pts表示远程终端（用不同的数字，终端号来区分不同的登录终端） 登录时间（什么时候登录的） w命令所在路径：/usr/bin/w执行权限：所有用户语法：w功能描述：查看登录用户详细信息 范例：w up linux连续运行多少时间了([uptime命令也行]) ； load average负载均衡的三个值 ； IDLE表示用户登录过来空闲了多久了 ； JCPU当前用户登录过来累计的占用时间； PCPU表示当前登录过来用户当前操作占用的时间 ； WHAT表示当前执行的什么操作、命令 6、压缩解压命令 .gz(window中很少).zip（linux window中都有）.rar(在linux中在需要装一个rar for linux的解压软件) gzip命令所在路径：/bin/gzip执行权限：所有用户语法：gzip [文件]功能描述：压缩文件 注意：跟window是不一样的，只能压缩文件，不能压缩目录，而且压缩完不保留原文件 只剩压缩包了压缩后文件的格式：.gz gunzip命令英文原意：GUNunzip命令所在路径：/bin/gunzip执行权限：所有用户语法：gunzip[压缩文件]功能描述：解压.gz的压缩文件 范例：gunzip buduo.gz tar压缩命令所在路径：/bin/tar执行权限：所有用户 语法：tar 选项[-zcf][压缩后文件名][目录] -c打包 ！！！ -v显示详细信息 -f指定文件名 -z打包同时压缩功能描述：打包目录压缩后文件格式：.tar.gz 例子：tar -cvf Japan.tar.gz Japan 把Japan这个目录压缩成Japan.tar tar解压 -x解包 !!!! -v显示详细信息 -f指定解压软件 -z解压缩 范例：tar -zxvf Japan.tar.gz zip命令所在路径：/usr/bin/zip执行权限：所有用户语法：zip 选项[-r] [压缩后文件名] [文件或目录] -r 压缩目录功能描述：压缩文件或目录压缩后文件格式：.zip 压缩原文件仍未保留 还会显示压缩比 但是压缩比并没有 gzip tar 那么强 解压：unzip [压缩文件] bzip2命令所在路径：/usr/bin/bzip2执行权限：所有用户语法：bzip2 选项 [-k][文件] -k 产生压缩文件后保留原文件功能描述：压缩文件压缩文件格式：.bz2 范例：bzip2 -k boduo tar -cjf Japan.tar.bz2 Japan 把-z换成-j就可以利用tar压缩成.tar.bz2格式 这个压缩格式比率惊人。 bunzip2命令所在路径：/usr/bin/bunzip2执行权限：所有用户语法：bunzip2 选项[-k][压缩文件] -k解压后保留原文件功能描述：解压 范例：bunzip2 -k boduo.bz2 tar -xjf Japan.tar.bz2 7、网络命令 write指令所在路径：/usr/bin/write执行权限：所有用户语法：write &lt;用户名&gt;功能描述：给在线用户发信息（w可以看到哪些用户在线）,ctrl+D保存结束 范例：# write linzhiling xxxxxxxxxxxxx ctrl+D保存结束 wall命令英文原意：write all命令所在路径：/usr/bin/wall执行权限：所有用户语法：wall [message]功能描述：发广播信息(给所有在线用户) 范例：# wall qingwa is a animal ping命令所在路径：/bin/ping执行权限：所有用户语法：ping 选项 IP地址 -c 指定发送次数功能描述：测试网络连通性 范例：# ping 192.168.88.99 ctrl+c结束 ifconfig命令英文原意：interface configure命令所在路径：/sbin/ifconfig执行权限：root语法：ifconfig 网卡名称 IP地址功能描述：查看和设置网卡信息 范例：# ifconfig eth0 192.168.88.99 linux有两套网卡eth0|eth1…本地真实的网卡，按照数字方式一次后推lo 回环网卡，用来本机通信和测试的，地址也是固定的 都是127.0.0.1 mail命令所在路径：/bin/mail执行权限：所有用户语法：mail[用户名]功能描述：查看发送电子邮件 范例：mail root 这个就不像write命令 可以用户不在线 ctrl+D保存结束 last 命令所在路径：/usr/bin/last执行权限：所有用户语法：last功能描述：列出目前与过去登入系统的用户信息 范例：# last [运用非常广泛]这个命令非常有效常用的命令！！可以看 有什么其他用户登录了服务器. 如果有时候我们不想那么多信息，想看到用户最后一次登录的时间，可以用lastlog命令！！ traceroute命令所在路径：/bin/traceroute执行权限：所有用户语法：traceroute功能描述：显示数据包到主机间的路径 范例：traceroute www.thaibl.com[运用非常广泛] netstat命令所在路径：/bin/netstat执行权限：所有用户语法：netstat [选项]功能描述：显示网络相关信息 选项： -t:TCP协议 传输控制协议的简称【三次握手 安全】相当于A打电话B A你是？B你是？ AB要通话了 -u:UDP协议 用户数据报协议【快 不管你在不在线 直接甩给你】相当于发短信 不管你是谁、关机与否、可能被谁看到不管 -l:监听 -r:路由 -n:显示IP地址和端口号 范例： # netstat -tlun 查看本机监听的端口 # netstat -an 查看本机所有的网络连接 # netstat -rn 查看本机路由表 [运用非常广泛，非常重要] setup命令所在路径：/usr/bin/setup执行权限：root语法：setup功能描述：配置网络 范例：# setup 挂载命令mount命令所在位置：/bin/mount执行权限：所有用户命令语法：mount [-t 文件系统] 设备文件名 挂载点 范例： # mount -t iso9660 /dev/sr0/ /mnt/cdrom = mount /dev/sr0/ /mnt/cdrom umount 设备文件名|挂载点umount /dev/sr0 卸载光盘需要跳到宿主目录去执行卸载命令 8、关机重启命令 shutdown 命令语法：shutdown [选项] 时间 选项：-c 取消前一个关机命令 -h 关机 -r 重启 eg：shutdown -h now 马上关机 shutdown -h 20:30 晚上八点关机 shutdown -r now 马上重启 shutdown -c 取消前一个关机命令 linux中还有其他重启关机命令，但是早期只有shutdown保存原来开启的服务 现在其他的也有了 但还是推荐这个老命令 提醒：关机或重启之前必须先把服务停掉！这样才能保证用户不能碰触我，硬盘才会空闲下来，才会重启。 服务器不能关机 只能重启！！！ 其他关机命令：halt poweroff 这个就不要用了 直接断电!!! init 0 其他重启命令：reboot init 6 系统运行级别： 0：关机 1：单用户（类似windows启动时按F8进入安全模式，其实就是启动最小的服务，其他多余附加的程序都不用，只启动核心的程序，用来做一些修复。只能root登录进去） 2：不完全多用户，不含NFS服务 3：完全多用户 4：未分配 5：图形界面 6：重启 cat /etc/inittab #修改系统默认运行级别 id:3:initdefault: `runlevel` #查询系统运行级别 退出登录命令：logout","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"linux学习笔记之vim","slug":"linux学习笔记之vim","date":"2014-03-17T14:52:07.000Z","updated":"2016-12-24T14:25:00.573Z","comments":true,"path":"2014/03/17/linux学习笔记之vim/","link":"","permalink":"http://yoursite.com/2014/03/17/linux学习笔记之vim/","excerpt":"一、Vim常用操作Vim是一个功能强大的全屏幕文本编辑器。是linux/unix上最常用的文本编辑器。它的作用是建立、编辑、显示文本文件。 Vim没有菜单，只有命令！ Vim三个工作模式： 命令模式 vi filename 进去命令模式 输入:wq保存退出 插入模式 当你在命令模式的时候，输入插入命令 i a o就可以进入插入模式，进入插入模式的标志是下方出现了INSERT字样。按ESC退出。 编辑模式 当你是命令模式的时候，按一个冒号 &apos;:&apos;就可以进入编辑模式。比如set number命令设置行号 设置完就回到命令模式","text":"一、Vim常用操作Vim是一个功能强大的全屏幕文本编辑器。是linux/unix上最常用的文本编辑器。它的作用是建立、编辑、显示文本文件。 Vim没有菜单，只有命令！ Vim三个工作模式： 命令模式 vi filename 进去命令模式 输入:wq保存退出 插入模式 当你在命令模式的时候，输入插入命令 i a o就可以进入插入模式，进入插入模式的标志是下方出现了INSERT字样。按ESC退出。 编辑模式 当你是命令模式的时候，按一个冒号 &apos;:&apos;就可以进入编辑模式。比如set number命令设置行号 设置完就回到命令模式 插入命令： 命令 作用 a 在光标所在字符后插入 A 在光标所在行尾插入 i 在光标所在字符前插入 I 在光标所在行行首插入 o 在光标下面插入新行 O 在光标上面插入新行 定位命令： 命令 作用 :set nu 设置行号 :set nonu 取消行号 gg 到第一行 G 到最后一行 nG 到第n行 :n 到第n行 $ 移至行尾 0 移至行首 删除命令： 命令 作用 x 删除光标所在处字符 nx 删除光标所在处后n个字符 dd 删除光标所在行 ndd删除n行 dG 删除光标所在行到文件末尾内容 D 删除光标所在处到行尾内容 :n1,n2d 删除n1行到n2行指定范围的行 复制和剪切命令 命令 作用 yy 复制当前行 nyy 复制当前行以下n行 dd 剪切当前行 ndd 复制当前行以下n行 p或P 粘贴在当前光标所在行下或行上 替换和取消命令 命令 作用 r 取代光标所在处字符 R 从光标所在处开始替换字符，按Esc结束 【下方会出现replace字符】 u 取消上一步操作 搜索和搜索替换命令 命令 作用 /string 1:搜索指定的字符串 2：搜索时忽略大小写 :set ic n 搜索指定字符串的下一个出现位置 :%s/old/new/g 全文替换指定字符串 :n1,n2s/old/new/g 在一定范围内替换指定字符串 :替换范围 %s 全文替换 起始行,终止行 s /要替换的字符串/替换的新的字符串/g c 询问确认 保存和退出命令 命令 作用 :w 保存修改 :W new_filename 另存为指定文件 :wq 保存修改并退出 ZZ 快捷键，保存修改并退出 :q! 不保存修改退出 :wq! 保存修改并退出（文件所有者及root可使用） 二、Vim常用技巧–技巧1———————————————–:r 文件名 ----把文件内容导入到刚刚光标所在的位置 :! 命令 -----可以执行命令 例如 :!which ls ----可以查看ls命令所在位置 可以把以上结合起来，可以把一个命令执行结果导入文件中 :r !命令 –技巧2———————————————–定义快捷键 :map 快捷键 触发命令 范例： :map ^P I#&lt;ESC&gt; 定义快捷键位ctrl+P 触发的命令为 I跳到行首并进入插入模式，然后插入#号，然后进入到命令模式 :map ^B 0x 定义快捷键ctrl+B 触发的命令为 0光标跳到行首并删除光标所在的字符 即可实现：删除注释 注意：快捷键一般跟ctrl结合起来 这里的^不是数字6那个 实际是ctrl+v 可以结合快捷键三个键一起按！ –技巧3———————————————–连续行注释 :n1,n2s/^/#/g 连续多行注释 :n1,n2s/^#//g 去掉连续多行的注释 :n1,n2s/^/\\/\\//g 有些程序我们需要//注释的时候 可以连续多行这个命令 –技巧4———————————————–替换 :ab mymail 763191973@qq.com 在用vim编辑器执行 以上 当我们在插入模式 的时候 输入mymail的时候 一回车就会变成了763191973@qq.com 注意!!!!：如果有定义的快捷键 ab在重启的时候 会发现都消失 如果你想永久有效 需要写在每个用户的宿主目录下面的家目录下面的配置文件里面。如果是root就在/root目录下面，如果是其他用户就在/home/xx下面。文件.vimrc 可以存放一些编辑模式的命令 快捷键 ab","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"VIM","slug":"VIM","permalink":"http://yoursite.com/tags/VIM/"}]}]}