<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Renqiang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://renqiangme.github.io/"/>
  <updated>2018-11-22T02:19:40.118Z</updated>
  <id>https://renqiangme.github.io/</id>
  
  <author>
    <name>Renqiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>给MongoDB新增一个readWriteAnyDatabase的角色账户</title>
    <link href="https://renqiangme.github.io/2018/05/01/%E7%BB%99MongoDB%E6%96%B0%E5%A2%9E%E4%B8%80%E4%B8%AAreadWriteAnyDatabase%E7%9A%84%E8%A7%92%E8%89%B2%E8%B4%A6%E6%88%B7/"/>
    <id>https://renqiangme.github.io/2018/05/01/给MongoDB新增一个readWriteAnyDatabase的角色账户/</id>
    <published>2018-05-01T09:18:01.000Z</published>
    <updated>2018-11-22T02:19:40.118Z</updated>
    
    <content type="html"><![CDATA[<p>安装好MongoDB时，通常开了一个最高管理权限的root账户来方便我们管理数据库，实际开发中并一般不使用这个账户，我们可以单独添加一个账户来连接数据库。</p><a id="more"></a><h5 id="MongoDB的账户角色："><a href="#MongoDB的账户角色：" class="headerlink" title="MongoDB的账户角色："></a>MongoDB的账户角色：</h5><p>数据库用户角色：read、readWrite</p><p>数据库管理角色：dbAdmin、dbOwner、userAdmin</p><p>集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManage</p><p>备份恢复角色：backup、restore</p><p>所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</p><p>超级用户角色：root</p><p>内部角色：__system</p><p><code>Read</code>：允许用户读取指定数据库</p><p><code>readWrite</code>：允许用户读写指定数据库</p><p><code>dbAdmin</code>：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile</p><p><code>userAdmin</code>：允许用户向system.users集合写入，可以在指定数据库里创建、删除和管理用户</p><p><code>clusterAdmin</code>：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。</p><p><code>readAnyDatabase</code>：只在admin数据库中可用，赋予用户所有数据库的读权限</p><p><code>readWriteAnyDatabase</code>：只在admin数据库中可用，赋予用户所有数据库的读写权限</p><p><code>userAdminAnyDatabase</code>：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限</p><p><code>dbAdminAnyDatabase</code>：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。</p><p><code>root</code>：只在admin数据库中可用。超级账号，超级权限</p><h5 id="新增一个readWriteAnyDatabase的角色账户"><a href="#新增一个readWriteAnyDatabase的角色账户" class="headerlink" title="新增一个readWriteAnyDatabase的角色账户"></a>新增一个readWriteAnyDatabase的角色账户</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#以root登录(这个root的角色是userAdminAnyDatabase)</div><div class="line">./mongo --port 27017 -u &quot;root&quot; -p &quot;xxx&quot; --authenticationDatabase &quot;admin&quot; </div><div class="line"></div><div class="line">#切换到admin db</div><div class="line">use admin</div><div class="line"></div><div class="line">#查看所有用户</div><div class="line">db.system.users.find()</div><div class="line"></div><div class="line">#新增用户，并授予readWriteAnyDatabase的角色</div><div class="line">db.createUser(&#123;user:&quot;mongodb-admin&quot;,pwd:&quot;123456&quot;,roles:[&#123;role:&quot;readWriteAnyDatabase&quot;, db:&quot;admin&quot;&#125;]&#125;)</div><div class="line"></div><div class="line">#新增xxxx角色</div><div class="line">#db.grantRolesToUser(&quot;mongodb-admin&quot;,[&#123;role:&quot;xxx&quot;,db:&quot;admin&quot;&#125;])</div><div class="line"></div><div class="line">#以mongodb-admin登录</div><div class="line">mongo --port 27017 -u mongodb-admin -p &apos;123456&apos; --authenticationDatabase &apos;admin&apos;</div><div class="line"></div><div class="line">#测试创建集合和查询，如果没有报错，说明权限已经ok</div><div class="line">use test</div><div class="line">db.createCollection(&quot;Account&quot;)</div><div class="line">db.Account.find()</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装好MongoDB时，通常开了一个最高管理权限的root账户来方便我们管理数据库，实际开发中并一般不使用这个账户，我们可以单独添加一个账户来连接数据库。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://renqiangme.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://renqiangme.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>使用Systemd部署管理SpringBoot应用</title>
    <link href="https://renqiangme.github.io/2018/04/17/%E4%BD%BF%E7%94%A8System%E9%83%A8%E7%BD%B2SpringBoot%E5%BA%94%E7%94%A8/"/>
    <id>https://renqiangme.github.io/2018/04/17/使用System部署SpringBoot应用/</id>
    <published>2018-04-17T05:28:12.000Z</published>
    <updated>2018-11-22T02:09:55.586Z</updated>
    
    <content type="html"><![CDATA[<p>如果不使用<code>Docker</code>和<code>Kubernets</code>部署管理<code>SpringBoot</code>应用，可以选择<code>Systemd</code>。</p><p>因为SpringBoot自带Tomcat之类的Web应用服务器，可以直接<code>java -jar xxx.jar</code>的方式启动起来。</p><p>如果我们直接使用<code>nohup java -jar xxx.jar &amp;</code> 之类的虽然也可以实现后台运行，但是是有可能因为某些原因挂掉的，所以我们需要找到一种工具让应用可以重启或者开机启动。</p><p>我们可以使用Python的<code>Supervisor</code>,也有盆友说可以使用Node的<code>pm2</code>,但是我一般都是选择<code>Systemd</code>，现在Linux系统都是自带这个的。</p><a id="more"></a><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p>生成jar包：进入到SpringBoot项目的目录，然后执行：<code>mvn clean package</code>，找到target目录里面的jar包。</p><p>上传jar包：scp -P xx_port xxx.jar username@host:./</p><p>SSH登录进入服务器之后，首先需要安装JDK,然后把jar包复制到/home/www/applications</p><p>在/etc/systemd/system/目录下面新建一个service的配置，配置内容参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[Unit]</div><div class="line">Description=service-test</div><div class="line">After=syslog.target</div><div class="line"></div><div class="line">[Service]</div><div class="line">User=root</div><div class="line">WorkingDirectory=/home/www/applications</div><div class="line">Restart=always</div><div class="line">ExecStart=/usr/local/jdk1.8.0_161/bin/java -jar /home/www/applications/service-test-1.0.jar</div><div class="line">ExecStop=/usr/bin/kill -15  $MAINPID</div><div class="line">SuccessExitStatus=143</div><div class="line"></div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target</div></pre></td></tr></table></figure><p>新增一个新的service之后，需要让配置生效,如果修改配置文件，需要reload。</p><p>使xx service生效:<br><code>systemctl enable xx.service</code></p><p>刷新配置:<br><code>systemctl daemon-reload</code></p><p>启动xx service:</p><p><code>systemctl start xx.service</code></p><p>查看xx service的status:</p><p><code>systemctl status xx.service</code></p><p>重启xx service:</p><p><code>systemctl restart xx.service</code></p><p>看xx service日志,按住shift+g可以跳转到最后一行:</p><p><code>journalctl -u xx.service</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果不使用&lt;code&gt;Docker&lt;/code&gt;和&lt;code&gt;Kubernets&lt;/code&gt;部署管理&lt;code&gt;SpringBoot&lt;/code&gt;应用，可以选择&lt;code&gt;Systemd&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因为SpringBoot自带Tomcat之类的Web应用服务器，可以直接&lt;code&gt;java -jar xxx.jar&lt;/code&gt;的方式启动起来。&lt;/p&gt;
&lt;p&gt;如果我们直接使用&lt;code&gt;nohup java -jar xxx.jar &amp;amp;&lt;/code&gt; 之类的虽然也可以实现后台运行，但是是有可能因为某些原因挂掉的，所以我们需要找到一种工具让应用可以重启或者开机启动。&lt;/p&gt;
&lt;p&gt;我们可以使用Python的&lt;code&gt;Supervisor&lt;/code&gt;,也有盆友说可以使用Node的&lt;code&gt;pm2&lt;/code&gt;,但是我一般都是选择&lt;code&gt;Systemd&lt;/code&gt;，现在Linux系统都是自带这个的。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://renqiangme.github.io/categories/JAVA/"/>
    
    
      <category term="Systemd" scheme="https://renqiangme.github.io/tags/Systemd/"/>
    
      <category term="JAVA" scheme="https://renqiangme.github.io/tags/JAVA/"/>
    
      <category term="SpringBoot" scheme="https://renqiangme.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Log4j2日志-&gt;Kafka-&gt;LogStash-&gt;ElasticSearch并邮件报警</title>
    <link href="https://renqiangme.github.io/2018/01/21/Log4j2%E6%97%A5%E5%BF%97-%3EKafka-%3ELogstash-%3EElasticsearch%E5%B9%B6%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6/"/>
    <id>https://renqiangme.github.io/2018/01/21/Log4j2日志-&gt;Kafka-&gt;Logstash-&gt;Elasticsearch并邮件报警/</id>
    <published>2018-01-21T11:08:28.000Z</published>
    <updated>2018-11-08T05:04:23.362Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot项目中需要把日志记录到<a href="https://www.elastic.co/cn/products/elasticsearch" target="_blank" rel="external">：ElasticSearch</a> 并使用 <a href="https://www.elastic.co/cn/products/kibana" target="_blank" rel="external">：Kibana</a> 搜索、展示、查看日志。</p><h4 id="修改SpringBoot中的配置"><a href="#修改SpringBoot中的配置" class="headerlink" title="修改SpringBoot中的配置"></a>修改SpringBoot中的配置</h4><p>因为SpringBoot默认使用的日志框架是：<a href="http://logback.qos.ch/" target="_blank" rel="external">：Logback</a>，但是<a href="https://logging.apache.org/log4j/2.x/" target="_blank" rel="external">：Log4j2</a> 性能可能更高就打算替换掉。</p><a id="more"></a><p>替换方法，修改项目maven的pom.xml配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</div><div class="line">    &lt;exclusions&gt;</div><div class="line">        &lt;exclusion&gt;</div><div class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</div><div class="line">        &lt;/exclusion&gt;</div><div class="line">    &lt;/exclusions&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><p>因为需要把日志记录到Kafka，所以引入org.apache.kafka kafka-clients到项目中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;0.10.0.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><p>因为日志在本地测试和线上的kafka的服务器需要分开，通常我们可以在resources目录下面创建：</p><ul><li>本地的log4j2的配置文件名叫log4j2-dev.xml</li><li>正式线上的log4j2的配置文件名叫log4j2-prd.xml</li></ul><p>然后我们可以修改SpringBoot的bootstrap.properties，<code>ACTIVE_ENVIRONMENT</code>为环境变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">spring.profiles.active=$&#123;ACTIVE_ENVIRONMENT:dev&#125;</div><div class="line">logging.config=classpath:log4j2-$&#123;ACTIVE_ENVIRONMENT&#125;.xml</div></pre></td></tr></table></figure></p><p>log4j2-xxx.xml的内容例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;Configuration status=&quot;warn&quot;&gt;</div><div class="line">    &lt;Properties&gt;</div><div class="line">    &lt;/Properties&gt;</div><div class="line">    &lt;Appenders&gt;</div><div class="line">        &lt;Console name=&quot;STDOUT&quot; target=&quot;SYSTEM_OUT&quot;&gt;</div><div class="line">            &lt;PatternLayout pattern=&quot;%d %p %c&#123;1.&#125; %t %m%n&quot;/&gt;</div><div class="line">        &lt;/Console&gt;</div><div class="line">         &lt;Kafka name=&quot;KAFKA-LOGGER&quot; topic=&quot;service-logs-dialog-service&quot;&gt;&lt;!--kafka topic--&gt;</div><div class="line">            &lt;JsonLayout/&gt; &lt;!--JsonLayout：日志格式为json,方便在Elastic中处理--&gt;</div><div class="line">            &lt;Property name=&quot;bootstrap.servers&quot;&gt;10.2.200.26:9092&lt;/Property&gt;&lt;!--kafka server的ip:port--&gt;</div><div class="line">            &lt;Property name =&quot;retries&quot; &gt;3&lt;/Property&gt;</div><div class="line">            &lt;Property name =&quot;linger.ms&quot; &gt;1000&lt;/Property&gt;</div><div class="line">            &lt;Property name =&quot;buffer.memory&quot; &gt; 10485760&lt;/Property&gt;</div><div class="line">        &lt;/Kafka&gt;</div><div class="line">        &lt;Async name=&quot;ASYNC-KAFKA-LOGGER&quot;&gt;</div><div class="line">            &lt;AppenderRef ref=&quot;KAFKA-LOGGER&quot;/&gt;</div><div class="line">            &lt;LinkedTransferQueue/&gt;</div><div class="line">        &lt;/Async&gt;</div><div class="line">    &lt;/Appenders&gt;</div><div class="line">    &lt;Loggers&gt;</div><div class="line">        &lt;logger name=&quot;ai.emos.platform.dialog&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;&lt;!--日志级别大于info都会被记录到Kafka--&gt;</div><div class="line">            &lt;AppenderRef ref=&quot;KAFKA-LOGGER&quot;/&gt;</div><div class="line">        &lt;/logger&gt;</div><div class="line">        &lt;!-- Root表示所有Logger用Root中的Appender打印日志  --&gt;</div><div class="line">        &lt;Root level=&quot;info&quot;&gt;</div><div class="line">            &lt;AppenderRef ref=&quot;STDOUT&quot;/&gt;</div><div class="line">            &lt;AppenderRef ref=&quot;ASYNC-KAFKA-LOGGER&quot;/&gt;</div><div class="line">        &lt;/Root&gt;</div><div class="line">    &lt;/Loggers&gt;</div><div class="line">&lt;/Configuration&gt;</div></pre></td></tr></table></figure></p><h4 id="在LogStash中的配置"><a href="#在LogStash中的配置" class="headerlink" title="在LogStash中的配置"></a>在LogStash中的配置</h4><p>LogStash组成结构：<br>Logstash 通过管道进行运作，管道有两个必需的元素，输入和输出，还有一个可选的元素，过滤器。输入插件从数据源获取数据，过滤器插件根据用户指定的数据格式修改数据，输出插件则将数据写入到目的地。<br>因此，需要一个配置文件管理输入、过滤器和输出相关的配置。配置文件内容格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#　输入</div><div class="line">input &#123;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 过滤器</div><div class="line">filter &#123;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 输出</div><div class="line">output &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>所以我们创建一个文件到LogStash的配置文件：logstash.yml中path.config配置的扫描目录。</p><p>service-logs.conf配置文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">input &#123;</div><div class="line">   kafka &#123;</div><div class="line">        topics_pattern =&gt; [&quot;service-logs-.*&quot;]</div><div class="line">        bootstrap_servers =&gt; &quot;10.1.220.27:9092&quot;</div><div class="line">        group_id =&gt; &quot;local-logstash&quot;</div><div class="line">        decorate_events =&gt; true</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">filter &#123;</div><div class="line">    json &#123;</div><div class="line">        source =&gt; &quot;message&quot;</div><div class="line">    &#125;</div><div class="line">    mutate &#123;</div><div class="line">        add_field =&gt; &#123;</div><div class="line">                &quot;kafka_topic&quot; =&gt; &quot;%&#123;[@metadata][kafka][topic]&#125;&quot;</div><div class="line">                &quot;kafka_consumer_group&quot; =&gt; &quot;%&#123;[@metadata][kafka][consumer_group]&#125;&quot;</div><div class="line">                &quot;kafka_partition&quot; =&gt; &quot;%&#123;[@metadata][kafka][partition]&#125;&quot;</div><div class="line">                &quot;kafka_offset&quot; =&gt; &quot;%&#123;[@metadata][kafka][offset]&#125;&quot;</div><div class="line">                &quot;kafka_timestamp&quot; =&gt; &quot;%&#123;[@metadata][kafka][timestamp]&#125;&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">output &#123;</div><div class="line">  if [level] == &quot;ERROR&quot; &#123;</div><div class="line">        http &#123;</div><div class="line">                url =&gt; &quot;http://localhost:8088/send/mail&quot;</div><div class="line">                http_method =&gt; &quot;post&quot;</div><div class="line">                automatic_retries =&gt; 0</div><div class="line">                connect_timeout =&gt; 6</div><div class="line">                keepalive =&gt; false</div><div class="line">        &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  elasticsearch &#123;</div><div class="line">        hosts =&gt; [&quot;127.0.0.1:9200&quot;]</div><div class="line">        action =&gt; &quot;index&quot;</div><div class="line">        index =&gt; &quot;logstash-%&#123;[kafka_topic]&#125;&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们可以看到上面output针对日志级别是ERROR的会发送一个HTTP请求到一个发邮件的服务器，因为LogStash自带的邮件发不出来，所以单独用了nodejs写了一个发邮件接口。</p><p>如果使用LogStash自带的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">output &#123;</div><div class="line">      if [level] == &quot;ERROR&quot; &#123;</div><div class="line">            email &#123;</div><div class="line">                    debug =&gt; true</div><div class="line">                    to =&gt; &quot;xx@qq.com&quot;</div><div class="line">                    from =&gt; &quot;xxx@126.com&quot;</div><div class="line">                    subject =&gt; &apos;Alert - Error&apos;</div><div class="line">                    codec =&gt; &quot;plain&quot;</div><div class="line">                    contenttype =&gt; &quot;text/html; charset=UTF-8&quot;</div><div class="line">                    body =&gt; &quot;Tags: %&#123;tags&#125;\\n\\Content:\\n%&#123;message&#125;&quot;</div><div class="line">                    username =&gt; &quot;xxx@126.com&quot;</div><div class="line">                    password =&gt; &quot;xxx&quot;</div><div class="line">                    address =&gt; &quot;smtp.126.com&quot;</div><div class="line">                    domain =&gt; &quot;smtp.126.com&quot;</div><div class="line">                    port =&gt; 25</div><div class="line">                    use_tls =&gt; false</div><div class="line">                    via =&gt; &quot;smtp&quot;</div><div class="line">            &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>LogStash的功能很强大，更多可以阅读官方的文档。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringBoot项目中需要把日志记录到&lt;a href=&quot;https://www.elastic.co/cn/products/elasticsearch&quot;&gt;：ElasticSearch&lt;/a&gt; 并使用 &lt;a href=&quot;https://www.elastic.co/cn/products/kibana&quot;&gt;：Kibana&lt;/a&gt; 搜索、展示、查看日志。&lt;/p&gt;
&lt;h4 id=&quot;修改SpringBoot中的配置&quot;&gt;&lt;a href=&quot;#修改SpringBoot中的配置&quot; class=&quot;headerlink&quot; title=&quot;修改SpringBoot中的配置&quot;&gt;&lt;/a&gt;修改SpringBoot中的配置&lt;/h4&gt;&lt;p&gt;因为SpringBoot默认使用的日志框架是：&lt;a href=&quot;http://logback.qos.ch/&quot;&gt;：Logback&lt;/a&gt;，但是&lt;a href=&quot;https://logging.apache.org/log4j/2.x/&quot;&gt;：Log4j2&lt;/a&gt; 性能可能更高就打算替换掉。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://renqiangme.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="https://renqiangme.github.io/tags/JAVA/"/>
    
      <category term="Kafka" scheme="https://renqiangme.github.io/tags/Kafka/"/>
    
      <category term="LogStash" scheme="https://renqiangme.github.io/tags/LogStash/"/>
    
      <category term="ElasticSearch" scheme="https://renqiangme.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>Git的一些操作记录</title>
    <link href="https://renqiangme.github.io/2018/01/12/Git%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    <id>https://renqiangme.github.io/2018/01/12/Git的一些操作记录/</id>
    <published>2018-01-12T01:30:28.000Z</published>
    <updated>2018-11-08T03:47:51.989Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Git撤销某个commit"><a href="#Git撤销某个commit" class="headerlink" title="Git撤销某个commit"></a>Git撤销某个commit</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码,同时清空了暂存区(回退commit和index信息)</div><div class="line">git reset –soft：回退到某个版本，只回退了commit的信息，git不会清除你的暂存区。如果还要提交，直接commit即可</div><div class="line">git reset –hard：彻底回退到某个版本，直接覆盖工作区，暂存区，本地的源码所有的内容也会变为上一个版本的内容</div><div class="line"></div><div class="line">Git撤销命令后面的可选参数：</div><div class="line">HEAD 最近一个提交</div><div class="line">HEAD^ 上一次</div><div class="line">&lt;commit_id&gt;  每次commit的SHA1值. 可以用git log 看到,也可以在页面上commit标签页里找到</div></pre></td></tr></table></figure><a id="more"></a><p>如果本地的源码彻底回退到某个版本，并希望远程Git仓库的记录也回滚的话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git reset --hard &lt;commit_id&gt;</div><div class="line">git push origin HEAD --force</div></pre></td></tr></table></figure><p>如果本地的源码彻底回退到某个版本，又想回滚到回滚前的某个版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reflog</div></pre></td></tr></table></figure><p>git reflog 可以查看所有分支的所有操作记录（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录。</p><h4 id="修改Git使用的远程仓库"><a href="#修改Git使用的远程仓库" class="headerlink" title="修改Git使用的远程仓库"></a>修改Git使用的远程仓库</h4><p>三种方式：</p><p>1：修改命令 git remte origin set-url url</p><p>2：先删后加 git remote rm origin &amp;&amp; git remote add origin url</p><p>3：直接修改文件: .git/config</p><h4 id="打包出Git两个commit之间提交过的文件"><a href="#打包出Git两个commit之间提交过的文件" class="headerlink" title="打包出Git两个commit之间提交过的文件"></a>打包出Git两个commit之间提交过的文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff xxx xxx --name-only | xargs tar -cvzf update.tar.gz</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Git撤销某个commit&quot;&gt;&lt;a href=&quot;#Git撤销某个commit&quot; class=&quot;headerlink&quot; title=&quot;Git撤销某个commit&quot;&gt;&lt;/a&gt;Git撤销某个commit&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码,同时清空了暂存区(回退commit和index信息)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git reset –soft：回退到某个版本，只回退了commit的信息，git不会清除你的暂存区。如果还要提交，直接commit即可&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git reset –hard：彻底回退到某个版本，直接覆盖工作区，暂存区，本地的源码所有的内容也会变为上一个版本的内容&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Git撤销命令后面的可选参数：&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;HEAD 最近一个提交&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;HEAD^ 上一次&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;commit_id&amp;gt;  每次commit的SHA1值. 可以用git log 看到,也可以在页面上commit标签页里找到&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Git" scheme="https://renqiangme.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://renqiangme.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装Elastic Stack</title>
    <link href="https://renqiangme.github.io/2018/01/02/Ubuntu%E5%AE%89%E8%A3%85Elastic%20Stack/"/>
    <id>https://renqiangme.github.io/2018/01/02/Ubuntu安装Elastic Stack/</id>
    <published>2018-01-02T08:18:08.000Z</published>
    <updated>2018-11-08T02:36:30.333Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-首先安装python-software-properties"><a href="#1-首先安装python-software-properties" class="headerlink" title="1.首先安装python-software-properties"></a>1.首先安装python-software-properties</h4><p>该程序将安装add-apt-repository的应用程序，更加方便的添加和使用PPA软件库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install -y python-software-properties software-properties-common apt-transport-https</div></pre></td></tr></table></figure><a id="more"></a><h4 id="2-安装java8"><a href="#2-安装java8" class="headerlink" title="2.安装java8"></a>2.安装java8</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:webupd8team/java -y</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install -y oracle-java8-installer</div></pre></td></tr></table></figure><p>打印java的版本信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -version</div></pre></td></tr></table></figure><h4 id="3-安装elastic"><a href="#3-安装elastic" class="headerlink" title="3.安装elastic"></a>3.安装elastic</h4><h5 id="3-1：安装之前先添加elastic-repository-key-到server"><a href="#3-1：安装之前先添加elastic-repository-key-到server" class="headerlink" title="3.1：安装之前先添加elastic repository key 到server"></a>3.1：安装之前先添加elastic repository key 到server</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -</div></pre></td></tr></table></figure><h5 id="3-2：找到当前的文档版本，导入当前的repository到sources-list-d："><a href="#3-2：找到当前的文档版本，导入当前的repository到sources-list-d：" class="headerlink" title="3.2：找到当前的文档版本，导入当前的repository到sources.list.d："></a>3.2：找到当前的文档版本，导入当前的repository到sources.list.d：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;deb https://artifacts.elastic.co/packages/6.x/apt stable main&quot; | sudo tee -a /etc/apt/sources.list.d/elastic-6.x.list</div></pre></td></tr></table></figure><h4 id="4-安装elasticsearch"><a href="#4-安装elasticsearch" class="headerlink" title="4:安装elasticsearch"></a>4:安装elasticsearch</h4><p>Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。</p><p>但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。</p><p>Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p><p>不过，Elasticsearch不仅仅是Lucene和全文搜索，我们还能这样去描述它：</p><p>分布式的实时文件存储，每个字段都被索引并可被搜索</p><p>分布式的实时分析搜索引擎</p><p>可以扩展到上百台服务器，处理PB级结构化或非结构化数据</p><p>而且，所有的这些功能被集成到一个服务里面，你的应用可以通过简单的RESTful API、各种语言的客户端甚至命令行与之交互<br>。</p><h5 id="4-1-安装及修改配置文件"><a href="#4-1-安装及修改配置文件" class="headerlink" title="4.1:安装及修改配置文件"></a>4.1:安装及修改配置文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install -y elasticsearch</div></pre></td></tr></table></figure><p>配置文件路径：/etc/elasticsearch/elasticsearch.yml </p><p>可以修改host，port….</p><h5 id="4-2-加入开机自启动服务"><a href="#4-2-加入开机自启动服务" class="headerlink" title="4.2:加入开机自启动服务"></a>4.2:加入开机自启动服务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo systemctl daemon-reload</div><div class="line">sudo systemctl enable elasticsearch</div><div class="line">sudo systemctl start elasticsearch</div></pre></td></tr></table></figure><h5 id="4-3-通过system进行管理elasticsearch"><a href="#4-3-通过system进行管理elasticsearch" class="headerlink" title="4.3:通过system进行管理elasticsearch"></a>4.3:通过system进行管理elasticsearch</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">systemctl status elasticsearch</div><div class="line"></div><div class="line">systemctl start elasticsearch</div><div class="line"></div><div class="line">systemctl stop elasticsearch</div><div class="line"></div><div class="line">systemctl restart elasticsearch</div></pre></td></tr></table></figure><h5 id="4-4-查看运行情况"><a href="#4-4-查看运行情况" class="headerlink" title="4.4:查看运行情况"></a>4.4:查看运行情况</h5><p>查看端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -plntu</div></pre></td></tr></table></figure><p>查看elasticsearch的cluster,版本..相关信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;localhost:9200/?pretty&apos;</div></pre></td></tr></table></figure><p>查看集群健康情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/_cat/health?v&apos;</div></pre></td></tr></table></figure><p>查看集群中的节点列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/_cat/nodes?v&apos;</div></pre></td></tr></table></figure><p>查看index情况:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/_cat/indices?v&apos;</div></pre></td></tr></table></figure><h5 id="4-4-参考文档"><a href="#4-4-参考文档" class="headerlink" title="4.4:参考文档"></a>4.4:参考文档</h5><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/cn/index.html" target="_blank" rel="external">Elasticsearch: 权威指南</a></p><h4 id="5-安装Kibana"><a href="#5-安装Kibana" class="headerlink" title="5:安装Kibana"></a>5:安装Kibana</h4><p>Kibana是一个为Elasticsearch平台分析和可视化的开源平台，使用Kibana能够搜索、展示存储在Elasticsearch中的索引数据。使用它可以很方便用图表、表格、地图展示和分析数据。<br>Kibana能够轻松处理大量数据，通过浏览器接口能够轻松的创建和分享仪表盘，通过改变Elasticsearch查询时间，可以完成动态仪表盘。</p><h5 id="5-1-通过apt安装及配置"><a href="#5-1-通过apt安装及配置" class="headerlink" title="5.1:通过apt安装及配置"></a>5.1:通过apt安装及配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install -y kibana</div></pre></td></tr></table></figure><p>配置文件路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/kibana/kibana.yml</div></pre></td></tr></table></figure><p>可以修改host,port,以及elasticsearch的url</p><h5 id="5-2-加入开机自启动"><a href="#5-2-加入开机自启动" class="headerlink" title="5.2:加入开机自启动"></a>5.2:加入开机自启动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo systemctl enable kibana</div><div class="line">sudo systemctl start kibana</div></pre></td></tr></table></figure><h5 id="5-3-通过system进行管理kibana"><a href="#5-3-通过system进行管理kibana" class="headerlink" title="5.3:通过system进行管理kibana"></a>5.3:通过system进行管理kibana</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">systemctl status kibana</div><div class="line"></div><div class="line">systemctl start kibana</div><div class="line"></div><div class="line">systemctl stop kibana</div><div class="line"></div><div class="line">systemctl restart kibana</div></pre></td></tr></table></figure><h4 id="6-安装Logstash"><a href="#6-安装Logstash" class="headerlink" title="6:安装Logstash"></a>6:安装Logstash</h4><p>Logstash 是一个开源的数据收集引擎具有实时管道能力。</p><p>Logstash 可以动态的统一数据从不同的来源和使数据规范化到你选择的目的地。</p><p>当Logstash 起初驾驭创新到日志收集,它的功能很好的扩展超出使用案例。任何事件的类型可以被丰富和改变使用一个input,filter和输出引擎,使用很多的本地的代码简化了采集的过程。</p><h5 id="6-1-通过apt安装"><a href="#6-1-通过apt安装" class="headerlink" title="6.1:通过apt安装"></a>6.1:通过apt安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install -y logstash</div></pre></td></tr></table></figure><h5 id="6-2-logstash的配置文件目录："><a href="#6-2-logstash的配置文件目录：" class="headerlink" title="6.2:logstash的配置文件目录："></a>6.2:logstash的配置文件目录：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/etc/logstash/</div><div class="line"></div><div class="line">├── conf.d</div><div class="line">│   └── kafka-logs-local.conf</div><div class="line">├── jvm.options</div><div class="line">├── log4j2.properties</div><div class="line">├── logstash.yml</div><div class="line">└── startup.options</div></pre></td></tr></table></figure><p>logstash.yml:</p><p>path.config:定义扫描input,filter,output的配置目录</p><p>path.logs: 定义log配置，在测试配置文件的时候有用。</p><p>input:kafka,output:elasticsearch的example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">input &#123;</div><div class="line">   kafka &#123;</div><div class="line">        topics_pattern =&gt; [&quot;service-logs-.*&quot;]</div><div class="line">        bootstrap_servers =&gt; &quot;10.1.220.27:9092&quot;</div><div class="line">        group_id =&gt; &quot;local-logstash&quot;</div><div class="line">        decorate_events =&gt; true</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">filter &#123;</div><div class="line">    json &#123;</div><div class="line">        source =&gt; &quot;message&quot;</div><div class="line">    &#125;</div><div class="line">    mutate &#123;</div><div class="line">        add_field =&gt; &#123;</div><div class="line">                &quot;kafka_topic&quot; =&gt; &quot;%&#123;[@metadata][kafka][topic]&#125;&quot;</div><div class="line">                &quot;kafka_consumer_group&quot; =&gt; &quot;%&#123;[@metadata][kafka][consumer_group]&#125;&quot;</div><div class="line">                &quot;kafka_partition&quot; =&gt; &quot;%&#123;[@metadata][kafka][partition]&#125;&quot;</div><div class="line">                &quot;kafka_offset&quot; =&gt; &quot;%&#123;[@metadata][kafka][offset]&#125;&quot;</div><div class="line">                &quot;kafka_timestamp&quot; =&gt; &quot;%&#123;[@metadata][kafka][timestamp]&#125;&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">output &#123;</div><div class="line">  if [level] == &quot;ERROR&quot; &#123;</div><div class="line">        http &#123;</div><div class="line">                url =&gt; &quot;http://localhost:8088/send/mail&quot;</div><div class="line">                http_method =&gt; &quot;post&quot;</div><div class="line">                automatic_retries =&gt; 0</div><div class="line">                connect_timeout =&gt; 6</div><div class="line">                keepalive =&gt; false</div><div class="line">        &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  elasticsearch &#123;</div><div class="line">        hosts =&gt; [&quot;127.0.0.1:9200&quot;]</div><div class="line">        action =&gt; &quot;index&quot;</div><div class="line">        index =&gt; &quot;logstash-%&#123;[kafka_topic]&#125;&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="6-3-加入开机自启动"><a href="#6-3-加入开机自启动" class="headerlink" title="6.3:加入开机自启动"></a>6.3:加入开机自启动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo systemctl enable logstash</div><div class="line">sudo systemctl start logstash</div></pre></td></tr></table></figure><h5 id="6-4-通过system进行管理logstash"><a href="#6-4-通过system进行管理logstash" class="headerlink" title="6.4:通过system进行管理logstash"></a>6.4:通过system进行管理logstash</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">systemctl status logstash</div><div class="line"></div><div class="line">systemctl start logstash</div><div class="line"></div><div class="line">systemctl stop logstash</div><div class="line"></div><div class="line">systemctl restart logstash</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-首先安装python-software-properties&quot;&gt;&lt;a href=&quot;#1-首先安装python-software-properties&quot; class=&quot;headerlink&quot; title=&quot;1.首先安装python-software-properties&quot;&gt;&lt;/a&gt;1.首先安装python-software-properties&lt;/h4&gt;&lt;p&gt;该程序将安装add-apt-repository的应用程序，更加方便的添加和使用PPA软件库。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sudo apt-get update&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sudo apt-get install -y python-software-properties software-properties-common apt-transport-https&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://renqiangme.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://renqiangme.github.io/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://renqiangme.github.io/tags/Ubuntu/"/>
    
      <category term="Elastic Stack" scheme="https://renqiangme.github.io/tags/Elastic-Stack/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu设置固定的ip</title>
    <link href="https://renqiangme.github.io/2017/08/18/Ubuntu%E8%AE%BE%E7%BD%AE%E5%9B%BA%E5%AE%9A%E7%9A%84ip/"/>
    <id>https://renqiangme.github.io/2017/08/18/Ubuntu设置固定的ip/</id>
    <published>2017-08-18T05:28:18.000Z</published>
    <updated>2018-11-08T02:45:49.776Z</updated>
    
    <content type="html"><![CDATA[<p>修改配置文件：/etc/network/interfaces</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">vim /etc/network/interfaces</div><div class="line"></div><div class="line">#增加修改如下：</div><div class="line"></div><div class="line">#The primary network interface</div><div class="line">auto ens160</div><div class="line">iface ens160 inet static</div><div class="line">address 10.1.220.15</div><div class="line">netmask 255.255.0.0</div><div class="line">gateway 10.1.1.1</div><div class="line">dns-nameservers 8.8.8.8 8.8.4.4</div><div class="line"></div><div class="line">service networking restart</div></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;修改配置文件：/etc/network/interfaces&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;vim /etc/network/interfaces&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#增加修改如下：&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#The primary network interface&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;auto ens160&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iface ens160 inet static&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;address 10.1.220.15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;netmask 255.255.0.0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;gateway 10.1.1.1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;dns-nameservers 8.8.8.8 8.8.4.4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;service networking restart&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://renqiangme.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://renqiangme.github.io/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://renqiangme.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>部署管理Swoole服务</title>
    <link href="https://renqiangme.github.io/2017/07/12/%E9%83%A8%E7%BD%B2%E7%AE%A1%E7%90%86Swoole%E6%9C%8D%E5%8A%A1/"/>
    <id>https://renqiangme.github.io/2017/07/12/部署管理Swoole服务/</id>
    <published>2017-07-12T03:20:38.000Z</published>
    <updated>2018-11-22T02:05:20.831Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用systemd管理Swoole服务"><a href="#使用systemd管理Swoole服务" class="headerlink" title="使用systemd管理Swoole服务"></a>使用systemd管理Swoole服务</h3><p>Systemd 是 Linux 系统工具，用来启动守护进程。</p><p>Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。包括：systemctl，systemd-analyze，hostnamectl，localectl，timedatectl，loginctl</p><a id="more"></a><p>更多参考<a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html/" target="_blank" rel="external">：Systemd介绍</a></p><p>所以Swoole的服务器程序可以编写一段service脚本，交由systemd进行管理。实现故障重启、开机自启动等功能。</p><p>使用systemd管理swoole服务参考文档:<a href="https://wiki.swoole.com/wiki/page/699.html/" target="_blank" rel="external">swoole官方文档</a></p><p>Demo:</p><p>在/etc/systemd/system/swoole_http.service新建一个service文件,内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[Unit]</div><div class="line">Description=Swoole Http service</div><div class="line">After=network.target</div><div class="line">After=syslog.target</div><div class="line"></div><div class="line">[Service]</div><div class="line">Type=forking</div><div class="line">PIDFile=/home/www/http/bin/server.pid</div><div class="line">ExecStart=/home/www/http/bin/server</div><div class="line">ExecStop=/bin/kill -15 $MAINPID</div><div class="line">ExecReload=/bin/kill -USR1 $MAINPID</div><div class="line">Restart=always</div><div class="line"></div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target graphical.target</div></pre></td></tr></table></figure><p>需要注意的是$MAINPID必须要是manager的id,不然启动或者重启的时候会报错。而且还需要修改swoole配置参数,把swoole的守护进程化设置为daemonize =&gt; 1。</p><p>kill -USR1 pid 重启woker进程和task进程</p><p>kill -USR2 pid 重启task进程</p><p>kill -15 管理进程id 关掉所有的manager相关进程</p><p>关于swoole重启的文档:<a href="https://wiki.swoole.com/wiki/page/p-server/reload.html" target="_blank" rel="external">链接</a></p><h3 id="使用Supervisor管理swoole服务"><a href="#使用Supervisor管理swoole服务" class="headerlink" title="使用Supervisor管理swoole服务"></a>使用Supervisor管理swoole服务</h3><p>Supervisor是一个客户/服务器系统，它可以在类Unix系统中管理控制大量进程。Supervisor使用python开发，有多年历史，目前很多生产环境下的服务器都在使用Supervisor,部署python程序经常这个。</p><p>Supervisor的服务器端称为supervisord，主要负责在启动自身时启动管理的子进程，响应客户端的命令，重启崩溃或退出的子进程，记录子进程stdout和stderr输出，生成和处理子进程生命周期中的事件。可以在一个配置文件中配置相关参数，包括Supervisord自身的状态，其管理的各个子进程的相关属性。配置文件一般位于/etc/supervisord.conf。</p><p>Supervisor的客户端称为supervisorctl，它提供了一个类shell的接口（即命令行）来使用supervisord服务端提供的功能。通过supervisorctl，用户可以连接到supervisord服务器进程，获得服务器进程控制的子进程的状态，启动和停止子进程，获得正在运行的进程列表。客户端通过Unix域套接字或者TCP套接字与服务端进行通信，服务器端具有身份凭证认证机制，可以有效提升安全性。当客户端和服务器位于同一台机器上时，客户端与服务器共用同一个配置文件/etc/supervisord.conf，通过不同标签来区分两者的配置。</p><p>Supervisor也提供了一个web页面来查看和管理进程状态，这个功能非常酷.</p><h4 id="安装Supervisor"><a href="#安装Supervisor" class="headerlink" title="安装Supervisor"></a>安装Supervisor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 我们可以通过pypi安装</div><div class="line">pip install supervisor</div><div class="line"># 或者从pypi上下载源码，然后安装</div><div class="line">python setup.py install</div><div class="line"># 安装完之后，使用下列命令来生成配置文件</div><div class="line">echo_supervisord_conf &gt; /etc/supervisord.conf</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># mkdir /etc/supervisord.d  用户存放被监控进程的配置文件</div></pre></td></tr></table></figure><p>修改/etc/supervisord.conf配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">在文件结尾[include]节点处把</div><div class="line">;files = relative/directory/*.ini改为files =/etc/supervisord.d/*.conf</div><div class="line"></div><div class="line">同时还需要去掉[include]前面的;</div></pre></td></tr></table></figure></p><p>保存并退出。</p><h4 id="把supervisor加入开机自启动服务"><a href="#把supervisor加入开机自启动服务" class="headerlink" title="把supervisor加入开机自启动服务"></a>把supervisor加入开机自启动服务</h4><p>到systemd系统下新建一个service配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /lib/systemd/system/supervisor.service</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[Unit]</div><div class="line">Description=supervisor</div><div class="line">After=network.target</div><div class="line"></div><div class="line">[Service]</div><div class="line">Type=forking</div><div class="line">ExecStart=/usr/bin/supervisord -c /etc/supervisord.conf</div><div class="line">ExecStop=/usr/bin/supervisorctl $OPTIONS shutdown</div><div class="line">ExecReload=/usr/bin/supervisorctl $OPTIONS reload</div><div class="line">KillMode=process</div><div class="line">Restart=on-failure</div><div class="line">RestartSec=42s</div><div class="line"></div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target graphical.target</div></pre></td></tr></table></figure><p>上述文件编写后，执行如下命令即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl enable supervisor.service</div></pre></td></tr></table></figure></p><p>加入开机自启动服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl daemon-reload</div></pre></td></tr></table></figure></p><p>重新载入systemd，扫描新的或有变动的单元。</p><p>实际上supervisor已经加入了systemctl管理了，后续起停supervisor服务都可以通过systemctl来控制了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">systemctl start supervisor.service 启动服务</div><div class="line"></div><div class="line">systemctl stop supervisor.service 停止服务</div><div class="line"></div><div class="line">systemctl restart supervisor.service 重新启动服务</div><div class="line"></div><div class="line">systemctl reload supervisor.service 重载配置文件</div><div class="line"></div><div class="line">systemctl status supervisor.service 查看服务状态</div></pre></td></tr></table></figure><h4 id="在-etc-supervisord-d-增加一个程序的demo配置参数："><a href="#在-etc-supervisord-d-增加一个程序的demo配置参数：" class="headerlink" title="在/etc/supervisord.d 增加一个程序的demo配置参数："></a>在/etc/supervisord.d 增加一个程序的demo配置参数：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">[program:cat]                ;程序名</div><div class="line">command=/bin/cat            ;命令绝对路径，可以包含参数</div><div class="line">process_name=%(program_name)s    ;进程名</div><div class="line">numprocs=1                  ;supervisor启动多少个该程序，如果大于1，那么进程名必须包括%(process_num)s</div><div class="line">directory=/tmp              ;该进程的启动时的工作目录</div><div class="line">umask=022                   ;掩码</div><div class="line">priority=999                ;优先级</div><div class="line">autostart=true              ;该程序是否在supervisor启动时启动</div><div class="line">autorestart=true            ;如果为false，那么该程序的相关进程永远不会自动重启。如果为unexpected，该程序的相关进程仅会在退出码为exitcodes中的值时重启;如果为true时</div><div class="line">startsecs=10                 ;最大启动时间</div><div class="line">startretries=3               ;最大启动重试次数。超过这个次数后，该进程会标记为FATAL状态</div><div class="line">exitcodes=0,2                ;退出码，关联autorestart=unexpected</div><div class="line"></div><div class="line">stopsignal=TERM                     ;关闭该程序相关进程所发送的信号量。可以为TERM, HUP, INT, QUIT, KILL, USR1, or USR2</div><div class="line">stopwaitsecs=10              ;supervisord父进程等待该程序的相关子进程返回SIGCLILD信号量的时间，超时后则发送SIGKILL</div><div class="line">user=chrism                  ;启动该程序进程的用户</div><div class="line">redirect_stderr=false        ;如果为true，则将该程序的进程错误输出到supervisor主日志文件中</div><div class="line">stdout_logfile=/tmp          ;标准输出</div><div class="line">stdout_logfile_maxbytes=1MB  ;日志轮滚</div><div class="line">stdout_logfile_backups=10    ;日志轮滚</div><div class="line">stdout_capture_maxbytes=1MB    </div><div class="line">stderr_logfile=/a/path        </div><div class="line">stderr_logfile_maxbytes=1MB</div><div class="line">stderr_logfile_backups=10</div><div class="line">stderr_capture_maxbytes=1MB</div><div class="line">environment=A=&quot;1&quot;,B=&quot;2&quot;        ;！环境变量信息</div><div class="line">serverurl=AUTO                 ;传送给该子进程的环境变量SUPERVISOR_SERVER_URL ，AUTO则自动提供一个Supervisord的URL。用于该进程可以和内部HTTP Server进行通信，简化进程管理。</div></pre></td></tr></table></figure><p>从swoole的文档我们得知：<br>Swoole提供了柔性终止/重启的机制，管理员只需要向SwooleServer发送特定的信号，Server的worker进程可以安全的结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">SIGTERM: 向主进程/管理进程发送此信号服务器将安全终止</div><div class="line">在PHP代码中可以调用$serv-&gt;shutdown()完成此操作</div><div class="line"></div><div class="line">SIGUSR1: 向主进程/管理进程发送SIGUSR1信号，将平稳地restart所有worker进程</div><div class="line">在PHP代码中可以调用$serv-&gt;reload()完成此操作</div><div class="line">swoole的reload有保护机制，当一次reload正在进行时，收到新的重启信号会丢弃</div><div class="line">如果设置了user/group，Worker进程可能没有权限向master进程发送信息，这种情况下必须使用root账户，在shell中执行kill指令进行重启</div><div class="line">reload指令对addProcess添加的用户进程无效</div><div class="line"></div><div class="line">#重启所有worker进程</div><div class="line">kill -USR1 主进程PID</div><div class="line"></div><div class="line">#仅重启task进程</div><div class="line">kill -USR2 主进程PID</div></pre></td></tr></table></figure><p>supervisor的程序restart的原理是实际上是发信号，所以我们需要给swoole的程序stop信号配置为：stopsignal=TERM </p><p>同时还需要把swoole的守护进程化设置为daemonize =&gt; 0，不然会报spawned error</p><h4 id="supervisorctl控制program"><a href="#supervisorctl控制program" class="headerlink" title="supervisorctl控制program"></a>supervisorctl控制program</h4><p>现在supervisor的server端我们已经交给systemd去管理，现在我们可以通过supervisorctl去控制配置添加的program</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">supervisorctl -c supervisor.conf status                    察看supervisor的状态</div><div class="line"></div><div class="line">supervisorctl -c supervisor.conf reload                    重新载入 配置文件</div><div class="line"></div><div class="line">supervisorctl -c supervisor.conf start [all]|[appname]     启动指定/所有supervisor管理的程序进程</div><div class="line"></div><div class="line">supervisorctl -c supervisor.conf stop [all]|[appname]      关闭指定/所有 supervisor管理的程序进程</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用systemd管理Swoole服务&quot;&gt;&lt;a href=&quot;#使用systemd管理Swoole服务&quot; class=&quot;headerlink&quot; title=&quot;使用systemd管理Swoole服务&quot;&gt;&lt;/a&gt;使用systemd管理Swoole服务&lt;/h3&gt;&lt;p&gt;Systemd 是 Linux 系统工具，用来启动守护进程。&lt;/p&gt;
&lt;p&gt;Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。包括：systemctl，systemd-analyze，hostnamectl，localectl，timedatectl，loginctl&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://renqiangme.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://renqiangme.github.io/tags/PHP/"/>
    
      <category term="Swoole" scheme="https://renqiangme.github.io/tags/Swoole/"/>
    
      <category term="Systemd" scheme="https://renqiangme.github.io/tags/Systemd/"/>
    
      <category term="Supervisor" scheme="https://renqiangme.github.io/tags/Supervisor/"/>
    
  </entry>
  
  <entry>
    <title>Python获取音频时长和分割音频</title>
    <link href="https://renqiangme.github.io/2017/06/26/Python%E8%8E%B7%E5%8F%96%E9%9F%B3%E9%A2%91%E6%97%B6%E9%95%BF%E5%92%8C%E5%88%86%E5%89%B2%E9%9F%B3%E9%A2%91/"/>
    <id>https://renqiangme.github.io/2017/06/26/Python获取音频时长和分割音频/</id>
    <published>2017-06-26T12:12:07.000Z</published>
    <updated>2018-11-08T02:11:31.124Z</updated>
    
    <content type="html"><![CDATA[<p><code>ffmpeg</code>是视频和音频处理的利器，各种转格式，提取视频中的图片，合并或者分隔音频，录制屏幕，加字幕啊…都是可以的。</p><p>因为有需求需要获取音频的长度然后来分割。</p><p>虽然<code>ffmpeg -i xxx file</code>也可以获取到音频的长度,但是可能需要正则去匹配，然后发现他们家族的<code>ffprobe</code>就可以直接返回json格式的音频信息。<code>ffprobe</code>是一个多媒体流分析工具。</p><a id="more"></a><p>大概命令如下:</p><pre><code>ffprobe -v quiet -print_format json -show_format -show_streams 1.wav</code></pre><p>python中可以这样子调用：</p><pre><code>import subprocess as sptry:    command = [&apos;ffprobe&apos;, &apos;-v&apos;, &apos;quiet&apos;, &apos;-print_format&apos;, &apos;json&apos;, &apos;-show_format&apos;,&apos;-show_streams&apos;, item[&quot;file_path&quot;]]    wav_info = sp.check_output(command, stderr=sp.STDOUT)    print(wav_info)except sp.CalledProcessError as e:    print(&apos;get audio info by ffprobe error %s&apos; % e.output)</code></pre><p>分割音频就需要用到<code>ffmpeg</code>了，大概命令如下：</p><pre><code>ffmpeg -i 1.wav -ss 00:00:03 -t 00:00:12 -acodec copy tmp.wav源音频：source_mp3开始位置：-ss结束位置：-t原始编码：-acodec</code></pre><p>需要注意的是：input的音频格式必须和output的音频格式一致，不然要报格式错误！</p><p>python中可以这样子调用：</p><pre><code>try:    cut_command = [&apos;ffmpeg&apos;, &apos;-y&apos;, &apos;-i&apos;, origin_wav, &apos;-ss&apos;, start_time, &apos;-t&apos;,end_time, &apos;-acodec&apos;, &apos;copy&apos;, cut_wav]    wav_cut_result = sp.check_call(cut_command)    if wav_cut_result == 0:        #todo successexcept sp.CalledProcessError as e:    print(&apos;cut audio info error %s&apos; % e.output)</code></pre><p>音频格式转换:</p><pre><code>单声道&amp;采样率16000ffmpeg -f s16le -ar 16000 -ac 1 -i xx.pcm xx.wav-f：强制格式s16le：无压缩-ar：采样率-ac：声道-i：输入文件</code></pre><p>更多命令相关参数：<code>ffmpeg --help</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ffmpeg&lt;/code&gt;是视频和音频处理的利器，各种转格式，提取视频中的图片，合并或者分隔音频，录制屏幕，加字幕啊…都是可以的。&lt;/p&gt;
&lt;p&gt;因为有需求需要获取音频的长度然后来分割。&lt;/p&gt;
&lt;p&gt;虽然&lt;code&gt;ffmpeg -i xxx file&lt;/code&gt;也可以获取到音频的长度,但是可能需要正则去匹配，然后发现他们家族的&lt;code&gt;ffprobe&lt;/code&gt;就可以直接返回json格式的音频信息。&lt;code&gt;ffprobe&lt;/code&gt;是一个多媒体流分析工具。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://renqiangme.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://renqiangme.github.io/tags/Python/"/>
    
      <category term="ffmpeg" scheme="https://renqiangme.github.io/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Redis通过模式匹配模糊删除key</title>
    <link href="https://renqiangme.github.io/2017/03/25/Redis%E9%80%9A%E8%BF%87%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E6%A8%A1%E7%B3%8A%E5%88%A0%E9%99%A4key/"/>
    <id>https://renqiangme.github.io/2017/03/25/Redis通过模式匹配模糊删除key/</id>
    <published>2017-03-25T07:33:29.000Z</published>
    <updated>2018-11-08T02:57:33.263Z</updated>
    
    <content type="html"><![CDATA[<p>Redis命令del不支持模式匹配，但是keys支持，如果需要通过模式匹配来删除一批，可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/redis/bin/redis-cli -h xx -p xx -a xx KEYS “test_*” | xargs /usr/local/redis/bin/redis-cli -h xx-p xx -a xx DEL</div></pre></td></tr></table></figure><a id="more"></a><p>关于keys命令的模式匹配介绍，可以参考：</p><p><a href="https://redis.io/commands/keys" target="_blank" rel="external">https://redis.io/commands/keys</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis命令del不支持模式匹配，但是keys支持，如果需要通过模式匹配来删除一批，可以执行：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;/usr/local/redis/bin/redis-cli -h xx -p xx -a xx KEYS “test_*” | xargs /usr/local/redis/bin/redis-cli -h xx-p xx -a xx DEL&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://renqiangme.github.io/categories/Linux/"/>
    
      <category term="Redis" scheme="https://renqiangme.github.io/categories/Linux/Redis/"/>
    
    
      <category term="Redis" scheme="https://renqiangme.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>在Centos上面源码安装TensorFlow</title>
    <link href="https://renqiangme.github.io/2017/03/18/%E5%9C%A8Centos%E4%B8%8A%E9%9D%A2%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85TensorFlow/"/>
    <id>https://renqiangme.github.io/2017/03/18/在Centos上面源码安装TensorFlow/</id>
    <published>2017-03-18T03:28:19.000Z</published>
    <updated>2018-11-08T02:10:48.227Z</updated>
    
    <content type="html"><![CDATA[<p>最先一开始用pip安装，但是总是在运行的时有源码安装效果更好的提示，所以索性源码安装，整个编译过程还真的是蛮久的。</p><a id="more"></a><p>源码安装<strong>TensorFlow</strong>需要先安装<strong>Bazel</strong>这个google推出的自动化构建工具。</p><p>1：安装Bazel之前先安装JDK</p><p>2：下载源码zip包<br><a href="https://github.com/bazelbuild/bazel/releases/" title="https://github.com/bazelbuild/bazel/releases/" target="_blank" rel="external">https://github.com/bazelbuild/bazel/releases/</a></p><p>3：然后直接执行./compile.sh等待出现安装成功后<br>4：把bazel导入到环境变量。<br>:vim /etc/profile<br>加入export PATH=/home/yangrenqiang/bazel/output:$PATH<br>source /etc/profile</p><p>5：测试bazel是否安装成功<br>bazel help</p><p>6：在github上面下载tensorflow的源码<br>7：执行./configure<br>8：<br>bazel build –config=opt //tensorflow/tools/pip_package:build_pip_package<br>9：<br>bazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg<br>10:<br>sudo pip install /tmp/tensorflow_pkg/tensorflow-1.0.1-py2-none-any.whl</p><p>具体参考：<br><a href="https://www.tensorflow.org/install/install_sources" title="https://www.tensorflow.org/install/install_sources" target="_blank" rel="external">https://www.tensorflow.org/install/install_sources</a></p><p>关于TensorFlow的中文文档：<a href="http://docs.pythontab.com/tensorflow/" title="http://docs.pythontab.com/tensorflow/" target="_blank" rel="external">http://docs.pythontab.com/tensorflow/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最先一开始用pip安装，但是总是在运行的时有源码安装效果更好的提示，所以索性源码安装，整个编译过程还真的是蛮久的。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://renqiangme.github.io/categories/Linux/"/>
    
    
      <category term="TensorFlow" scheme="https://renqiangme.github.io/tags/TensorFlow/"/>
    
      <category term="Centos" scheme="https://renqiangme.github.io/tags/Centos/"/>
    
      <category term="AI" scheme="https://renqiangme.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>Linux禁止某些用户和组SSH登录</title>
    <link href="https://renqiangme.github.io/2017/02/08/Linux%E7%A6%81%E6%AD%A2%E6%9F%90%E4%BA%9B%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84SSH%E7%99%BB%E5%BD%95/"/>
    <id>https://renqiangme.github.io/2017/02/08/Linux禁止某些用户和组SSH登录/</id>
    <published>2017-02-08T04:10:02.000Z</published>
    <updated>2018-11-08T03:04:58.602Z</updated>
    
    <content type="html"><![CDATA[<p>Linux系统可以通过sshd的配置项，禁止某些用户SSH登录，方法如下：</p><a id="more"></a><p>1、打开sshd的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/ssh/sshd_config</div></pre></td></tr></table></figure><p>2、修改该配置文件，增加或修改如下行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#禁止用户user1登陆，多个用户空格分隔</div><div class="line"></div><div class="line">DenyUsers user1</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#禁止用户组group1的所有用户登录，多个空格分隔</div><div class="line"></div><div class="line">DenyGroups group1</div></pre></td></tr></table></figure><p>3、保存配置后，重启sshd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/rc.d/init.d/sshd restart</div></pre></td></tr></table></figure><p>完成上面的配置后，就可以禁止用户或用户组的用户进行SSH登录</p><p>4、配置完毕后，在其它linux机器上使用如下命令进行测试</p><p>使用ssh测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ssh user1@192.168.1.168</div><div class="line">user1@192.168.1.168&apos;s password:</div><div class="line">Permission denied, please try again.</div></pre></td></tr></table></figure><p>授权被拒绝，已经实现禁用该用户使用SSH登录</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux系统可以通过sshd的配置项，禁止某些用户SSH登录，方法如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://renqiangme.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://renqiangme.github.io/tags/Linux/"/>
    
      <category term="SSH" scheme="https://renqiangme.github.io/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>Linux禁止root账户远程SSH登录</title>
    <link href="https://renqiangme.github.io/2017/02/08/Linux%E7%A6%81%E6%AD%A2root%E8%B4%A6%E6%88%B7%E8%BF%9C%E7%A8%8BSSH%E7%99%BB%E5%BD%95/"/>
    <id>https://renqiangme.github.io/2017/02/08/Linux禁止root账户远程SSH登录/</id>
    <published>2017-02-08T03:25:42.000Z</published>
    <updated>2018-11-08T02:57:25.814Z</updated>
    
    <content type="html"><![CDATA[<p>为增强服务器的安全,我们通常会禁止root账户远程SSH登录。</p><p>首先增加一个普通权限的用户：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">useradd demo</div><div class="line">passwd demo123</div></pre></td></tr></table></figure><p>修改配置文件/etc/ssh/sshd_config，禁止root远程SSH登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/ssh/sshd_config</div></pre></td></tr></table></figure><p>把PermitRootLogin改为no</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PermitRootLogin yes</div><div class="line">PermitRootLogin no</div></pre></td></tr></table></figure><p>重启sshd服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service sshd restart</div></pre></td></tr></table></figure><p>然后远程管理，用普通用户demo登录，然后用 su root 切换到root用户拿到最高权限，来保障服务器的安全。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为增强服务器的安全,我们通常会禁止root账户远程SSH登录。&lt;/p&gt;
&lt;p&gt;首先增加一个普通权限的用户：&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://renqiangme.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://renqiangme.github.io/tags/Linux/"/>
    
      <category term="SSH" scheme="https://renqiangme.github.io/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>通过nginx代理nodejs支持websocket</title>
    <link href="https://renqiangme.github.io/2017/01/20/%E9%80%9A%E8%BF%87nginx%E4%BB%A3%E7%90%86nodejs%E6%94%AF%E6%8C%81websocket/"/>
    <id>https://renqiangme.github.io/2017/01/20/通过nginx代理nodejs支持websocket/</id>
    <published>2017-01-20T04:05:42.000Z</published>
    <updated>2018-11-08T02:10:15.102Z</updated>
    
    <content type="html"><![CDATA[<p>NGINX自从1.3版本就开始支持WebSocket了，并且可以为WebSocket应用程序做反向代理和负载均衡。</p><p>WebSocket 和HTTP协议不同，但是WebSocket中的握手和HTTP中的握手兼容，它使用HTTP中的Upgrade协议头将连接从HTTP升级到WebSocket。这使得WebSocket程序可以更容易的使用现已存在的基础设施。例如，WebSocket可以使用标准的HTTP端口 80 和 443，因此，现存的防火墙规则也同样适用。<br><a id="more"></a><br>一个WebSockets的应用程序会在客户端和服务端保持一个长时间工作的连接。用来将连接从HTTP升级到WebSocket的HTTP升级机制使用HTTP的Upgrade和Connection协议头。反向代理服务器在支持WebSocket方面面临着一些挑战。一项挑战是WebSocket是一个hop-by-hop协议，所以，当代理服务器拦截到一个客户端发来的Upgrade请求时，它(指服务器)需要将它自己的Upgrade请求发送给后端服务器，也包括合适的请求头。此外，由于WebSocket连接是长时间保持的，所以代理服务器需要允许这些连接处于打开状态，而不是像对待HTTP使用的短连接那样将其关闭。</p><p>NGINX 通过在客户端和后端服务器之间建立起一条隧道来支持WebSocket。为了使NGINX可以将来自客户端的Upgrade请求发送给后端服务器，Upgrade和Connection的头信息必须被显式的设置。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">proxy_set_header Upgrade $http_upgrade;</div><div class="line">proxy_set_header Connection &quot;upgrade&quot;;</div></pre></td></tr></table></figure></p><p>完整配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">upstream wsbackend &#123;</div><div class="line">       server 127.0.0.1:3000;#nodejs启动的本地端口</div><div class="line">       keepalive 8;</div><div class="line">&#125;</div><div class="line">server</div><div class="line">    &#123;</div><div class="line">        listen 80;</div><div class="line">        server_name xxx.com;</div><div class="line">        index index.html index.htm index.php default.html default.htm default.php;</div><div class="line">        root  /home/wwwroot/xxx.com;</div><div class="line">        location / &#123;</div><div class="line">                proxy_pass http://wsbackend;</div><div class="line">#这两个HTTP头是因为采用了nginx作为代理后，后端可以通过 X-real-ip 或 X-Forwarded-For取得用户IP地址</div><div class="line">                proxy_set_header X-Real-IP $remote_addr;</div><div class="line">                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</div><div class="line">                proxy_set_header Host $http_host;</div><div class="line">                proxy_set_header X-NginX-Proxy true;</div><div class="line">                proxy_http_version 1.1;</div><div class="line">                proxy_set_header Upgrade $http_upgrade;#  声明支持websocket</div><div class="line">                proxy_set_header Connection &quot;upgrade&quot;;#  声明支持websocket</div><div class="line">                proxy_redirect off;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NGINX自从1.3版本就开始支持WebSocket了，并且可以为WebSocket应用程序做反向代理和负载均衡。&lt;/p&gt;
&lt;p&gt;WebSocket 和HTTP协议不同，但是WebSocket中的握手和HTTP中的握手兼容，它使用HTTP中的Upgrade协议头将连接从HTTP升级到WebSocket。这使得WebSocket程序可以更容易的使用现已存在的基础设施。例如，WebSocket可以使用标准的HTTP端口 80 和 443，因此，现存的防火墙规则也同样适用。&lt;br&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://renqiangme.github.io/categories/Nginx/"/>
    
      <category term="NodeJS" scheme="https://renqiangme.github.io/categories/Nginx/NodeJS/"/>
    
    
      <category term="Nginx" scheme="https://renqiangme.github.io/tags/Nginx/"/>
    
      <category term="NodeJS" scheme="https://renqiangme.github.io/tags/NodeJS/"/>
    
      <category term="Websocket" scheme="https://renqiangme.github.io/tags/Websocket/"/>
    
  </entry>
  
  <entry>
    <title>网页加载优化-PHP压缩网页进Redis,Openresty端直接输出</title>
    <link href="https://renqiangme.github.io/2016/12/25/%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96-PHP%E5%8E%8B%E7%BC%A9%E7%BD%91%E9%A1%B5%E8%BF%9BRedis-Openresty%E7%AB%AF%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%87%BA/"/>
    <id>https://renqiangme.github.io/2016/12/25/网页加载优化-PHP压缩网页进Redis-Openresty端直接输出/</id>
    <published>2016-12-25T14:07:30.000Z</published>
    <updated>2018-11-08T02:09:44.016Z</updated>
    
    <content type="html"><![CDATA[<p>其实商城项目的网页端，观察京东，淘宝他们有很多活动页面或者商品详情页，推广力度很多，流量也就比较多，通常一个页面很大很大，整个网页内容也很多，单纯考虑从webserver到走进php,java连接数据库等等读取数据拼装，再渲染视图输出到浏览器，整个过程下来，并发不大的情况还好，一大起来的就会性能大大的降低。</p><p>对于中小型项目，解决的方案肯定没有淘宝京东的方案多。<br><a id="more"></a><br>于是就要想解决优化的方案，像商品详情页有商品相关的静态数据，同时掺杂着一些评论，购买数量等等的动态数据，其实可以把整个网页动静分离，动态数据走接口，静态数据直接gzip压缩存进缓存，通过Openresty在nginx层面通过lua直接读取就输出,然后浏览器自动解压gzip。由于页面数据是压缩了的可以节省网络IO,大大提升页面的加载速度。但是像一些活动页面，动态数据可能没有那么多,改动商品相关的价格库存…等等改动那么频繁，其实可以直接扔进CDN,动态数据也走接口。</p><p>下面来看下PHP的几个GZIP压缩相关的函数，都是基于ZLIB库。</p><p>gzcompress gzdeflate gzencode函数的区别在于它们压缩的数据格式不同：</p><p>gzcompress使用的是ZLIB格式；</p><p>gzdeflate使用的是纯粹的DEFLATE格式；</p><p>gzencode使用的是GZIP格式；</p><p>但是有一点是相同的，它们压缩数据时都使用了DEFLATE压缩算法（理论上ZLIB和GZIP格式可以使用其他的压缩算法，但是目前实践中只使用DEFLATE算法），ZLIB和GZIP只不过是在DEFLATE的基础之上加了一些头部和尾部而已。</p><p>顺便提一下，HTTP协议中的Content-Encoding: deflate使用的是ZLIB格式而不是纯DEFLATE格式。</p><p>通过测试发现，gzencode和gzdeflate浏览器可以自动解压出来，前提是：http的请求头里面有accept-encoding:gzip, deflate，说明方案是可行的，但是对于一些浏览器可能不支持自动解压，所以需要判断下请求头，如果不支持，就需要lua解压之后再输出。</p><p>既然使用Openresty就在社区搜索了下。<br>lua的zlib库有两个：<br>–<a href="https://github.com/brimworks/lua-zlib" title="lua-zlib" target="_blank" rel="external">lua-zlib</a><br>–通过LuaJIT的FFI库来包装ZLIB模块</p><p>选择的是：lua-zlib</p><p>lua输出判断函数：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">echoPage</span><span class="params">(index_page)</span></span></div><div class="line"><span class="comment">--如果index_page=nil 就继续让nginx执行下一阶段，走进php让php自己处理</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> index_page <span class="keyword">then</span></div><div class="line">ngx.exit(ngx.OK)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="keyword">local</span> accept_encoding_table = ngx.req.get_headers()</div><div class="line"><span class="keyword">local</span> accept_encoding = accept_encoding_table[<span class="string">"accept-encoding"</span>]</div><div class="line"><span class="keyword">local</span> need_uncompress = <span class="number">0</span></div><div class="line"><span class="keyword">if</span> accept_encoding ~= <span class="keyword">nil</span> <span class="keyword">and</span> #accept_encoding&gt;<span class="number">0</span> <span class="keyword">then</span></div><div class="line"><span class="keyword">local</span> begin,stop = ngx.re.find(accept_encoding,<span class="string">'gzip'</span>)</div><div class="line"><span class="keyword">if</span> begin ~= <span class="keyword">nil</span>  <span class="keyword">then</span></div><div class="line">need_uncompress = <span class="number">0</span></div><div class="line"><span class="keyword">else</span></div><div class="line">need_uncompress = <span class="number">1</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="keyword">else</span></div><div class="line">need_uncompress = <span class="number">1</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="keyword">if</span> need_uncompress == <span class="number">1</span> <span class="keyword">then</span></div><div class="line"><span class="keyword">local</span> zlib = <span class="built_in">require</span> <span class="string">"zlib"</span></div><div class="line"><span class="keyword">local</span> stream = zlib.inflate()</div><div class="line"><span class="keyword">local</span> inflated,stream_eof,bytes_in,bytes_out = stream(res)</div><div class="line">ngx.say(inflated)</div><div class="line"><span class="keyword">else</span></div><div class="line">ngx.header[<span class="string">"Content-Encoding"</span>] = <span class="string">"gzip"</span><span class="comment">--避免Nginx再去压缩，需要发送一个响应头，告诉Nginx是一个gzip压缩的</span></div><div class="line">ngx.send_headers()</div><div class="line">ngx.say(res)</div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p><p>注释：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ngx.exit(ngx.OK)<span class="comment">--因为openresty有执行阶段这一个说法，是告诉openresty执行下一阶段</span></div><div class="line">ngx.exit(<span class="number">200</span>)<span class="comment">--意思是直接返回200，不再向下执行。也可以是其他的http状态码。</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实商城项目的网页端，观察京东，淘宝他们有很多活动页面或者商品详情页，推广力度很多，流量也就比较多，通常一个页面很大很大，整个网页内容也很多，单纯考虑从webserver到走进php,java连接数据库等等读取数据拼装，再渲染视图输出到浏览器，整个过程下来，并发不大的情况还好，一大起来的就会性能大大的降低。&lt;/p&gt;
&lt;p&gt;对于中小型项目，解决的方案肯定没有淘宝京东的方案多。&lt;br&gt;
    
    </summary>
    
      <category term="Openresty" scheme="https://renqiangme.github.io/categories/Openresty/"/>
    
    
      <category term="PHP" scheme="https://renqiangme.github.io/tags/PHP/"/>
    
      <category term="Openresty" scheme="https://renqiangme.github.io/tags/Openresty/"/>
    
      <category term="Redis" scheme="https://renqiangme.github.io/tags/Redis/"/>
    
      <category term="zlib" scheme="https://renqiangme.github.io/tags/zlib/"/>
    
  </entry>
  
  <entry>
    <title>内部微信授权code解决多个域名的脚本</title>
    <link href="https://renqiangme.github.io/2016/12/24/%E5%86%85%E9%83%A8%E5%BE%AE%E4%BF%A1%E6%8E%88%E6%9D%83code%E8%A7%A3%E5%86%B3%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <id>https://renqiangme.github.io/2016/12/24/内部微信授权code解决多个域名的脚本/</id>
    <published>2016-12-24T15:42:04.000Z</published>
    <updated>2018-11-22T02:29:48.443Z</updated>
    
    <content type="html"><![CDATA[<h5 id="内部调用微信授权脚本－解决一个域名想授权多个域名获取微信授权code"><a href="#内部调用微信授权脚本－解决一个域名想授权多个域名获取微信授权code" class="headerlink" title="内部调用微信授权脚本－解决一个域名想授权多个域名获取微信授权code"></a>内部调用微信授权脚本－解决一个域名想授权多个域名获取微信授权code</h5><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$access_key = &apos;123qwe&apos;;</div><div class="line">$innder_key = $_GET[&apos;inner_key&apos;];</div><div class="line">//内部调用</div><div class="line">if (isset($inner_key) &amp;&amp; !empty($inner_key)) &#123;</div><div class="line">    if ($inner_key != sha1($access_key)) &#123;</div><div class="line">        exit(&apos;access error!&apos;);</div><div class="line">    &#125;</div><div class="line">    $current_url = &apos;http://www.xxx.com/code.php&apos;;</div><div class="line">    $redirect_uri = $current_url.&apos;?url=&apos;.urlencode($_GET[&apos;redirect_url&apos;]);</div><div class="line">    $oauth_url = getOauthRedirect($redirect_uri);</div><div class="line">    header(&apos;Location:&apos;.$oauth_url);</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line">//微信授权回调</div><div class="line">if(isset($_GET[&apos;code&apos;]))&#123;</div><div class="line">    $url = urldecode($_GET[&apos;url&apos;]);</div><div class="line">    $new_url = $url.&apos;&amp;code=&apos;.$_GET[&apos;code&apos;];</div><div class="line">    header(&apos;Location:&apos;.$new_url);</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * oauth 授权跳转接口</div><div class="line"> * @param string $callback 回调URI</div><div class="line"> * @return string 返回 用户同意授权，获取code的URL 外部调用直接header重定向这个链接</div><div class="line"> */</div><div class="line">function getOauthRedirect($callback, $state = &apos;&apos;, $scope = &apos;snsapi_base&apos;) &#123;</div><div class="line">    $appid = &apos;xxxx&apos;;//微信公众号服务号的appid</div><div class="line">    return &apos;https://open.weixin.qq.com/connect/oauth2/authorize?appid=&apos; . $appid . &apos;&amp;redirect_uri=&apos; . urlencode($callback) . &apos;&amp;response_type=code&amp;scope=&apos; . $scope . &apos;&amp;state=&apos; . $state . &apos;#wechat_redirect&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;内部调用微信授权脚本－解决一个域名想授权多个域名获取微信授权code&quot;&gt;&lt;a href=&quot;#内部调用微信授权脚本－解决一个域名想授权多个域名获取微信授权code&quot; class=&quot;headerlink&quot; title=&quot;内部调用微信授权脚本－解决一个域名想授权多个域名获取微信授权code&quot;&gt;&lt;/a&gt;内部调用微信授权脚本－解决一个域名想授权多个域名获取微信授权code&lt;/h5&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://renqiangme.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://renqiangme.github.io/tags/PHP/"/>
    
      <category term="微信公众号" scheme="https://renqiangme.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习之权限管理</title>
    <link href="https://renqiangme.github.io/2016/12/24/Linux%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>https://renqiangme.github.io/2016/12/24/Linux学习之权限管理/</id>
    <published>2016-12-24T15:03:47.000Z</published>
    <updated>2018-11-22T02:30:09.610Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h3><h5 id="1：ACL权限简介和开启"><a href="#1：ACL权限简介和开启" class="headerlink" title="1：ACL权限简介和开启"></a>1：ACL权限简介和开启</h5><pre><code>A：不再考虑身份。用户或用户组直接拿过来给它改权限B：查看分区ACL权限是否开启  dumpe2fs -h /dev/sda3  #dump2fs命令是查询指定分区详细文件系统信息的命令  选项：-h 仅显示超级块中信息，而不显示磁盘块组的详细信息  (步骤1：df -h  #查看当前系统分区使用情况，容量，已用，可用，挂载点，找到用户所在分区。)  (步骤2：dumpe2fs -h /dev/sda3)C：临时开启分区ACL权限  mount -o remount,acl /  #重新挂载根分区，并载入acl权限D：永久开启分区ACL权限  步骤1：vi /etc/fstab  #加入acl   UUID=c2cq6f57-b15c-43ea-bca0-f239083d8bd2 / ext4 defaults,acl 1 1 #defaults后面加了一个acl  步骤2：mount -o remount / #重新挂载文件系统或重启动系统，使修改生效 </code></pre><a id="more"></a> <h5 id="2：查看与设定ACL权限"><a href="#2：查看与设定ACL权限" class="headerlink" title="2：查看与设定ACL权限"></a>2：查看与设定ACL权限</h5><pre><code>  A：查看ACL命令 getfacl 文件名 #查看ACL权限  B:设定ACL权限 setfacl 选项 文件名  选项：-m   设定ACL权限                  给用户设置ACL权限       setfacl -m u:qingwa:rx /project/       给用户组设定ACL权限     setfacl -m g:xxgroup:rwx project/        -x   删除指定的ACL权限 setfacl -x g:xxgroup /project/ #删除xxgroup在project下面的ACL权限        -b   删除所有的ACL权限 setfacl -b /project/ #会删除在project下面所有用户用户组的ACL权限        -d   设定默认的ACL权限        -k   删除默认ACL权限        -R   递归设定ACL权限</code></pre><h5 id="3-最大有效权限与删除ACL权限"><a href="#3-最大有效权限与删除ACL权限" class="headerlink" title="3:最大有效权限与删除ACL权限"></a>3:最大有效权限与删除ACL权限</h5><p>最大有效权限mask<br>mask是用来指定最大有效权限的。如果我给用户赋予了ACL权限，是需要和mask的权限“相与”才能得到用户的真正权限。(相与—相当于逻辑的与 一个为假就都为假)</p><h5 id="4：默认ACL权限和递归ACL权限"><a href="#4：默认ACL权限和递归ACL权限" class="headerlink" title="4：默认ACL权限和递归ACL权限"></a>4：默认ACL权限和递归ACL权限</h5><p>递归是父目录在设定ACL权限时，所有的子文件和子目录也会拥有相同的ACL权限。<br>setfacl -m u:用户名:权限 -R 文件名</p><p>默认ACL权限<br>默认ACL权限的作用是如果给父目录设定了ACL权限，那么父目录中所有新建的子文件都会继承父目录的ACL权限<br>。<br>setfacl -m d:u用户名：权限 文件名</p><h3 id="文件特殊权限"><a href="#文件特殊权限" class="headerlink" title="文件特殊权限"></a>文件特殊权限</h3><h5 id="1-SetUID"><a href="#1-SetUID" class="headerlink" title="1:  SetUID"></a>1:  SetUID</h5><p><strong>SetUID的功能</strong></p><pre><code>.只有可以执行的二进制程序才能设定SUID权限.命令执行者要对该程序拥有x（执行）权限.命令执行者在执行该程序时获得该程序文件宿主的身份（在执行程序的过程中灵魂附体为文件的属主）.SetUID权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效。---设置SUID---4代表SUID-    chmod 4755 文件名-    chmod u+s 文件名---取消SUID----    chmod 755 文件名-    chmod u-s 文件名---危险的SetUID---.关键目录应该严格控制写权限，比如“/”、“/usr”等。.用户的密码设置要严格遵守密码三原则。.对系统中默认应该是具有SetUID权限的文件作一列表，定时检查有没有这之外的文件被设置了SetUID权限。</code></pre><h5 id="2-SetGID"><a href="#2-SetGID" class="headerlink" title="2:  SetGID"></a>2:  SetGID</h5><pre><code>SetGID针对文件的作用.只有可执行的二进制程序才能设置SGID权限.命令执行者要对该程序拥有x(执行)权限.命令执行在执行程序的时候，组身份升级为该程序文件的属组.SetGID权限同样只在该程序执行过程中有效，也就是说组身份改变只在程序执行过程中有效SetGID针对目录的作用.普通用户必须对此目录拥有r和x权限，才能进入此目录.普通用户在此目录中的有效组会变成此目录的属组.若普通用户对此目录拥有w权限时，新建的文件的默认属组是这个目录的属组--设定SetGID--2代表SGID-chmod 2755 文件名-chmod g+s 文件名</code></pre><h5 id="3-Sticky-BIT"><a href="#3-Sticky-BIT" class="headerlink" title="3:  Sticky BIT"></a>3:  Sticky BIT</h5><p><strong>SBIT粘着位作用</strong><br>    .粘着位目前只对目录有效<br>    .普通用户对该目录拥有w和x权限，即普通用户可以在此目录拥有写入权限<br>    .如果没有粘着位，因为普通用户拥有w权限，所以可以删除此目录下所有文件，包括其他用户建立的文件。一旦赋予了粘着位，除了root可以删除所有文件，普通用户就算拥有w权限，也只能删除自己建立的文件，但是不能删除其他用户建立的文件。</p><pre><code>设置与取消粘着位1代表SBIT设置粘着位.chmod 1755 目录名.chmod o+t 目录名取消粘着位.chmod 777 目录名.chmod o-t 目录名</code></pre><h3 id="文件系统属性chattr权限"><a href="#文件系统属性chattr权限" class="headerlink" title="文件系统属性chattr权限"></a>文件系统属性chattr权限</h3><p>chattr[+-=][选项]文件或目录名</p><pre><code>+：增加权限-：删除权限=：等于某权限选项：    i:如果对文件设置i属性，那么不允许对文件进行删除，改名，也不能添加和修改数据；如果对目录设置i属性，那么只能修改目录下文件的数据，但不允许建立和删除文件。    a:如果对文件设置a属性，那么只能在文件中增加数据，但是不能删除也不能修改数据；如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许删除。</code></pre><p>2、查看文件系统属性：lsattr 选项 文件名</p><p>选项：-a 显示所有文件和目录   -d若目标是目录，仅列出目录本身的属性，而不是子文件的。</p><h3 id="系统命令sudo权限"><a href="#系统命令sudo权限" class="headerlink" title="系统命令sudo权限"></a>系统命令sudo权限</h3><p>1：<br>-root把本来只能超级用户执行的命令赋予普通用户执行<br>-sudo的操作对象是系统命令<br>2：sudo使用<br>visudo #需要超级管理员执行这个命令  实际修改的是/etc/sudoers文件 </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ACL权限&quot;&gt;&lt;a href=&quot;#ACL权限&quot; class=&quot;headerlink&quot; title=&quot;ACL权限&quot;&gt;&lt;/a&gt;ACL权限&lt;/h3&gt;&lt;h5 id=&quot;1：ACL权限简介和开启&quot;&gt;&lt;a href=&quot;#1：ACL权限简介和开启&quot; class=&quot;headerlink&quot; title=&quot;1：ACL权限简介和开启&quot;&gt;&lt;/a&gt;1：ACL权限简介和开启&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;A：不再考虑身份。用户或用户组直接拿过来给它改权限

B：查看分区ACL权限是否开启
  dumpe2fs -h /dev/sda3  #dump2fs命令是查询指定分区详细文件系统信息的命令
  选项：-h 仅显示超级块中信息，而不显示磁盘块组的详细信息

  (步骤1：df -h  #查看当前系统分区使用情况，容量，已用，可用，挂载点，找到用户所在分区。)
  (步骤2：dumpe2fs -h /dev/sda3)
C：临时开启分区ACL权限
  mount -o remount,acl /  #重新挂载根分区，并载入acl权限
D：永久开启分区ACL权限
  步骤1：vi /etc/fstab  #加入acl
   UUID=c2cq6f57-b15c-43ea-bca0-f239083d8bd2 / ext4 defaults,acl 1 1
 #defaults后面加了一个acl
  步骤2：mount -o remount / #重新挂载文件系统或重启动系统，使修改生效 
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://renqiangme.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://renqiangme.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习笔记之Vim</title>
    <link href="https://renqiangme.github.io/2016/12/24/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BVim/"/>
    <id>https://renqiangme.github.io/2016/12/24/Linux学习笔记之Vim/</id>
    <published>2016-12-24T14:52:07.000Z</published>
    <updated>2018-11-22T02:30:17.874Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Vim常用操作"><a href="#一、Vim常用操作" class="headerlink" title="一、Vim常用操作"></a>一、Vim常用操作</h3><p>Vim是一个功能强大的全屏幕文本编辑器。是linux/unix上最常用的文本编辑器。它的作用是建立、编辑、显示文本文件。</p><p>Vim没有菜单，只有命令！<br><a id="more"></a></p><p>Vim三个工作模式：<br>            命令模式<br>            vi filename 进去命令模式 输入:wq保存退出</p><pre><code>插入模式当你在命令模式的时候，输入插入命令 i a o就可以进入插入模式，进入插入模式的标志是下方出现了INSERT字样。按ESC退出。        编辑模式当你是命令模式的时候，按一个冒号 &apos;:&apos;就可以进入编辑模式。比如set number命令设置行号 设置完就回到命令模式</code></pre><hr><pre><code>插入命令：命令            作用a            在光标所在字符后插入A            在光标所在行尾插入i            在光标所在字符前插入I            在光标所在行行首插入o            在光标下面插入新行O            在光标上面插入新行</code></pre><hr><pre><code>定位命令：命令            作用:set nu            设置行号:set nonu        取消行号gg            到第一行G            到最后一行nG            到第n行:n            到第n行$            移至行尾0            移至行首</code></pre><hr><pre><code>删除命令：命令            作用x            删除光标所在处字符nx            删除光标所在处后n个字符dd            删除光标所在行  ndd删除n行dG            删除光标所在行到文件末尾内容D            删除光标所在处到行尾内容:n1,n2d            删除n1行到n2行指定范围的行</code></pre><hr><pre><code>复制和剪切命令命令            作用yy            复制当前行nyy            复制当前行以下n行dd            剪切当前行ndd            复制当前行以下n行p或P            粘贴在当前光标所在行下或行上</code></pre><hr><pre><code>替换和取消命令命令            作用r            取代光标所在处字符R            从光标所在处开始替换字符，按Esc结束 【下方会出现replace字符】u            取消上一步操作</code></pre><hr><pre><code>搜索和搜索替换命令命令            作用/string            1:搜索指定的字符串 2：搜索时忽略大小写 :set icn            搜索指定字符串的下一个出现位置:%s/old/new/g        全文替换指定字符串:n1,n2s/old/new/g    在一定范围内替换指定字符串:替换范围%s 全文替换起始行,终止行 s     /要替换的字符串/替换的新的字符串/g                             c 询问确认</code></pre><hr><pre><code>保存和退出命令命令            作用:w            保存修改:W new_filename        另存为指定文件:wq            保存修改并退出ZZ            快捷键，保存修改并退出:q!            不保存修改退出:wq!            保存修改并退出（文件所有者及root可使用）</code></pre><hr><h3 id="二、Vim常用技巧"><a href="#二、Vim常用技巧" class="headerlink" title="二、Vim常用技巧"></a>二、Vim常用技巧</h3><h5 id="技巧1"><a href="#技巧1" class="headerlink" title="技巧1"></a>技巧1</h5><pre><code>:r 文件名 ----把文件内容导入到刚刚光标所在的位置:! 命令 -----可以执行命令例如 :!which ls ----可以查看ls命令所在位置可以把以上结合起来，可以把一个命令执行结果导入文件中 :r !命令</code></pre><h5 id="技巧2"><a href="#技巧2" class="headerlink" title="技巧2"></a>技巧2</h5><pre><code>定义快捷键 :map 快捷键 触发命令范例：    :map ^P I#&lt;ESC&gt; 定义快捷键位ctrl+P 触发的命令为 I跳到行首并进入插入模式，然后插入#号，然后进入到命令模式    :map ^B 0x   定义快捷键ctrl+B 触发的命令为 0光标跳到行首并删除光标所在的字符 即可实现：删除注释注意：快捷键一般跟ctrl结合起来 这里的^不是数字6那个 实际是ctrl+v 可以结合快捷键三个键一起按！</code></pre><h5 id="技巧3"><a href="#技巧3" class="headerlink" title="技巧3"></a>技巧3</h5><pre><code>连续行注释    :n1,n2s/^/#/g 连续多行注释    :n1,n2s/^#//g 去掉连续多行的注释    :n1,n2s/^/\/\//g 有些程序我们需要//注释的时候 可以连续多行这个命令</code></pre><h5 id="技巧4"><a href="#技巧4" class="headerlink" title="技巧4"></a>技巧4</h5><pre><code>替换:ab mymail 763191973@qq.com在用vim编辑器执行 以上 当我们在插入模式 的时候 输入mymail的时候 一回车就会变成了763191973@qq.com</code></pre><hr><p>注意!!!!：如果有定义的快捷键 ab在重启的时候 会发现都消失 如果你想永久有效 需要写在每个用户的宿主目录下面的家目录下面的配置文件里面。如果是root就在/root目录下面，如果是其他用户就在/home/xx下面。<br>文件.vimrc 可以存放一些编辑模式的命令 快捷键 ab</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Vim常用操作&quot;&gt;&lt;a href=&quot;#一、Vim常用操作&quot; class=&quot;headerlink&quot; title=&quot;一、Vim常用操作&quot;&gt;&lt;/a&gt;一、Vim常用操作&lt;/h3&gt;&lt;p&gt;Vim是一个功能强大的全屏幕文本编辑器。是linux/unix上最常用的文本编辑器。它的作用是建立、编辑、显示文本文件。&lt;/p&gt;
&lt;p&gt;Vim没有菜单，只有命令！&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://renqiangme.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://renqiangme.github.io/tags/Linux/"/>
    
      <category term="Vim" scheme="https://renqiangme.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Openresty中获取和设置cookie</title>
    <link href="https://renqiangme.github.io/2016/12/24/Openresty%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AEcookie/"/>
    <id>https://renqiangme.github.io/2016/12/24/Openresty中获取和设置cookie/</id>
    <published>2016-12-24T14:27:52.000Z</published>
    <updated>2018-11-08T02:09:28.465Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1：获取cookie"><a href="#1：获取cookie" class="headerlink" title="1：获取cookie"></a>1：获取cookie</h3><p>local cookie_xx_value = ngx.var.cookie_xx<br><a id="more"></a></p><h3 id="2：设置cookie"><a href="#2：设置cookie" class="headerlink" title="2：设置cookie"></a>2：设置cookie</h3><p>因为cookie的过期时间格是林尼治时间需要注意转下。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">local</span> expires = <span class="number">3600</span> * <span class="number">24</span>  <span class="comment">-- cookie expires = 1 day</span></div><div class="line">ngx.header[<span class="string">"Set-Cookie"</span>] = <span class="string">"hello=world; Path=/; Expires="</span> .. ngx.cookie_time(ngx.time() + expires)</div></pre></td></tr></table></figure><p>如果想同时设置多个cookie，可以传一个table</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">local</span> expires = <span class="number">3600</span> * <span class="number">24</span>  <span class="comment">-- cookie expires = 1 day</span></div><div class="line"><span class="keyword">local</span> cookie_table = &#123;</div><div class="line"><span class="string">"hello=world; Path=/;Domain=/; Expires="</span> .. ngx.cookie_time(ngx.time() + expires),</div><div class="line"><span class="string">"hello2=world2; Path=/;Domain=/; Expires="</span> .. ngx.cookie_time(ngx.time() + expires),</div><div class="line"><span class="string">"hello3=world3; Path=/;Domain=/; Expires="</span> .. ngx.cookie_time(ngx.time() + expires)</div><div class="line">&#125;</div><div class="line">ngx.header[<span class="string">"Set-Cookie"</span>] = cookie_table</div></pre></td></tr></table></figure><p>更多cookie相关可以参考wikipedia:<a href="https://en.wikipedia.org/wiki/HTTP_cookie" title="https://en.wikipedia.org/wiki/HTTP_cookie" target="_blank" rel="external">https://en.wikipedia.org/wiki/HTTP_cookie</a></p><p>也可以直接使用github上面分享的lua的cookie封装好的库。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1：获取cookie&quot;&gt;&lt;a href=&quot;#1：获取cookie&quot; class=&quot;headerlink&quot; title=&quot;1：获取cookie&quot;&gt;&lt;/a&gt;1：获取cookie&lt;/h3&gt;&lt;p&gt;local cookie_xx_value = ngx.var.cookie_xx&lt;br&gt;
    
    </summary>
    
      <category term="Openresty" scheme="https://renqiangme.github.io/categories/Openresty/"/>
    
    
      <category term="Openresty" scheme="https://renqiangme.github.io/tags/Openresty/"/>
    
      <category term="Cookie" scheme="https://renqiangme.github.io/tags/Cookie/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习之用户管理</title>
    <link href="https://renqiangme.github.io/2016/12/24/Linux%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <id>https://renqiangme.github.io/2016/12/24/Linux学习之用户管理/</id>
    <published>2016-12-24T12:14:09.000Z</published>
    <updated>2018-11-22T02:30:04.537Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用户配置文件"><a href="#用户配置文件" class="headerlink" title="用户配置文件"></a>用户配置文件</h3><h5 id="用户管理简介"><a href="#用户管理简介" class="headerlink" title="用户管理简介"></a>用户管理简介</h5><p> .越是对服务器安全性要求高的服务器，越需要建立合理的用户权限等级制度和服务器操作规范</p><p> .在linux中主要是通过用户配置文件来查看和修改用户信息</p><a id="more"></a><h5 id="用户信息文件-etc-passwd"><a href="#用户信息文件-etc-passwd" class="headerlink" title="用户信息文件/etc/passwd"></a>用户信息文件/etc/passwd</h5><p>vim /etc/passwd<br>如果不知道这个文件是干什么的 可以执行 man 5 passwd 查看帮助<br>用户很多：如 root:x:0:0:root:/root:/bin/bash</p><p>第1个字段：用户名称</p><p>第2个字段：密码标志 （直接一个x 并没有直接列出密码 而是放在了/etc/shadow下面 原因/etc/passwd 各个用户都是可读的，就可能被暴力拆解 而/etc/shadow也是通过加密的 只有管理员有权限！）</p><p>第3个字段：UID（用户ID） 0:超级用户 1-499系统用户（伪用户）500-65535：普通用户</p><p>第4个字段：GID（用户初始组ID） 组：相同类型的集合</p><pre><code>初始组：linux用户一建立就默认属于一个组 跟window不一样 window每添加一个用户就会放入到user组里面。而linux你创建一个user1就会创建一个跟用户名相同名的user1用户组。每个用户必须要有一个初始组且只能有一个。建议：虽然初始组能够改，但并不建议改，原因：改了初始组把所建立的文件搞糊涂！附加组：指用户可以加入多个其他的用户组，并拥有这些组的权限，附加组可以有多个。</code></pre><p>第5个字段：用户说明</p><p>第6个字段：家目录<br>        普通用户：/home/用户名<br>        超级用户：/root/</p><p>第7个字段：登录之后的Shell<br>               Shell 就是Linux的命令解释器<br>        在/etc/passwd当中，除了标准Shell是/bin/bash之外，还可以写如/sbin/nologin</p><h5 id="影子文件-etc-shadow"><a href="#影子文件-etc-shadow" class="headerlink" title="影子文件/etc/shadow"></a>影子文件/etc/shadow</h5><p>实际就是 /etc/passwd的影子文件 只是权限更低 都是000000000<br>例如：<br>    root:$6$JmdhYiD4y7zwPiMu$kq9iu9C.0on1X1Ia14QZslgSWRy1pK8sQsVmCauGykqOFAyawpvFkaVM83nuqum4oJ92Y3sPPIXlpw5Fksp3m/:16326:0:99999:7:::<br>第一个字段：用户名<br>第二个字段：加密密码<br>         加密算法升级为SHA512散列加密算法<br>         如果密码位是“!!”或“*”代表没有密码，不能登录<br>第三个字段：密码最后一次修改日期<br>                使用1970年1月1日作为标准时间，每过一天时间戳加1<br>第四个字段：两次密码的修改间隔时间（和第3个字段相比）<br>第五个字段：密码有效期（和第3个字段相比）<br>第六个字段：密码修改到期前的警告天数（和第5字段相比）<br>第七个字段：密码过期后的宽限天数（和第五个字段相比）<br>         0:代表密码过期后立即失效<br>         1:代表密码永远不会失效<br>第八个字段：账号失效时间<br>         要用时间戳表示<br>         把时间戳换算为日期 date -d “1970-01-01 16066 days”<br>         把日期换算为时间戳 echo $((date –date=”2014/01/06” +%s)/86400+1)<br>第九个字段：保留</p><h5 id="组信息文件-etc-group和组密码文件-etc-gshadow"><a href="#组信息文件-etc-group和组密码文件-etc-gshadow" class="headerlink" title="组信息文件/etc/group和组密码文件/etc/gshadow"></a>组信息文件/etc/group和组密码文件/etc/gshadow</h5><pre><code>组信息文件/etc/group 例如：root:x:0:第一个字段：组名 第二个字段：组密码标志 第三个字段：GID 第四个字段：组中附加用户组密码文件/etc/gshadow第一个字段：组名 第二个字段：组密码 第三个字段：组管理员用户名 第四个字段：组中附加用户</code></pre><h3 id="用户管理相关文件"><a href="#用户管理相关文件" class="headerlink" title="用户管理相关文件"></a>用户管理相关文件</h3><h5 id="用户的家目录"><a href="#用户的家目录" class="headerlink" title="用户的家目录"></a>用户的家目录</h5><pre><code>普通用户：/home/用户名，所有者和所属组都是此用户，权限是700超级用户：/root/ 所有者和所属组都是root用户，权限是550 如果你想把普通用户变为超级用户 家目录并不会修改 只是权限变为了超级权限。普通用户变为超级用户的方法：修改用户信息文件/etc/passwd 把uid变为0 这样我们再登录的时候就会发现输入命令前面如果是#就说明是超级用户 如果是$就是普通用户</code></pre><h5 id="用户的邮箱"><a href="#用户的邮箱" class="headerlink" title="用户的邮箱"></a>用户的邮箱</h5><pre><code>/var/spool/mail/用户名是不是和我们用的QQ邮箱一样呢？QQ邮箱之所以能够转发是靠QQ自带的服务器进行转发，linux虽然可以作为客户端收发邮件，但是也要依赖服务器去发送邮件。QQ邮箱有专门的服务器去发送邮件，在linux中用户之间可以传递邮件，利用linux的内存直接转发，每个用户都有邮箱，我们用的只是邮箱的客户端，并没有搭建服务器。</code></pre><h5 id="用户模板目录"><a href="#用户模板目录" class="headerlink" title="用户模板目录"></a>用户模板目录</h5><pre><code>/etc/skel在用户家目录执行 ls -a 会发现出现了一些隐藏文件，这是在用户创建的时候自动创建的。这些自动创建的文件是从/etc/skel自动拷贝过去的。如果我想让所有用户一添加就在家目录出现某个文件，比如你登陆的我的系统要遵守xx规则，几点关机，警告信息...等等。只需要在/etc/skel下面添加文件就行了！</code></pre><h3 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h3><h5 id="用户添加命令-useradd"><a href="#用户添加命令-useradd" class="headerlink" title="用户添加命令   useradd"></a>用户添加命令   useradd</h5><p>  格式：useradd [选项] 用户名<br>  选项：<br> -u UID：  手工指定用户的UID号<br> -d 家目录：  手工指定用户的家目录<br>        -c 用户说明：  手工指定用户的说明<br> -g 组名：  手工指定用户的初始组<br>        -G 组名：  指定用户的附加组<br> -s shell:  手工指定用户的登录shell 。默认是/bin/bash<br>  设置用户默认值的文件 /etc/default/useradd   和 /etc/login.defs</p><h5 id="修改用户密码-passwd"><a href="#修改用户密码-passwd" class="headerlink" title="修改用户密码   passwd"></a>修改用户密码   passwd</h5><p>   passwd [选项] 用户名<br>   选项：<br> -S 查询用户密码的密码状态。仅root用户可用。</p><pre><code>eg: passwd -S qingwaqingwa PS 2014-09-14 0 99999 7 -1 #用户名密码设定时间2014-09-14 密码修改间隔时间（0）密码有效期（99999）#警告时间（7） 密码不失效（-1）</code></pre><p> 实际上就跟 /etc/shadow里面看到的一样</p><p> -l 暂时锁定用户。仅root用户可用。在密码前面加上!! 让其密码失效<br> -u 解锁用户。仅root用户可用。<br> –stdin 可以通过管道符输出的数据作为用户的密码<br> echo “123” | passwd –stdin qingwa<br> 管道符:直接将前面的输出作为后面的输入</p><h5 id="修改用户信息-usermod"><a href="#修改用户信息-usermod" class="headerlink" title="修改用户信息   usermod"></a>修改用户信息   usermod</h5><pre><code>usermod -c &quot;test user&quot; lamp #修改用户的说明usermod -G root lamp #把lamp用户加入root组usermod -L lamp #锁定用户usermod -U lamp #解锁用户</code></pre><h5 id="修改用户密码状态-chage"><a href="#修改用户密码状态-chage" class="headerlink" title="修改用户密码状态 chage"></a>修改用户密码状态 chage</h5><p> chage [选项] 用户名<br> 选项：<br> -l 列出用户的详细密码状态<br> -d 日期 修改密码最后一次更改日期（shadow第3字段）<br> -m 天数 两次密码修改间隔（shadow第4字段）<br> -M 天数 密码有效期（shadow第5字段）<br> -W 天数 密码过期前警告天数（shadow第6字段）<br> -I 天数 密码过后宽限天数（shadow第7字段）<br> -E 日期 账号失效时间（shadow第8字段）<br> 因为选项过多直接修改vim /etc/shadow文件就行了<br> 常用的一个：chage -d 0 qingwa #这个命令其实是把密码修改日期归0了 这样用户一登陆就要修改密码</p><h5 id="删除用户-userdel"><a href="#删除用户-userdel" class="headerlink" title="删除用户 userdel"></a>删除用户 userdel</h5><p> userdel [-r] 用户名<br> 选项：<br>      -r 删除用户的同时删除用户家目录<br> id 用户名 #查看用户的uid 组id </p><h5 id="用户切换命令-su"><a href="#用户切换命令-su" class="headerlink" title="用户切换命令 su"></a>用户切换命令 su</h5><pre><code>su [选项] 用户名选项：    - #选项只使用“-”代表连带用户的环境变量一起切换    -c 命令  #仅执行一次命令，而不切换用户身份eg: su - root #切换成rootsu - root -c &quot;useradd qinwa&quot; 不切换成root，但是执行useradd命令添加qingw用户</code></pre><h3 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h3><h5 id="添加用户组"><a href="#添加用户组" class="headerlink" title="添加用户组"></a>添加用户组</h5><pre><code>groupadd [选项] 组名       选项：-g GID   #指定组ID</code></pre><h5 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h5><pre><code>groupmod [选项] 组名-g GID #修改组ID-n 新组名 #修改组名  eg:groupmod -n testgrp group1 #把组名group1修改为testgrp</code></pre><h5 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组"></a>删除用户组</h5><pre><code>groupdel 组名</code></pre><h5 id="把用户添加入组或从组中删除"><a href="#把用户添加入组或从组中删除" class="headerlink" title="把用户添加入组或从组中删除"></a>把用户添加入组或从组中删除</h5><pre><code>gpasswd 选项  组名选项：-a 用户名 #把用户加入组      -d 用户名 #把用户从组中删除</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;用户配置文件&quot;&gt;&lt;a href=&quot;#用户配置文件&quot; class=&quot;headerlink&quot; title=&quot;用户配置文件&quot;&gt;&lt;/a&gt;用户配置文件&lt;/h3&gt;&lt;h5 id=&quot;用户管理简介&quot;&gt;&lt;a href=&quot;#用户管理简介&quot; class=&quot;headerlink&quot; title=&quot;用户管理简介&quot;&gt;&lt;/a&gt;用户管理简介&lt;/h5&gt;&lt;p&gt; .越是对服务器安全性要求高的服务器，越需要建立合理的用户权限等级制度和服务器操作规范&lt;/p&gt;
&lt;p&gt; .在linux中主要是通过用户配置文件来查看和修改用户信息&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://renqiangme.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://renqiangme.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习笔记之常用命令之目录处理命令</title>
    <link href="https://renqiangme.github.io/2016/12/24/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B9%8B%E7%9B%AE%E5%BD%95%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    <id>https://renqiangme.github.io/2016/12/24/Linux学习笔记之常用命令之目录处理命令/</id>
    <published>2016-12-24T10:35:29.000Z</published>
    <updated>2018-11-22T02:30:13.775Z</updated>
    
    <content type="html"><![CDATA[<p><strong>————————常用命令—————</strong></p><pre><code>1文件处理命令 1.1命令格式与目录处理命令 1.2目录处理命令 1.3文件处理命令 1.4链接命令2权限管理命令3文件搜索命令4帮助命令5用户管理命令6压缩解压命令7网络命令8关机重启命令</code></pre><a id="more"></a><h3 id="1、文件处理命令"><a href="#1、文件处理命令" class="headerlink" title="1、文件处理命令"></a>1、文件处理命令</h3><p>1.1 命令格式：命令 [-选项][参数]   方括号是可选的</p><pre><code>例：ls -la /etc</code></pre><p>说明：<br>    1、个别命令使用不遵循此格式<br>    2、当有多个选项时，可以写在一起 -l a—&gt;-la<br>    3、简化选项与完整选项 -a等于–all linux简化的习惯一个-  完整的得用两个–</p><h3 id="1-2-目录处理命令："><a href="#1-2-目录处理命令：" class="headerlink" title="1.2 目录处理命令："></a>1.2 目录处理命令：</h3><p><code>ls</code></p><p>英文原意：list<br>命令所在路径：/bin/ls<br>执行权限：所有用户<br>功能描述：显示目录文件</p><p>语法：ls 选项[-ald][文件或目录]</p><pre><code>      -a 显示所有文件，包括隐藏文件 [all]      -l 详细信息显示 [long]        -h 人性化显示把文件大小显示为KB MB [human]      -d 查看目录属性 [directory]      -i 查看文件的i节点,可以理解为系统会给每个文件一个ID号 [inode]任何一个文件的详细信息：-rw-r--r--文件类型：- 二进制文件   d 目录[directory]     l 软链接文件[link]rw- r-- r--u   g   o u所有者 g所有组 o其他人 (在上面rw-三个一组)r读 w写 x执行</code></pre><hr><p><code>mkdir</code></p><p>英文原意：make directories<br>命令所在路径：/bin/mkdir<br>执行权限：所有用户<br>语法：mkdir-p[目录名]<br>功能描述：创建根目录 -p递归创建</p><pre><code>范例：mkdir -p /tmp/Japan/boduo      mkdir /tmp/Japan/longze/tmp/Japan/canjing 这个会报错 应该如果不-p递归 你在一个本来不存在的目录里面再去创建目录 肯定是不行的</code></pre><hr><p><code>cd</code></p><p>英文原意：change directory;<br>命令所在路径：shell内置命令；<br>执行权限：所有用户；<br>语法：cd[目录]；<br>功能描述：切换目录</p><pre><code>范例：cd /tem/Japan/boduo切换到指定目录     cd .. 回到上一级目录</code></pre><hr><p><code>rmdir</code></p><p>英文原意：remove empty directories<br>命令所在路径：/bin/rmdir<br>执行权限：所有用户<br>语法：rmdir[目录名]<br>功能描述：删除空目录</p><pre><code>如果不为空得用rm -r xxx范例：rmdir /tmp/Japan/boduo</code></pre><hr><p><code>cp</code></p><p>英文原意：copy ; 命令所在路径：/bin/cp ；执行权限：所有用户;<br>语法：cp -rp [原文件或目录][目标目录]<br>         -r  复制目录<br>         -p 保留文件属性<br>功能描述：复制文件或目录(可以同时复制多个文件或目录 只要指定目标位置)</p><pre><code>例子：mv -r /tmp/Japan /root/riben 把tmp目录下面的Japan复制到root目录下面并且更改名字为riben</code></pre><hr><p><code>mv</code></p><p>英文原意：move<br>命令所在路径:/bin/mv<br>执行权限：所有用户；<br>语法：mv[原文件或目录][目标目录]<br>功能描述:剪切文件或改名<br>    例子：mv /tmp/Japan /root/riben 把tmp目录下面的Japan剪切到root目录下面并且更改名字为riben<br>    改名:<br>    cd /root<br>    mv Japan riben 如果在当前目录下面mv不就是在改名么！ </p><hr><p><code>rm</code><br>英文原意：remove<br>命令所在路径:/bin/rm<br>执行权限：所有用户<br>语法：rm -rf[文件或目录]<br>         -r 删除目录<br>         -f 强制执行<br>功能描述:删除文件<br>    rm grub.config</p><hr><h3 id="1-3-文件处理命令"><a href="#1-3-文件处理命令" class="headerlink" title="1.3 文件处理命令"></a>1.3 文件处理命令</h3><hr><p><code>touch</code><br>命令所在路径:/bin/touch<br>执行权限：所有用户<br>语法：touch[文件名]<br>功能描述：创建空文件</p><pre><code>范例：touch Japanlovestory.list //在当前路径下面创建文件      touch /root/Japanlovestory.list  //如果加了完整路径则在root路径下面创建一个空文件linux中并不像window中对特殊符号不允许 但是建议在Linux中也别用另外注意空格：      touch program files  因为在window中可以在文件命名的时候 中间去敲一个空格 但是注意！！这条命令会创建两个文件 program files如果真的需要创建一个“program files”的文件，可以用引号引起来      touch &quot;program files&quot;虽然可以敲一个空白符 但是并不建议这么做，因为在以后查找的时候 会产生很多麻烦 </code></pre><hr><p><code>cat</code><br>命令所在路径：/bin/cat<br>执行权限：所有用户<br>语法：cat[文件名]<br>功能描述：显示文件内容<br>  -n显示行号</p><pre><code>范例：cat /etc/issue     cat -n /etc/services</code></pre><p>此命令并适合浏览很长很长的文件！要用more</p><hr><p><code>tac</code><br>命令所在路径：/usr/bin/tac<br>执行权限：所有用户<br>语法：tac [文件名]<br>功能描述：显示文件内容（反向列示）—反过来倒着显示 但是并不支持显示行号</p><pre><code>范例：tac /etc/services</code></pre><hr><p><code>more</code><br>命令所在路径：/bin/more<br>执行权限：所有用户<br>语法：more [文件名]<br>      空格或者f  翻页<br>      enter      换行<br>      q或Q       退出<br>功能描述：分页显示文件内容<br>    范例：more /etc/services<br>不足：只可以按往下面翻页 不能往上面翻页 所以得用：less</p><hr><p><code>less</code><br>命令所在路径：/usr/bin/less<br>执行权限：所有用户<br>    语法：less [文件名]<br>          pageup向上翻页<br>          空格或者f  翻页<br>          enter      换行<br>          向上方向箭头 上面一行<br>          q或Q       退出<br>          /xxx    搜索关键词xxx  n向下切换搜索的结果所在位置[next]<br>功能描述：分页显示文件内容（可向上翻页 并且可以查找）</p><pre><code>范例：less /etc/services</code></pre><hr><p><code>head</code><br>命令所在路径：/usr/bin/head<br>执行权限：所有用户<br>语法：head [文件名]<br>功能描述：显示文件前面几行<br>              -n指定行数<br>    范例：head -n 20 /etc/services<br>如果你不指定行号，会默认显示10行。</p><hr><p><code>tail</code><br>命令所在路径：/usr/bin/tail<br>执行权限：所有用户<br>语法：tail [文件名]<br>功能描述：显示文件后面几行<br>              -n指定行数<br>       -f动态显示文件末尾内容 常用来监控日志 因为它会动态显示<br>    范例：tail -n 18 /etc/services<br>如果你不指定行号，会默认显示10行。</p><hr><h3 id="1-4链接命令"><a href="#1-4链接命令" class="headerlink" title="1.4链接命令"></a>1.4链接命令</h3><hr><p><code>ln</code><br>英文原意：link<br>命令所在路径：/bin/ln<br>执行权限：所有用户<br>    语法：ln -s [原文件][目标文件]<br>             -s 创建软链接<br>功能描述：生成链接文件</p><pre><code>范例：ln -s /etc/issue /tmp/issue.soft      创建文件/etc/issue的软链接/tmp/issue.soft      ln /etc/issue /tmp/issue.hard      创建文件/etc/issue的硬链接/tmp/issue.hard  硬链接没有 -s选项</code></pre><p>软链接特征：类似windows快捷方式</p><pre><code>1：lrwxrwxrwx l开头表示文件类型为软链接 软链接所有用户的文件权限均为可读可写可执行2：文件大小 当我们创建一个软链接的时候 跟原文件相比 大小相比原文件小很多，因为它只是一个符号链接3：/tmp/issue.soft -&gt; /etc/issue 箭头指向源文件什么时候用软链接即什么时候在window中用快捷方式</code></pre><p>硬链接特征：</p><pre><code>1：拷贝 cp-p + 同步更新echo &quot;www.thaibl.com&quot; &gt;&gt; /etc/issue(相当于拷贝并保留原文件属性（最后修改时间，大小，内容）外加同步更新,就算一个文件删除了，另外一个依然存在)2：通过i节点识别。 当给某个文件创建一个硬链接的时候 我们会发现硬链接文件的节点跟原文件的节点一样。[所以才会实时更新][ls -i]3：不能跨分区 比如不能把都在 /tmp目录下面的文件 创建到/bin目录下面去 而软链接没有这个限制4：不能针对目录使用[不能跟某个目录创建硬链接，而软链接没有这个限制]</code></pre><hr><h3 id="2、权限管理命令"><a href="#2、权限管理命令" class="headerlink" title="2、权限管理命令"></a>2、权限管理命令</h3><hr><p>代表字符 权限 对文件的含义 对目录的含义</p><p>r 读权限 可以查看文件的内容 可以列出目录中的内容</p><p>w 写权限 可以修改文件内容 可以在目录中创建删除文件</p><p>x 执行权限 可以执行文件 可以进入目录</p><hr><p>注意：对所属用户来说 一个文件是否有删除权限，要看文件所在的目录是否有写权限<br>假如我们在 root下面创建一个temp目录 然后touch /temp/testfile 然后chmod 777 /temp 再去创建useradd qingwa passwd qingwa 创建一个普通用户qingwa之后再去登录，执行rw /temp/testfile 由于我们设置了temp目录对普通用户来说也是有写的权限，所以能删除！！</p><hr><p><code>chmod</code><br>命令英文原意：change the permissions mode of a file<br>命令所在路径：/bin/chmode<br>执行权限：所有用户</p><pre><code>语法：一、chmod [{ugoa}{+-=}{rwx}][文件或目录]             //u所有者 g所有组 o其他人 +增加权限 -减少权限 =不管你之前有什么权限，现在必须是这个权限 rwx可读可写可执行    例子：chmod u+x /tmp/test.html 即给test.html 所有者增加x可执行的权限          chmod g+x,o-r /tmp/text/html 可以给多个用户修改多个权限，用逗号隔开就行了  二、[mode=421][文件或目录]   -------通常用这个      //权限的数字表示,r--4 w---2  x---1      rwxrw-r--      7  6  4例子：假如我们想要这个权限640 rw-r----- 可以这样：chmod 640 /tmp/test.html  三、-R 递归修改  假如在tmp/a/b  thmod -R 777 /tmp/a  因为是递归修改 我们ls -lh的时候会发现b目录的权限也会被递归修改为777</code></pre><p>功能描述：改变文件或目录权限</p><hr><p><code>chown</code><br>命令英文原意：change file ownership<br>命令所在路径：/bin/chown<br>执行权限：所有用户<br>语法：chown[用户][文件或目录]<br>功能描述：改变文件或目录的所有者</p><pre><code>范例：chown qingwa yang  //改变文件qingwa的所有者为yang</code></pre><hr><p><code>chgrp</code><br>命令英文原意：change file group ownership<br>命令所在路径：/bin/chgrp<br>执行权限：所有用户<br>语法：chgrp[用户组][文件或目录]<br>功能描述：改变文件或目录的所属组<br>    范例：chgrp lampbrother fengjie //改变文件fengjie的所属组为lampbrother </p><p>[groupadd 添加用户组]</p><hr><p><code>umask</code><br>英文原意:the user file-creation mask<br>命令所在路径:Shell内置命令<br>执行权限：所有用户<br>语法：umask [-S]<br>      -S 以rwx形式显示新建文件缺省权限<br>功能描述：显示、设置文件的缺省权限<br><code>范例：umask -S</code><br>注意：linux中创建一个新文件默认是rw-r–r–出于安全考虑是不让新建的文件有可执行的权限644<br>假如我想修改默认新建文件的权限，就是以后创建的新文件的权限为rwxr-xr– 754<br>需要这么做：777-754=023<br>umask 023<br>以后新建的文件的权限就是：rwxr-xr– 754</p><hr><h3 id="3、文件搜索命令"><a href="#3、文件搜索命令" class="headerlink" title="3、文件搜索命令"></a>3、文件搜索命令</h3><hr><p>在linux中，最重要的事情不是搜索你能找得到文件，而是应该规划好目录结构，放好位置，因为搜索会很占用系统资源，如果在服务器访问高发期间，小心崩溃。</p><hr><p><code>find</code><br>命令所在路径：/bin/find<br>执行权限：所有用户<br>语法：find [搜索范围][匹配条件]<br>功能描述：文件搜索</p><pre><code>A：find /etc -name init  在目录/etc中查找文件名为 init  [-iname不区分大小写]B：find /etc -size +204800 在目录/etc下查找大于100M的文件  +n 大于 -n小于  n等于  注意：在linux中得换算为数据块 1数据块等于512字节即0.5k--100M=102400kb=204800kbC：find / -user qingwa 在根目录下面查找所有者为qingwa的文件       -group根据所属组查找D：find /etc -cmin -5 在/etc下查找5分钟内被修改过属性的文件和目录             -amin 访问时间[access]      -cmin 文件属性[change]      -mmin 文件内容[modify]    +xx表示超过时间 -xx表示多少时间以内E：find /etc -size +163840 -a -size -204800 在/etc下查找大于80MB小于100MB的文件   -a两个条件同时满足 [and]   -o两个条件满足任意一个即可F：find /etc -name inittab -exec ls -l {}\; 在/etc下查找inittab文件并显示其详细信息   -exec/ok 命令 {}\; 对搜索结果执行操作G：-type根据文件类型查找 f文件 d目录 l软链接文件H: 根据i节点查找   find . -inum 31531 -exec rm {}\;查找节点为31531的文件并立即执行删除命令</code></pre><hr><p><code>locate</code><br>命令所在路径：/usr/bin/locate<br>执行权限：所有用户<br>语法：locate 文件名<br>功能描述：在文件资料库中查找文件<br>    范例：locate inittab</p><pre><code>-i 选项不区分大小写注意1：locate搜索速度很快 相当于window那个everything那个软件。原因是：用locate locate 会得到很多行信息，系统会定期把信息存放到mlocate.db文件里，不像find会在某个分区某个文件去查找，只需要搜索mlocate.db这个文件就行了。但是有一个问题，新建的文件实际上是没有被收录到这个文件里的，所以用locate去查找的时候，是查找不了的。解决办法：执行下update命令 回去更新这个文件资料库，再去查找就会找到了。注意2：locate是无法找到临时目录下面的文件的 比如/tmp</code></pre><hr><p><code>which</code><br>命令所在路径：/usr/bin/which<br>执行权限：所有用户<br>语法：which命令<br>功能描述：搜索命令所在目录及别名信息<br>    范例：which ls</p><hr><pre><code>whereis</code></pre><p>命令所在路径：/usr/bin/whereis<br>执行权限：所有用户<br>语法：whereis [命令名称]<br>功能描述：搜索命令所在目录及帮助文档路径<br>    范例：whereis ls</p><hr><p><code>grep</code><br>命令所在路径：/bin/grep<br>执行权限：所有用户<br>语法：grep -iv[指定字串][文件]<br>功能描述：在文件中搜寻字串匹配的行并输出<br> -i 不区分大小写<br> -v 排除指定字串<br>    范例:grep -i mysql /root/install.log 在/root/install.log文件中不区分大小写的查找mysql<br>         grep -v ^# /etc.initab排除以#开头的行的字符串</p><hr><h3 id="4、帮助命令"><a href="#4、帮助命令" class="headerlink" title="4、帮助命令"></a>4、帮助命令</h3><hr><p><code>man</code><br>英文原意：manual<br>命令所在路径：/usr/bin/man<br>执行权限：所在用户<br>语法：man[命令或配置文件]<br>功能描述：获得帮助信息<br>    范例：man ls<br>          查看ls命令的帮助信息<br>          man services<br>          查看配置文件services的帮助信息<br>          man 5 passwd 查看用户信息</p><pre><code>Linux中,执行man命令查询帮助文档时,是以vi形式打开帮助文档,所以退出时应该键入:q命令</code></pre><hr><p><code>whatis</code> 命令<br>查看到命令简短的介绍信息[该命令是干什么的]</p><hr><p><code>apropos</code> 配置文件的名称<br>查看配置文件的简短信息</p><hr><p>技巧：<br><strong>命令 –help</strong> 会把该命令常见的选项列出来<br>    touch –help</p><hr><p><code>info</code> 跟 man差不多也是显示帮助信息</p><hr><p><code>help</code><br>命令所在路径：Shell内置命令<br>执行权限：所有用户<br>语法：help命令<br>功能描述：获得Shell内置命令的帮助信息<br>范例：help umask   查看umask命令的帮助信息</p><p>用which找不到的命令都是Shell内置命令</p><hr><h3 id="5、用户管理命令"><a href="#5、用户管理命令" class="headerlink" title="5、用户管理命令"></a>5、用户管理命令</h3><hr><p><code>useradd</code></p><p>命令所在路径：/usr/sbin/useradd<br>执行权限：root<br>语法：useradd用户名<br>功能描述：添加新用户<br>    范例：useradd qingwa</p><hr><p><code>passwd</code><br>命令所在路径：/usr/bin/passwd<br>执行权限：所有用户<br>语法：passwd用户名<br>功能描述：设置用户密码<br>    范例 passwd amdin888</p><p>普通用户只能更改自己的密码 而root可以更改所有用户的密码</p><hr><p><code>who</code><br>命令所在路径：/usr/bin/who<br>执行权限：所有用户<br>语法：who<br>功能描述：查看登录用户信息<br>    范例：who </p><p>显示规则：<br>登录用户名  登录终端  tty本地终端  pts表示远程终端（用不同的数字，终端号来区分不同的登录终端） 登录时间（什么时候登录的）</p><hr><p><code>w</code><br>命令所在路径：/usr/bin/w<br>执行权限：所有用户<br>语法：w<br>功能描述：查看登录用户详细信息</p><pre><code>范例：wup linux连续运行多少时间了([uptime命令也行]) ；load average负载均衡的三个值 ；IDLE表示用户登录过来空闲了多久了 ；JCPU当前用户登录过来累计的占用时间；PCPU表示当前登录过来用户当前操作占用的时间 ；WHAT表示当前执行的什么操作、命令</code></pre><hr><h3 id="6、压缩解压命令"><a href="#6、压缩解压命令" class="headerlink" title="6、压缩解压命令"></a>6、压缩解压命令</h3><hr><p>.gz(window中很少)<br>.zip（linux window中都有）<br>.rar(在linux中在需要装一个rar for linux的解压软件)</p><hr><p><code>gzip</code><br>命令所在路径：/bin/gzip<br>执行权限：所有用户<br>语法：gzip [文件]<br>功能描述：压缩文件 注意：跟window是不一样的，只能压缩文件，不能压缩目录，而且压缩完不保留原文件 只剩压缩包了<br>压缩后文件的格式：.gz</p><hr><p><code>gunzip</code><br>命令英文原意：GUNunzip<br>命令所在路径：/bin/gunzip<br>执行权限：所有用户<br>语法：gunzip[压缩文件]<br>功能描述：解压.gz的压缩文件</p><pre><code>范例：gunzip buduo.gz</code></pre><hr><p><code>tar</code>压缩<br>命令所在路径：/bin/tar<br>执行权限：所有用户<br>    语法：tar 选项[-zcf][压缩后文件名][目录]<br>       -c打包 ！！！<br>       -v显示详细信息<br>       -f指定文件名<br>       -z打包同时压缩<br>功能描述：打包目录<br>压缩后文件格式：.tar.gz<br>    例子：tar -cvf Japan.tar.gz Japan  把Japan这个目录压缩成Japan.tar</p><pre><code>tar解压 -x解包 !!!! -v显示详细信息 -f指定解压软件 -z解压缩范例：tar -zxvf Japan.tar.gz</code></pre><hr><p><code>zip</code><br>命令所在路径：/usr/bin/zip<br>执行权限：所有用户<br>语法：<br>zip 选项[-r] [压缩后文件名] [文件或目录]<br>    -r 压缩目录<br>功能描述：压缩文件或目录<br>压缩后文件格式：.zip</p><p>压缩原文件仍未保留 还会显示压缩比 但是压缩比并没有 gzip tar 那么强</p><p>解压：unzip [压缩文件]</p><hr><p><code>bzip2</code><br>命令所在路径：/usr/bin/bzip2<br>执行权限：所有用户<br>语法：bzip2 选项 [-k][文件]<br>      -k 产生压缩文件后保留原文件<br>功能描述：压缩文件<br>压缩文件格式：.bz2<br>    范例：bzip2 -k boduo<br>          tar -cjf Japan.tar.bz2 Japan  把-z换成-j就可以利用tar压缩成.tar.bz2格式</p><p>这个压缩格式比率惊人。</p><hr><p><code>bunzip2</code><br>命令所在路径：/usr/bin/bunzip2<br>执行权限：所有用户<br>语法：bunzip2 选项[-k][压缩文件]<br>      -k解压后保留原文件<br>功能描述：解压<br>    范例：bunzip2 -k boduo.bz2<br>          tar -xjf Japan.tar.bz2</p><hr><h3 id="7、网络命令"><a href="#7、网络命令" class="headerlink" title="7、网络命令"></a>7、网络命令</h3><hr><p><code>write</code><br>指令所在路径：/usr/bin/write<br>执行权限：所有用户<br>语法：write &lt;用户名&gt;<br>功能描述：给在线用户发信息（w可以看到哪些用户在线）,ctrl+D保存结束<br>    范例：# write linzhiling<br>    xxxxxxxxxxxxx<br>    ctrl+D保存结束</p><hr><p><code>wall</code><br>命令英文原意：write all<br>命令所在路径：/usr/bin/wall<br>执行权限：所有用户<br>语法：wall [message]<br>功能描述：发广播信息(给所有在线用户)<br>    范例：# wall qingwa is a animal</p><hr><p><code>ping</code><br>命令所在路径：/bin/ping<br>执行权限：所有用户<br>语法：ping 选项 IP地址<br>      -c 指定发送次数<br>功能描述：测试网络连通性<br>    范例：# ping 192.168.88.99</p><p>ctrl+c结束</p><hr><p><code>ifconfig</code><br>命令英文原意：interface configure<br>命令所在路径：/sbin/ifconfig<br>执行权限：root<br>语法：ifconfig 网卡名称 IP地址<br>功能描述：查看和设置网卡信息<br>    范例：# ifconfig eth0 192.168.88.99</p><p><em>linux有两套网卡<br>eth0|eth1…本地真实的网卡，按照数字方式一次后推<br>lo 回环网卡，用来本机通信和测试的，地址也是固定的 都是127.0.0.1</em></p><hr><p><code>mail</code><br>命令所在路径：/bin/mail<br>执行权限：所有用户<br>语法：mail[用户名]<br>功能描述：查看发送电子邮件<br>    范例：mail root</p><p>这个就不像write命令 可以用户不在线  </p><p>ctrl+D保存结束</p><hr><p><code>last</code></p><p>命令所在路径：/usr/bin/last<br>执行权限：所有用户<br>语法：last<br>功能描述：列出目前与过去登入系统的用户信息<br>    范例：# last</p><p>[运用非常广泛]<br>这个命令非常有效常用的命令！！可以看 有什么其他用户登录了服务器.</p><p>如果有时候我们不想那么多信息，想看到用户最后一次登录的时间，可以用lastlog命令！！</p><hr><p><code>traceroute</code><br>命令所在路径：/bin/traceroute<br>执行权限：所有用户<br>语法：traceroute<br>功能描述：显示数据包到主机间的路径<br>    范例：traceroute www.thaibl.com<br>[运用非常广泛]</p><hr><p><code>netstat</code><br>命令所在路径：/bin/netstat<br>执行权限：所有用户<br>语法：netstat [选项]<br>功能描述：显示网络相关信息</p><pre><code>选项： -t:TCP协议 传输控制协议的简称【三次握手 安全】相当于A打电话B A你是？B你是？ AB要通话了  -u:UDP协议 用户数据报协议【快 不管你在不在线 直接甩给你】相当于发短信  不管你是谁、关机与否、可能被谁看到不管 -l:监听 -r:路由 -n:显示IP地址和端口号范例： # netstat -tlun 查看本机监听的端口 # netstat -an 查看本机所有的网络连接 # netstat -rn 查看本机路由表</code></pre><p>[运用非常广泛，非常重要]</p><hr><p><code>setup</code><br>命令所在路径：/usr/bin/setup<br>执行权限：root<br>语法：setup<br>功能描述：配置网络<br>    范例：# setup</p><hr><p>挂载命令<br><code>mount</code><br>命令所在位置：/bin/mount<br>执行权限：所有用户<br>命令语法：mount [-t 文件系统] 设备文件名 挂载点<br>    范例： # mount -t iso9660 /dev/sr0/ /mnt/cdrom<br>             = mount /dev/sr0/ /mnt/cdrom </p><p>umount 设备文件名|挂载点<br>umount /dev/sr0 卸载光盘<br>需要跳到宿主目录去执行卸载命令</p><hr><h3 id="8、关机重启命令"><a href="#8、关机重启命令" class="headerlink" title="8、关机重启命令"></a>8、关机重启命令</h3><hr><p><code>shutdown</code></p><p>命令语法：shutdown [选项] 时间<br>    选项：-c 取消前一个关机命令<br>          -h 关机<br>          -r 重启</p><pre><code>eg：shutdown -h now 马上关机 shutdown -h 20:30 晚上八点关机    shutdown -r now 马上重启    shutdown -c 取消前一个关机命令</code></pre><p>linux中还有其他重启关机命令，但是早期只有shutdown保存原来开启的服务 现在其他的也有了 但还是推荐这个老命令</p><p>提醒：<br>关机或重启之前必须先把服务停掉！这样才能保证用户不能碰触我，硬盘才会空闲下来，才会重启。</p><p>服务器不能关机 只能重启！！！</p><pre><code>其他关机命令：halt              poweroff 这个就不要用了 直接断电!!!            init 0其他重启命令：reboot            init 6</code></pre><hr><pre><code>系统运行级别：0：关机1：单用户（类似windows启动时按F8进入安全模式，其实就是启动最小的服务，其他多余附加的程序都不用，只启动核心的程序，用来做一些修复。只能root登录进去）2：不完全多用户，不含NFS服务3：完全多用户4：未分配5：图形界面6：重启cat /etc/inittab#修改系统默认运行级别id:3:initdefault:`runlevel`#查询系统运行级别 </code></pre><hr><p>退出登录命令：<br><code>logout</code></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;————————常用命令—————&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1文件处理命令
 1.1命令格式与目录处理命令
 1.2目录处理命令
 1.3文件处理命令
 1.4链接命令
2权限管理命令
3文件搜索命令
4帮助命令
5用户管理命令
6压缩解压命令
7网络命令
8关机重启命令
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://renqiangme.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://renqiangme.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
