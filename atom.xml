<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Renqiang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://renqiangme.github.io/"/>
  <updated>2018-11-22T02:19:40.118Z</updated>
  <id>https://renqiangme.github.io/</id>
  
  <author>
    <name>Renqiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>给MongoDB新增一个readWriteAnyDatabase的角色账户</title>
    <link href="https://renqiangme.github.io/2018/05/01/%E7%BB%99MongoDB%E6%96%B0%E5%A2%9E%E4%B8%80%E4%B8%AAreadWriteAnyDatabase%E7%9A%84%E8%A7%92%E8%89%B2%E8%B4%A6%E6%88%B7/"/>
    <id>https://renqiangme.github.io/2018/05/01/给MongoDB新增一个readWriteAnyDatabase的角色账户/</id>
    <published>2018-05-01T09:18:01.000Z</published>
    <updated>2018-11-22T02:19:40.118Z</updated>
    
    <content type="html"><![CDATA[<p>安装好MongoDB时，通常开了一个最高管理权限的root账户来方便我们管理数据库，实际开发中并一般不使用这个账户，我们可以单独添加一个账户来连接数据库。</p><a id="more"></a><h5 id="mongodb的账户角色"><a class="markdownIt-Anchor" href="#mongodb的账户角色"></a> MongoDB的账户角色：</h5><p>数据库用户角色：read、readWrite</p><p>数据库管理角色：dbAdmin、dbOwner、userAdmin</p><p>集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManage</p><p>备份恢复角色：backup、restore</p><p>所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</p><p>超级用户角色：root</p><p>内部角色：__system</p><p><code>Read</code>：允许用户读取指定数据库</p><p><code>readWrite</code>：允许用户读写指定数据库</p><p><code>dbAdmin</code>：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile</p><p><code>userAdmin</code>：允许用户向system.users集合写入，可以在指定数据库里创建、删除和管理用户</p><p><code>clusterAdmin</code>：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。</p><p><code>readAnyDatabase</code>：只在admin数据库中可用，赋予用户所有数据库的读权限</p><p><code>readWriteAnyDatabase</code>：只在admin数据库中可用，赋予用户所有数据库的读写权限</p><p><code>userAdminAnyDatabase</code>：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限</p><p><code>dbAdminAnyDatabase</code>：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。</p><p><code>root</code>：只在admin数据库中可用。超级账号，超级权限</p><h5 id="新增一个readwriteanydatabase的角色账户"><a class="markdownIt-Anchor" href="#新增一个readwriteanydatabase的角色账户"></a> 新增一个readWriteAnyDatabase的角色账户</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#以root登录(这个root的角色是userAdminAnyDatabase)</div><div class="line">./mongo --port 27017 -u &quot;root&quot; -p &quot;xxx&quot; --authenticationDatabase &quot;admin&quot; </div><div class="line"></div><div class="line">#切换到admin db</div><div class="line">use admin</div><div class="line"></div><div class="line">#查看所有用户</div><div class="line">db.system.users.find()</div><div class="line"></div><div class="line">#新增用户，并授予readWriteAnyDatabase的角色</div><div class="line">db.createUser(&#123;user:&quot;mongodb-admin&quot;,pwd:&quot;123456&quot;,roles:[&#123;role:&quot;readWriteAnyDatabase&quot;, db:&quot;admin&quot;&#125;]&#125;)</div><div class="line"></div><div class="line">#新增xxxx角色</div><div class="line">#db.grantRolesToUser(&quot;mongodb-admin&quot;,[&#123;role:&quot;xxx&quot;,db:&quot;admin&quot;&#125;])</div><div class="line"></div><div class="line">#以mongodb-admin登录</div><div class="line">mongo --port 27017 -u mongodb-admin -p &apos;123456&apos; --authenticationDatabase &apos;admin&apos;</div><div class="line"></div><div class="line">#测试创建集合和查询，如果没有报错，说明权限已经ok</div><div class="line">use test</div><div class="line">db.createCollection(&quot;Account&quot;)</div><div class="line">db.Account.find()</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装好MongoDB时，通常开了一个最高管理权限的root账户来方便我们管理数据库，实际开发中并一般不使用这个账户，我们可以单独添加一个账户来连接数据库。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://renqiangme.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://renqiangme.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>使用Systemd部署管理SpringBoot应用</title>
    <link href="https://renqiangme.github.io/2018/04/17/%E4%BD%BF%E7%94%A8System%E9%83%A8%E7%BD%B2SpringBoot%E5%BA%94%E7%94%A8/"/>
    <id>https://renqiangme.github.io/2018/04/17/使用System部署SpringBoot应用/</id>
    <published>2018-04-17T05:28:12.000Z</published>
    <updated>2018-11-22T02:09:55.586Z</updated>
    
    <content type="html"><![CDATA[<p>如果不使用<code>Docker</code>和<code>Kubernets</code>部署管理<code>SpringBoot</code>应用，可以选择<code>Systemd</code>。</p><p>因为SpringBoot自带Tomcat之类的Web应用服务器，可以直接<code>java -jar xxx.jar</code>的方式启动起来。</p><p>如果我们直接使用<code>nohup java -jar xxx.jar &amp;</code> 之类的虽然也可以实现后台运行，但是是有可能因为某些原因挂掉的，所以我们需要找到一种工具让应用可以重启或者开机启动。</p><p>我们可以使用Python的<code>Supervisor</code>,也有盆友说可以使用Node的<code>pm2</code>,但是我一般都是选择<code>Systemd</code>，现在Linux系统都是自带这个的。</p><a id="more"></a><h5 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h5><p>生成jar包：进入到SpringBoot项目的目录，然后执行：<code>mvn clean package</code>，找到target目录里面的jar包。</p><p>上传jar包：scp -P xx_port xxx.jar username@host:./</p><p>SSH登录进入服务器之后，首先需要安装JDK,然后把jar包复制到/home/www/applications</p><p>在/etc/systemd/system/目录下面新建一个service的配置，配置内容参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[Unit]</div><div class="line">Description=service-test</div><div class="line">After=syslog.target</div><div class="line"></div><div class="line">[Service]</div><div class="line">User=root</div><div class="line">WorkingDirectory=/home/www/applications</div><div class="line">Restart=always</div><div class="line">ExecStart=/usr/local/jdk1.8.0_161/bin/java -jar /home/www/applications/service-test-1.0.jar</div><div class="line">ExecStop=/usr/bin/kill -15  $MAINPID</div><div class="line">SuccessExitStatus=143</div><div class="line"></div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target</div></pre></td></tr></table></figure><p>新增一个新的service之后，需要让配置生效,如果修改配置文件，需要reload。</p><p>使xx service生效:<br><code>systemctl enable xx.service</code></p><p>刷新配置:<br><code>systemctl daemon-reload</code></p><p>启动xx service:</p><p><code>systemctl start xx.service</code></p><p>查看xx service的status:</p><p><code>systemctl status xx.service</code></p><p>重启xx service:</p><p><code>systemctl restart xx.service</code></p><p>看xx service日志,按住shift+g可以跳转到最后一行:</p><p><code>journalctl -u xx.service</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果不使用&lt;code&gt;Docker&lt;/code&gt;和&lt;code&gt;Kubernets&lt;/code&gt;部署管理&lt;code&gt;SpringBoot&lt;/code&gt;应用，可以选择&lt;code&gt;Systemd&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因为SpringBoot自带Tomcat之类的Web应用服务器，可以直接&lt;code&gt;java -jar xxx.jar&lt;/code&gt;的方式启动起来。&lt;/p&gt;
&lt;p&gt;如果我们直接使用&lt;code&gt;nohup java -jar xxx.jar &amp;amp;&lt;/code&gt; 之类的虽然也可以实现后台运行，但是是有可能因为某些原因挂掉的，所以我们需要找到一种工具让应用可以重启或者开机启动。&lt;/p&gt;
&lt;p&gt;我们可以使用Python的&lt;code&gt;Supervisor&lt;/code&gt;,也有盆友说可以使用Node的&lt;code&gt;pm2&lt;/code&gt;,但是我一般都是选择&lt;code&gt;Systemd&lt;/code&gt;，现在Linux系统都是自带这个的。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://renqiangme.github.io/categories/JAVA/"/>
    
    
      <category term="Systemd" scheme="https://renqiangme.github.io/tags/Systemd/"/>
    
      <category term="JAVA" scheme="https://renqiangme.github.io/tags/JAVA/"/>
    
      <category term="SpringBoot" scheme="https://renqiangme.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Log4j2日志-&gt;Kafka-&gt;LogStash-&gt;ElasticSearch并邮件报警</title>
    <link href="https://renqiangme.github.io/2018/01/21/Log4j2%E6%97%A5%E5%BF%97-%3EKafka-%3ELogstash-%3EElasticsearch%E5%B9%B6%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6/"/>
    <id>https://renqiangme.github.io/2018/01/21/Log4j2日志-&gt;Kafka-&gt;Logstash-&gt;Elasticsearch并邮件报警/</id>
    <published>2018-01-21T11:08:28.000Z</published>
    <updated>2018-11-08T05:04:23.362Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot项目中需要把日志记录到<a href="https://www.elastic.co/cn/products/elasticsearch" target="_blank" rel="external">：ElasticSearch</a> 并使用 <a href="https://www.elastic.co/cn/products/kibana" target="_blank" rel="external">：Kibana</a> 搜索、展示、查看日志。</p><h4 id="修改springboot中的配置"><a class="markdownIt-Anchor" href="#修改springboot中的配置"></a> 修改SpringBoot中的配置</h4><p>因为SpringBoot默认使用的日志框架是：<a href="http://logback.qos.ch/" target="_blank" rel="external">：Logback</a>，但是<a href="https://logging.apache.org/log4j/2.x/" target="_blank" rel="external">：Log4j2</a> 性能可能更高就打算替换掉。</p><a id="more"></a><p>替换方法，修改项目maven的pom.xml配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</div><div class="line">    &lt;exclusions&gt;</div><div class="line">        &lt;exclusion&gt;</div><div class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</div><div class="line">        &lt;/exclusion&gt;</div><div class="line">    &lt;/exclusions&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><p>因为需要把日志记录到Kafka，所以引入org.apache.kafka kafka-clients到项目中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;0.10.0.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><p>因为日志在本地测试和线上的kafka的服务器需要分开，通常我们可以在resources目录下面创建：</p><ul><li>本地的log4j2的配置文件名叫log4j2-dev.xml</li><li>正式线上的log4j2的配置文件名叫log4j2-prd.xml</li></ul><p>然后我们可以修改SpringBoot的bootstrap.properties，<code>ACTIVE_ENVIRONMENT</code>为环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">spring.profiles.active=$&#123;ACTIVE_ENVIRONMENT:dev&#125;</div><div class="line">logging.config=classpath:log4j2-$&#123;ACTIVE_ENVIRONMENT&#125;.xml</div></pre></td></tr></table></figure><p>log4j2-xxx.xml的内容例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;Configuration status=&quot;warn&quot;&gt;</div><div class="line">    &lt;Properties&gt;</div><div class="line">    &lt;/Properties&gt;</div><div class="line">    &lt;Appenders&gt;</div><div class="line">        &lt;Console name=&quot;STDOUT&quot; target=&quot;SYSTEM_OUT&quot;&gt;</div><div class="line">            &lt;PatternLayout pattern=&quot;%d %p %c&#123;1.&#125; %t %m%n&quot;/&gt;</div><div class="line">        &lt;/Console&gt;</div><div class="line">         &lt;Kafka name=&quot;KAFKA-LOGGER&quot; topic=&quot;service-logs-dialog-service&quot;&gt;&lt;!--kafka topic--&gt;</div><div class="line">            &lt;JsonLayout/&gt; &lt;!--JsonLayout：日志格式为json,方便在Elastic中处理--&gt;</div><div class="line">            &lt;Property name=&quot;bootstrap.servers&quot;&gt;10.2.200.26:9092&lt;/Property&gt;&lt;!--kafka server的ip:port--&gt;</div><div class="line">            &lt;Property name =&quot;retries&quot; &gt;3&lt;/Property&gt;</div><div class="line">            &lt;Property name =&quot;linger.ms&quot; &gt;1000&lt;/Property&gt;</div><div class="line">            &lt;Property name =&quot;buffer.memory&quot; &gt; 10485760&lt;/Property&gt;</div><div class="line">        &lt;/Kafka&gt;</div><div class="line">        &lt;Async name=&quot;ASYNC-KAFKA-LOGGER&quot;&gt;</div><div class="line">            &lt;AppenderRef ref=&quot;KAFKA-LOGGER&quot;/&gt;</div><div class="line">            &lt;LinkedTransferQueue/&gt;</div><div class="line">        &lt;/Async&gt;</div><div class="line">    &lt;/Appenders&gt;</div><div class="line">    &lt;Loggers&gt;</div><div class="line">        &lt;logger name=&quot;ai.emos.platform.dialog&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;&lt;!--日志级别大于info都会被记录到Kafka--&gt;</div><div class="line">            &lt;AppenderRef ref=&quot;KAFKA-LOGGER&quot;/&gt;</div><div class="line">        &lt;/logger&gt;</div><div class="line">        &lt;!-- Root表示所有Logger用Root中的Appender打印日志  --&gt;</div><div class="line">        &lt;Root level=&quot;info&quot;&gt;</div><div class="line">            &lt;AppenderRef ref=&quot;STDOUT&quot;/&gt;</div><div class="line">            &lt;AppenderRef ref=&quot;ASYNC-KAFKA-LOGGER&quot;/&gt;</div><div class="line">        &lt;/Root&gt;</div><div class="line">    &lt;/Loggers&gt;</div><div class="line">&lt;/Configuration&gt;</div></pre></td></tr></table></figure><h4 id="在logstash中的配置"><a class="markdownIt-Anchor" href="#在logstash中的配置"></a> 在LogStash中的配置</h4><p>LogStash组成结构：<br>Logstash 通过管道进行运作，管道有两个必需的元素，输入和输出，还有一个可选的元素，过滤器。输入插件从数据源获取数据，过滤器插件根据用户指定的数据格式修改数据，输出插件则将数据写入到目的地。<br>因此，需要一个配置文件管理输入、过滤器和输出相关的配置。配置文件内容格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#　输入</div><div class="line">input &#123;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 过滤器</div><div class="line">filter &#123;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 输出</div><div class="line">output &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所以我们创建一个文件到LogStash的配置文件：logstash.yml中path.config配置的扫描目录。</p><p>service-logs.conf配置文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">input &#123;</div><div class="line">   kafka &#123;</div><div class="line">        topics_pattern =&gt; [&quot;service-logs-.*&quot;]</div><div class="line">        bootstrap_servers =&gt; &quot;10.1.220.27:9092&quot;</div><div class="line">        group_id =&gt; &quot;local-logstash&quot;</div><div class="line">        decorate_events =&gt; true</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">filter &#123;</div><div class="line">    json &#123;</div><div class="line">        source =&gt; &quot;message&quot;</div><div class="line">    &#125;</div><div class="line">    mutate &#123;</div><div class="line">        add_field =&gt; &#123;</div><div class="line">                &quot;kafka_topic&quot; =&gt; &quot;%&#123;[@metadata][kafka][topic]&#125;&quot;</div><div class="line">                &quot;kafka_consumer_group&quot; =&gt; &quot;%&#123;[@metadata][kafka][consumer_group]&#125;&quot;</div><div class="line">                &quot;kafka_partition&quot; =&gt; &quot;%&#123;[@metadata][kafka][partition]&#125;&quot;</div><div class="line">                &quot;kafka_offset&quot; =&gt; &quot;%&#123;[@metadata][kafka][offset]&#125;&quot;</div><div class="line">                &quot;kafka_timestamp&quot; =&gt; &quot;%&#123;[@metadata][kafka][timestamp]&#125;&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">output &#123;</div><div class="line">  if [level] == &quot;ERROR&quot; &#123;</div><div class="line">        http &#123;</div><div class="line">                url =&gt; &quot;http://localhost:8088/send/mail&quot;</div><div class="line">                http_method =&gt; &quot;post&quot;</div><div class="line">                automatic_retries =&gt; 0</div><div class="line">                connect_timeout =&gt; 6</div><div class="line">                keepalive =&gt; false</div><div class="line">        &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  elasticsearch &#123;</div><div class="line">        hosts =&gt; [&quot;127.0.0.1:9200&quot;]</div><div class="line">        action =&gt; &quot;index&quot;</div><div class="line">        index =&gt; &quot;logstash-%&#123;[kafka_topic]&#125;&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们可以看到上面output针对日志级别是ERROR的会发送一个HTTP请求到一个发邮件的服务器，因为LogStash自带的邮件发不出来，所以单独用了nodejs写了一个发邮件接口。</p><p>如果使用LogStash自带的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">output &#123;</div><div class="line">      if [level] == &quot;ERROR&quot; &#123;</div><div class="line">            email &#123;</div><div class="line">                    debug =&gt; true</div><div class="line">                    to =&gt; &quot;xx@qq.com&quot;</div><div class="line">                    from =&gt; &quot;xxx@126.com&quot;</div><div class="line">                    subject =&gt; &apos;Alert - Error&apos;</div><div class="line">                    codec =&gt; &quot;plain&quot;</div><div class="line">                    contenttype =&gt; &quot;text/html; charset=UTF-8&quot;</div><div class="line">                    body =&gt; &quot;Tags: %&#123;tags&#125;\\n\\Content:\\n%&#123;message&#125;&quot;</div><div class="line">                    username =&gt; &quot;xxx@126.com&quot;</div><div class="line">                    password =&gt; &quot;xxx&quot;</div><div class="line">                    address =&gt; &quot;smtp.126.com&quot;</div><div class="line">                    domain =&gt; &quot;smtp.126.com&quot;</div><div class="line">                    port =&gt; 25</div><div class="line">                    use_tls =&gt; false</div><div class="line">                    via =&gt; &quot;smtp&quot;</div><div class="line">            &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>LogStash的功能很强大，更多可以阅读官方的文档。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringBoot项目中需要把日志记录到&lt;a href=&quot;https://www.elastic.co/cn/products/elasticsearch&quot;&gt;：ElasticSearch&lt;/a&gt; 并使用 &lt;a href=&quot;https://www.elastic.co/cn/products/kibana&quot;&gt;：Kibana&lt;/a&gt; 搜索、展示、查看日志。&lt;/p&gt;
&lt;h4 id=&quot;修改springboot中的配置&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#修改springboot中的配置&quot;&gt;&lt;/a&gt; 修改SpringBoot中的配置&lt;/h4&gt;
&lt;p&gt;因为SpringBoot默认使用的日志框架是：&lt;a href=&quot;http://logback.qos.ch/&quot;&gt;：Logback&lt;/a&gt;，但是&lt;a href=&quot;https://logging.apache.org/log4j/2.x/&quot;&gt;：Log4j2&lt;/a&gt; 性能可能更高就打算替换掉。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://renqiangme.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="https://renqiangme.github.io/tags/JAVA/"/>
    
      <category term="Kafka" scheme="https://renqiangme.github.io/tags/Kafka/"/>
    
      <category term="LogStash" scheme="https://renqiangme.github.io/tags/LogStash/"/>
    
      <category term="ElasticSearch" scheme="https://renqiangme.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>Git的一些操作记录</title>
    <link href="https://renqiangme.github.io/2018/01/12/Git%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    <id>https://renqiangme.github.io/2018/01/12/Git的一些操作记录/</id>
    <published>2018-01-12T01:30:28.000Z</published>
    <updated>2018-11-08T03:47:51.989Z</updated>
    
    <content type="html"><![CDATA[<h4 id="git撤销某个commit"><a class="markdownIt-Anchor" href="#git撤销某个commit"></a> Git撤销某个commit</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码,同时清空了暂存区(回退commit和index信息)</div><div class="line">git reset –soft：回退到某个版本，只回退了commit的信息，git不会清除你的暂存区。如果还要提交，直接commit即可</div><div class="line">git reset –hard：彻底回退到某个版本，直接覆盖工作区，暂存区，本地的源码所有的内容也会变为上一个版本的内容</div><div class="line"></div><div class="line">Git撤销命令后面的可选参数：</div><div class="line">HEAD 最近一个提交</div><div class="line">HEAD^ 上一次</div><div class="line">&lt;commit_id&gt;  每次commit的SHA1值. 可以用git log 看到,也可以在页面上commit标签页里找到</div></pre></td></tr></table></figure><a id="more"></a><p>如果本地的源码彻底回退到某个版本，并希望远程Git仓库的记录也回滚的话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git reset --hard &lt;commit_id&gt;</div><div class="line">git push origin HEAD --force</div></pre></td></tr></table></figure><p>如果本地的源码彻底回退到某个版本，又想回滚到回滚前的某个版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reflog</div></pre></td></tr></table></figure><p>git reflog 可以查看所有分支的所有操作记录（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录。</p><h4 id="修改git使用的远程仓库"><a class="markdownIt-Anchor" href="#修改git使用的远程仓库"></a> 修改Git使用的远程仓库</h4><p>三种方式：</p><p>1：修改命令 git remte origin set-url url</p><p>2：先删后加 git remote rm origin &amp;&amp; git remote add origin url</p><p>3：直接修改文件: .git/config</p><h4 id="打包出git两个commit之间提交过的文件"><a class="markdownIt-Anchor" href="#打包出git两个commit之间提交过的文件"></a> 打包出Git两个commit之间提交过的文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff xxx xxx --name-only | xargs tar -cvzf update.tar.gz</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;git撤销某个commit&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#git撤销某个commit&quot;&gt;&lt;/a&gt; Git撤销某个commit&lt;/h4&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码,同时清空了暂存区(回退commit和index信息)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git reset –soft：回退到某个版本，只回退了commit的信息，git不会清除你的暂存区。如果还要提交，直接commit即可&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git reset –hard：彻底回退到某个版本，直接覆盖工作区，暂存区，本地的源码所有的内容也会变为上一个版本的内容&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Git撤销命令后面的可选参数：&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;HEAD 最近一个提交&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;HEAD^ 上一次&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;commit_id&amp;gt;  每次commit的SHA1值. 可以用git log 看到,也可以在页面上commit标签页里找到&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Git" scheme="https://renqiangme.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://renqiangme.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装Elastic Stack</title>
    <link href="https://renqiangme.github.io/2018/01/02/Ubuntu%E5%AE%89%E8%A3%85Elastic%20Stack/"/>
    <id>https://renqiangme.github.io/2018/01/02/Ubuntu安装Elastic Stack/</id>
    <published>2018-01-02T08:18:08.000Z</published>
    <updated>2018-11-08T02:36:30.333Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1首先安装python-software-properties"><a class="markdownIt-Anchor" href="#1首先安装python-software-properties"></a> 1.首先安装python-software-properties</h4><p>该程序将安装add-apt-repository的应用程序，更加方便的添加和使用PPA软件库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install -y python-software-properties software-properties-common apt-transport-https</div></pre></td></tr></table></figure><a id="more"></a><h4 id="2安装java8"><a class="markdownIt-Anchor" href="#2安装java8"></a> 2.安装java8</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:webupd8team/java -y</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install -y oracle-java8-installer</div></pre></td></tr></table></figure><p>打印java的版本信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -version</div></pre></td></tr></table></figure><h4 id="3安装elastic"><a class="markdownIt-Anchor" href="#3安装elastic"></a> 3.安装elastic</h4><h5 id="31安装之前先添加elastic-repository-key-到server"><a class="markdownIt-Anchor" href="#31安装之前先添加elastic-repository-key-到server"></a> 3.1：安装之前先添加elastic repository key 到server</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -</div></pre></td></tr></table></figure><h5 id="32找到当前的文档版本导入当前的repository到sourceslistd"><a class="markdownIt-Anchor" href="#32找到当前的文档版本导入当前的repository到sourceslistd"></a> 3.2：找到当前的文档版本，导入当前的repository到sources.list.d：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;deb https://artifacts.elastic.co/packages/6.x/apt stable main&quot; | sudo tee -a /etc/apt/sources.list.d/elastic-6.x.list</div></pre></td></tr></table></figure><h4 id="4安装elasticsearch"><a class="markdownIt-Anchor" href="#4安装elasticsearch"></a> 4:安装elasticsearch</h4><p>Elasticsearch是一个基于Apache Lucene™的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。</p><p>但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。</p><p>Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p><p>不过，Elasticsearch不仅仅是Lucene和全文搜索，我们还能这样去描述它：</p><p>分布式的实时文件存储，每个字段都被索引并可被搜索</p><p>分布式的实时分析搜索引擎</p><p>可以扩展到上百台服务器，处理PB级结构化或非结构化数据</p><p>而且，所有的这些功能被集成到一个服务里面，你的应用可以通过简单的RESTful API、各种语言的客户端甚至命令行与之交互<br>。</p><h5 id="41安装及修改配置文件"><a class="markdownIt-Anchor" href="#41安装及修改配置文件"></a> 4.1:安装及修改配置文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install -y elasticsearch</div></pre></td></tr></table></figure><p>配置文件路径：/etc/elasticsearch/elasticsearch.yml</p><p>可以修改host，port…</p><h5 id="42加入开机自启动服务"><a class="markdownIt-Anchor" href="#42加入开机自启动服务"></a> 4.2:加入开机自启动服务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo systemctl daemon-reload</div><div class="line">sudo systemctl enable elasticsearch</div><div class="line">sudo systemctl start elasticsearch</div></pre></td></tr></table></figure><h5 id="43通过system进行管理elasticsearch"><a class="markdownIt-Anchor" href="#43通过system进行管理elasticsearch"></a> 4.3:通过system进行管理elasticsearch</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">systemctl status elasticsearch</div><div class="line"></div><div class="line">systemctl start elasticsearch</div><div class="line"></div><div class="line">systemctl stop elasticsearch</div><div class="line"></div><div class="line">systemctl restart elasticsearch</div></pre></td></tr></table></figure><h5 id="44查看运行情况"><a class="markdownIt-Anchor" href="#44查看运行情况"></a> 4.4:查看运行情况</h5><p>查看端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -plntu</div></pre></td></tr></table></figure><p>查看elasticsearch的cluster,版本…相关信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;localhost:9200/?pretty&apos;</div></pre></td></tr></table></figure><p>查看集群健康情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/_cat/health?v&apos;</div></pre></td></tr></table></figure><p>查看集群中的节点列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/_cat/nodes?v&apos;</div></pre></td></tr></table></figure><p>查看index情况:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl &apos;localhost:9200/_cat/indices?v&apos;</div></pre></td></tr></table></figure><h5 id="44参考文档"><a class="markdownIt-Anchor" href="#44参考文档"></a> 4.4:参考文档</h5><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/cn/index.html" target="_blank" rel="external">Elasticsearch: 权威指南</a></p><h4 id="5安装kibana"><a class="markdownIt-Anchor" href="#5安装kibana"></a> 5:安装Kibana</h4><p>Kibana是一个为Elasticsearch平台分析和可视化的开源平台，使用Kibana能够搜索、展示存储在Elasticsearch中的索引数据。使用它可以很方便用图表、表格、地图展示和分析数据。<br>Kibana能够轻松处理大量数据，通过浏览器接口能够轻松的创建和分享仪表盘，通过改变Elasticsearch查询时间，可以完成动态仪表盘。</p><h5 id="51通过apt安装及配置"><a class="markdownIt-Anchor" href="#51通过apt安装及配置"></a> 5.1:通过apt安装及配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install -y kibana</div></pre></td></tr></table></figure><p>配置文件路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/kibana/kibana.yml</div></pre></td></tr></table></figure><p>可以修改host,port,以及elasticsearch的url</p><h5 id="52加入开机自启动"><a class="markdownIt-Anchor" href="#52加入开机自启动"></a> 5.2:加入开机自启动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo systemctl enable kibana</div><div class="line">sudo systemctl start kibana</div></pre></td></tr></table></figure><h5 id="53通过system进行管理kibana"><a class="markdownIt-Anchor" href="#53通过system进行管理kibana"></a> 5.3:通过system进行管理kibana</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">systemctl status kibana</div><div class="line"></div><div class="line">systemctl start kibana</div><div class="line"></div><div class="line">systemctl stop kibana</div><div class="line"></div><div class="line">systemctl restart kibana</div></pre></td></tr></table></figure><h4 id="6安装logstash"><a class="markdownIt-Anchor" href="#6安装logstash"></a> 6:安装Logstash</h4><p>Logstash 是一个开源的数据收集引擎具有实时管道能力。</p><p>Logstash 可以动态的统一数据从不同的来源和使数据规范化到你选择的目的地。</p><p>当Logstash 起初驾驭创新到日志收集,它的功能很好的扩展超出使用案例。任何事件的类型可以被丰富和改变使用一个input,filter和输出引擎,使用很多的本地的代码简化了采集的过程。</p><h5 id="61通过apt安装"><a class="markdownIt-Anchor" href="#61通过apt安装"></a> 6.1:通过apt安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install -y logstash</div></pre></td></tr></table></figure><h5 id="62logstash的配置文件目录"><a class="markdownIt-Anchor" href="#62logstash的配置文件目录"></a> 6.2:logstash的配置文件目录：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/etc/logstash/</div><div class="line"></div><div class="line">├── conf.d</div><div class="line">│   └── kafka-logs-local.conf</div><div class="line">├── jvm.options</div><div class="line">├── log4j2.properties</div><div class="line">├── logstash.yml</div><div class="line">└── startup.options</div></pre></td></tr></table></figure><p>logstash.yml:</p><p>path.config:定义扫描input,filter,output的配置目录</p><p>path.logs: 定义log配置，在测试配置文件的时候有用。</p><p>input:kafka,output:elasticsearch的example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">input &#123;</div><div class="line">   kafka &#123;</div><div class="line">        topics_pattern =&gt; [&quot;service-logs-.*&quot;]</div><div class="line">        bootstrap_servers =&gt; &quot;10.1.220.27:9092&quot;</div><div class="line">        group_id =&gt; &quot;local-logstash&quot;</div><div class="line">        decorate_events =&gt; true</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">filter &#123;</div><div class="line">    json &#123;</div><div class="line">        source =&gt; &quot;message&quot;</div><div class="line">    &#125;</div><div class="line">    mutate &#123;</div><div class="line">        add_field =&gt; &#123;</div><div class="line">                &quot;kafka_topic&quot; =&gt; &quot;%&#123;[@metadata][kafka][topic]&#125;&quot;</div><div class="line">                &quot;kafka_consumer_group&quot; =&gt; &quot;%&#123;[@metadata][kafka][consumer_group]&#125;&quot;</div><div class="line">                &quot;kafka_partition&quot; =&gt; &quot;%&#123;[@metadata][kafka][partition]&#125;&quot;</div><div class="line">                &quot;kafka_offset&quot; =&gt; &quot;%&#123;[@metadata][kafka][offset]&#125;&quot;</div><div class="line">                &quot;kafka_timestamp&quot; =&gt; &quot;%&#123;[@metadata][kafka][timestamp]&#125;&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">output &#123;</div><div class="line">  if [level] == &quot;ERROR&quot; &#123;</div><div class="line">        http &#123;</div><div class="line">                url =&gt; &quot;http://localhost:8088/send/mail&quot;</div><div class="line">                http_method =&gt; &quot;post&quot;</div><div class="line">                automatic_retries =&gt; 0</div><div class="line">                connect_timeout =&gt; 6</div><div class="line">                keepalive =&gt; false</div><div class="line">        &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  elasticsearch &#123;</div><div class="line">        hosts =&gt; [&quot;127.0.0.1:9200&quot;]</div><div class="line">        action =&gt; &quot;index&quot;</div><div class="line">        index =&gt; &quot;logstash-%&#123;[kafka_topic]&#125;&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="63加入开机自启动"><a class="markdownIt-Anchor" href="#63加入开机自启动"></a> 6.3:加入开机自启动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo systemctl enable logstash</div><div class="line">sudo systemctl start logstash</div></pre></td></tr></table></figure><h5 id="64通过system进行管理logstash"><a class="markdownIt-Anchor" href="#64通过system进行管理logstash"></a> 6.4:通过system进行管理logstash</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">systemctl status logstash</div><div class="line"></div><div class="line">systemctl start logstash</div><div class="line"></div><div class="line">systemctl stop logstash</div><div class="line"></div><div class="line">systemctl restart logstash</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1首先安装python-software-properties&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1首先安装python-software-properties&quot;&gt;&lt;/a&gt; 1.首先安装python-software-properties&lt;/h4&gt;
&lt;p&gt;该程序将安装add-apt-repository的应用程序，更加方便的添加和使用PPA软件库。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sudo apt-get update&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sudo apt-get install -y python-software-properties software-properties-common apt-transport-https&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://renqiangme.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://renqiangme.github.io/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://renqiangme.github.io/tags/Ubuntu/"/>
    
      <category term="Elastic Stack" scheme="https://renqiangme.github.io/tags/Elastic-Stack/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu设置固定的ip</title>
    <link href="https://renqiangme.github.io/2017/08/18/Ubuntu%E8%AE%BE%E7%BD%AE%E5%9B%BA%E5%AE%9A%E7%9A%84ip/"/>
    <id>https://renqiangme.github.io/2017/08/18/Ubuntu设置固定的ip/</id>
    <published>2017-08-18T05:28:18.000Z</published>
    <updated>2018-11-08T02:45:49.776Z</updated>
    
    <content type="html"><![CDATA[<p>修改配置文件：/etc/network/interfaces</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">vim /etc/network/interfaces</div><div class="line"></div><div class="line">#增加修改如下：</div><div class="line"></div><div class="line">#The primary network interface</div><div class="line">auto ens160</div><div class="line">iface ens160 inet static</div><div class="line">address 10.1.220.15</div><div class="line">netmask 255.255.0.0</div><div class="line">gateway 10.1.1.1</div><div class="line">dns-nameservers 8.8.8.8 8.8.4.4</div><div class="line"></div><div class="line">service networking restart</div></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;修改配置文件：/etc/network/interfaces&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;vim /etc/network/interfaces&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#增加修改如下：&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#The primary network interface&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;auto ens160&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iface ens160 inet static&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;address 10.1.220.15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;netmask 255.255.0.0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;gateway 10.1.1.1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;dns-nameservers 8.8.8.8 8.8.4.4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;service networking restart&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://renqiangme.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://renqiangme.github.io/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://renqiangme.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>部署管理Swoole服务</title>
    <link href="https://renqiangme.github.io/2017/07/12/%E9%83%A8%E7%BD%B2%E7%AE%A1%E7%90%86Swoole%E6%9C%8D%E5%8A%A1/"/>
    <id>https://renqiangme.github.io/2017/07/12/部署管理Swoole服务/</id>
    <published>2017-07-12T03:20:38.000Z</published>
    <updated>2018-11-22T02:05:20.831Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用systemd管理swoole服务"><a class="markdownIt-Anchor" href="#使用systemd管理swoole服务"></a> 使用systemd管理Swoole服务</h3><p>Systemd 是 Linux 系统工具，用来启动守护进程。</p><p>Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。包括：systemctl，systemd-analyze，hostnamectl，localectl，timedatectl，loginctl</p><a id="more"></a><p>更多参考<a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html/" target="_blank" rel="external">：Systemd介绍</a></p><p>所以Swoole的服务器程序可以编写一段service脚本，交由systemd进行管理。实现故障重启、开机自启动等功能。</p><p>使用systemd管理swoole服务参考文档:<a href="https://wiki.swoole.com/wiki/page/699.html/" target="_blank" rel="external">swoole官方文档</a></p><p>Demo:</p><p>在/etc/systemd/system/swoole_http.service新建一个service文件,内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[Unit]</div><div class="line">Description=Swoole Http service</div><div class="line">After=network.target</div><div class="line">After=syslog.target</div><div class="line"></div><div class="line">[Service]</div><div class="line">Type=forking</div><div class="line">PIDFile=/home/www/http/bin/server.pid</div><div class="line">ExecStart=/home/www/http/bin/server</div><div class="line">ExecStop=/bin/kill -15 $MAINPID</div><div class="line">ExecReload=/bin/kill -USR1 $MAINPID</div><div class="line">Restart=always</div><div class="line"></div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target graphical.target</div></pre></td></tr></table></figure><p>需要注意的是$MAINPID必须要是manager的id,不然启动或者重启的时候会报错。而且还需要修改swoole配置参数,把swoole的守护进程化设置为daemonize =&gt; 1。</p><p>kill -USR1 pid 重启woker进程和task进程</p><p>kill -USR2 pid 重启task进程</p><p>kill -15 管理进程id 关掉所有的manager相关进程</p><p>关于swoole重启的文档:<a href="https://wiki.swoole.com/wiki/page/p-server/reload.html" target="_blank" rel="external">链接</a></p><h3 id="使用supervisor管理swoole服务"><a class="markdownIt-Anchor" href="#使用supervisor管理swoole服务"></a> 使用Supervisor管理swoole服务</h3><p>Supervisor是一个客户/服务器系统，它可以在类Unix系统中管理控制大量进程。Supervisor使用python开发，有多年历史，目前很多生产环境下的服务器都在使用Supervisor,部署python程序经常这个。</p><p>Supervisor的服务器端称为supervisord，主要负责在启动自身时启动管理的子进程，响应客户端的命令，重启崩溃或退出的子进程，记录子进程stdout和stderr输出，生成和处理子进程生命周期中的事件。可以在一个配置文件中配置相关参数，包括Supervisord自身的状态，其管理的各个子进程的相关属性。配置文件一般位于/etc/supervisord.conf。</p><p>Supervisor的客户端称为supervisorctl，它提供了一个类shell的接口（即命令行）来使用supervisord服务端提供的功能。通过supervisorctl，用户可以连接到supervisord服务器进程，获得服务器进程控制的子进程的状态，启动和停止子进程，获得正在运行的进程列表。客户端通过Unix域套接字或者TCP套接字与服务端进行通信，服务器端具有身份凭证认证机制，可以有效提升安全性。当客户端和服务器位于同一台机器上时，客户端与服务器共用同一个配置文件/etc/supervisord.conf，通过不同标签来区分两者的配置。</p><p>Supervisor也提供了一个web页面来查看和管理进程状态，这个功能非常酷.</p><h4 id="安装supervisor"><a class="markdownIt-Anchor" href="#安装supervisor"></a> 安装Supervisor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 我们可以通过pypi安装</div><div class="line">pip install supervisor</div><div class="line"># 或者从pypi上下载源码，然后安装</div><div class="line">python setup.py install</div><div class="line"># 安装完之后，使用下列命令来生成配置文件</div><div class="line">echo_supervisord_conf &gt; /etc/supervisord.conf</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># mkdir /etc/supervisord.d  用户存放被监控进程的配置文件</div></pre></td></tr></table></figure><p>修改/etc/supervisord.conf配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">在文件结尾[include]节点处把</div><div class="line">;files = relative/directory/*.ini改为files =/etc/supervisord.d/*.conf</div><div class="line"></div><div class="line">同时还需要去掉[include]前面的;</div></pre></td></tr></table></figure><p>保存并退出。</p><h4 id="把supervisor加入开机自启动服务"><a class="markdownIt-Anchor" href="#把supervisor加入开机自启动服务"></a> 把supervisor加入开机自启动服务</h4><p>到systemd系统下新建一个service配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /lib/systemd/system/supervisor.service</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[Unit]</div><div class="line">Description=supervisor</div><div class="line">After=network.target</div><div class="line"></div><div class="line">[Service]</div><div class="line">Type=forking</div><div class="line">ExecStart=/usr/bin/supervisord -c /etc/supervisord.conf</div><div class="line">ExecStop=/usr/bin/supervisorctl $OPTIONS shutdown</div><div class="line">ExecReload=/usr/bin/supervisorctl $OPTIONS reload</div><div class="line">KillMode=process</div><div class="line">Restart=on-failure</div><div class="line">RestartSec=42s</div><div class="line"></div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target graphical.target</div></pre></td></tr></table></figure><p>上述文件编写后，执行如下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl enable supervisor.service</div></pre></td></tr></table></figure><p>加入开机自启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl daemon-reload</div></pre></td></tr></table></figure><p>重新载入systemd，扫描新的或有变动的单元。</p><p>实际上supervisor已经加入了systemctl管理了，后续起停supervisor服务都可以通过systemctl来控制了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">systemctl start supervisor.service 启动服务</div><div class="line"></div><div class="line">systemctl stop supervisor.service 停止服务</div><div class="line"></div><div class="line">systemctl restart supervisor.service 重新启动服务</div><div class="line"></div><div class="line">systemctl reload supervisor.service 重载配置文件</div><div class="line"></div><div class="line">systemctl status supervisor.service 查看服务状态</div></pre></td></tr></table></figure><h4 id="在etcsupervisordd-增加一个程序的demo配置参数"><a class="markdownIt-Anchor" href="#在etcsupervisordd-增加一个程序的demo配置参数"></a> 在/etc/supervisord.d 增加一个程序的demo配置参数：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">[program:cat]                ;程序名</div><div class="line">command=/bin/cat            ;命令绝对路径，可以包含参数</div><div class="line">process_name=%(program_name)s    ;进程名</div><div class="line">numprocs=1                  ;supervisor启动多少个该程序，如果大于1，那么进程名必须包括%(process_num)s</div><div class="line">directory=/tmp              ;该进程的启动时的工作目录</div><div class="line">umask=022                   ;掩码</div><div class="line">priority=999                ;优先级</div><div class="line">autostart=true              ;该程序是否在supervisor启动时启动</div><div class="line">autorestart=true            ;如果为false，那么该程序的相关进程永远不会自动重启。如果为unexpected，该程序的相关进程仅会在退出码为exitcodes中的值时重启;如果为true时</div><div class="line">startsecs=10                 ;最大启动时间</div><div class="line">startretries=3               ;最大启动重试次数。超过这个次数后，该进程会标记为FATAL状态</div><div class="line">exitcodes=0,2                ;退出码，关联autorestart=unexpected</div><div class="line"></div><div class="line">stopsignal=TERM                     ;关闭该程序相关进程所发送的信号量。可以为TERM, HUP, INT, QUIT, KILL, USR1, or USR2</div><div class="line">stopwaitsecs=10              ;supervisord父进程等待该程序的相关子进程返回SIGCLILD信号量的时间，超时后则发送SIGKILL</div><div class="line">user=chrism                  ;启动该程序进程的用户</div><div class="line">redirect_stderr=false        ;如果为true，则将该程序的进程错误输出到supervisor主日志文件中</div><div class="line">stdout_logfile=/tmp          ;标准输出</div><div class="line">stdout_logfile_maxbytes=1MB  ;日志轮滚</div><div class="line">stdout_logfile_backups=10    ;日志轮滚</div><div class="line">stdout_capture_maxbytes=1MB    </div><div class="line">stderr_logfile=/a/path        </div><div class="line">stderr_logfile_maxbytes=1MB</div><div class="line">stderr_logfile_backups=10</div><div class="line">stderr_capture_maxbytes=1MB</div><div class="line">environment=A=&quot;1&quot;,B=&quot;2&quot;        ;！环境变量信息</div><div class="line">serverurl=AUTO                 ;传送给该子进程的环境变量SUPERVISOR_SERVER_URL ，AUTO则自动提供一个Supervisord的URL。用于该进程可以和内部HTTP Server进行通信，简化进程管理。</div></pre></td></tr></table></figure><p>从swoole的文档我们得知：<br>Swoole提供了柔性终止/重启的机制，管理员只需要向SwooleServer发送特定的信号，Server的worker进程可以安全的结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">SIGTERM: 向主进程/管理进程发送此信号服务器将安全终止</div><div class="line">在PHP代码中可以调用$serv-&gt;shutdown()完成此操作</div><div class="line"></div><div class="line">SIGUSR1: 向主进程/管理进程发送SIGUSR1信号，将平稳地restart所有worker进程</div><div class="line">在PHP代码中可以调用$serv-&gt;reload()完成此操作</div><div class="line">swoole的reload有保护机制，当一次reload正在进行时，收到新的重启信号会丢弃</div><div class="line">如果设置了user/group，Worker进程可能没有权限向master进程发送信息，这种情况下必须使用root账户，在shell中执行kill指令进行重启</div><div class="line">reload指令对addProcess添加的用户进程无效</div><div class="line"></div><div class="line">#重启所有worker进程</div><div class="line">kill -USR1 主进程PID</div><div class="line"></div><div class="line">#仅重启task进程</div><div class="line">kill -USR2 主进程PID</div></pre></td></tr></table></figure><p>supervisor的程序restart的原理是实际上是发信号，所以我们需要给swoole的程序stop信号配置为：stopsignal=TERM</p><p>同时还需要把swoole的守护进程化设置为daemonize =&gt; 0，不然会报spawned error</p><h4 id="supervisorctl控制program"><a class="markdownIt-Anchor" href="#supervisorctl控制program"></a> supervisorctl控制program</h4><p>现在supervisor的server端我们已经交给systemd去管理，现在我们可以通过supervisorctl去控制配置添加的program</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">supervisorctl -c supervisor.conf status                    察看supervisor的状态</div><div class="line"></div><div class="line">supervisorctl -c supervisor.conf reload                    重新载入 配置文件</div><div class="line"></div><div class="line">supervisorctl -c supervisor.conf start [all]|[appname]     启动指定/所有supervisor管理的程序进程</div><div class="line"></div><div class="line">supervisorctl -c supervisor.conf stop [all]|[appname]      关闭指定/所有 supervisor管理的程序进程</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用systemd管理swoole服务&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#使用systemd管理swoole服务&quot;&gt;&lt;/a&gt; 使用systemd管理Swoole服务&lt;/h3&gt;
&lt;p&gt;Systemd 是 Linux 系统工具，用来启动守护进程。&lt;/p&gt;
&lt;p&gt;Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。包括：systemctl，systemd-analyze，hostnamectl，localectl，timedatectl，loginctl&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://renqiangme.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://renqiangme.github.io/tags/PHP/"/>
    
      <category term="Swoole" scheme="https://renqiangme.github.io/tags/Swoole/"/>
    
      <category term="Systemd" scheme="https://renqiangme.github.io/tags/Systemd/"/>
    
      <category term="Supervisor" scheme="https://renqiangme.github.io/tags/Supervisor/"/>
    
  </entry>
  
  <entry>
    <title>Python获取音频时长和分割音频</title>
    <link href="https://renqiangme.github.io/2017/06/26/Python%E8%8E%B7%E5%8F%96%E9%9F%B3%E9%A2%91%E6%97%B6%E9%95%BF%E5%92%8C%E5%88%86%E5%89%B2%E9%9F%B3%E9%A2%91/"/>
    <id>https://renqiangme.github.io/2017/06/26/Python获取音频时长和分割音频/</id>
    <published>2017-06-26T12:12:07.000Z</published>
    <updated>2018-11-08T02:11:31.124Z</updated>
    
    <content type="html"><![CDATA[<p><code>ffmpeg</code>是视频和音频处理的利器，各种转格式，提取视频中的图片，合并或者分隔音频，录制屏幕，加字幕啊…都是可以的。</p><p>因为有需求需要获取音频的长度然后来分割。</p><p>虽然<code>ffmpeg -i xxx file</code>也可以获取到音频的长度,但是可能需要正则去匹配，然后发现他们家族的<code>ffprobe</code>就可以直接返回json格式的音频信息。<code>ffprobe</code>是一个多媒体流分析工具。</p><a id="more"></a><p>大概命令如下:</p><pre><code>ffprobe -v quiet -print_format json -show_format -show_streams 1.wav</code></pre><p>python中可以这样子调用：</p><pre><code>    import subprocess as sp    try:    command = ['ffprobe', '-v', 'quiet', '-print_format', 'json', '-show_format','-show_streams', item[&quot;file_path&quot;]]    wav_info = sp.check_output(command, stderr=sp.STDOUT)    print(wav_info)    except sp.CalledProcessError as e:    print('get audio info by ffprobe error %s' % e.output)</code></pre><p>分割音频就需要用到<code>ffmpeg</code>了，大概命令如下：</p><pre><code>ffmpeg -i 1.wav -ss 00:00:03 -t 00:00:12 -acodec copy tmp.wav源音频：source_mp3开始位置：-ss结束位置：-t原始编码：-acodec</code></pre><p>需要注意的是：input的音频格式必须和output的音频格式一致，不然要报格式错误！</p><p>python中可以这样子调用：</p><pre><code>    try:    cut_command = ['ffmpeg', '-y', '-i', origin_wav, '-ss', start_time, '-t',end_time, '-acodec', 'copy', cut_wav]    wav_cut_result = sp.check_call(cut_command)    if wav_cut_result == 0:    #todo success    except sp.CalledProcessError as e:    print('cut audio info error %s' % e.output)</code></pre><p>音频格式转换:</p><pre><code>单声道&amp;采样率16000ffmpeg -f s16le -ar 16000 -ac 1 -i xx.pcm xx.wav-f：强制格式s16le：无压缩-ar：采样率-ac：声道-i：输入文件</code></pre><p>更多命令相关参数：<code>ffmpeg --help</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ffmpeg&lt;/code&gt;是视频和音频处理的利器，各种转格式，提取视频中的图片，合并或者分隔音频，录制屏幕，加字幕啊…都是可以的。&lt;/p&gt;
&lt;p&gt;因为有需求需要获取音频的长度然后来分割。&lt;/p&gt;
&lt;p&gt;虽然&lt;code&gt;ffmpeg -i xxx file&lt;/code&gt;也可以获取到音频的长度,但是可能需要正则去匹配，然后发现他们家族的&lt;code&gt;ffprobe&lt;/code&gt;就可以直接返回json格式的音频信息。&lt;code&gt;ffprobe&lt;/code&gt;是一个多媒体流分析工具。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://renqiangme.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://renqiangme.github.io/tags/Python/"/>
    
      <category term="ffmpeg" scheme="https://renqiangme.github.io/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Redis通过模式匹配模糊删除key</title>
    <link href="https://renqiangme.github.io/2017/03/25/Redis%E9%80%9A%E8%BF%87%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E6%A8%A1%E7%B3%8A%E5%88%A0%E9%99%A4key/"/>
    <id>https://renqiangme.github.io/2017/03/25/Redis通过模式匹配模糊删除key/</id>
    <published>2017-03-25T07:33:29.000Z</published>
    <updated>2018-11-08T02:57:33.263Z</updated>
    
    <content type="html"><![CDATA[<p>Redis命令del不支持模式匹配，但是keys支持，如果需要通过模式匹配来删除一批，可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/redis/bin/redis-cli -h xx -p xx -a xx KEYS “test_*” | xargs /usr/local/redis/bin/redis-cli -h xx-p xx -a xx DEL</div></pre></td></tr></table></figure><a id="more"></a><p>关于keys命令的模式匹配介绍，可以参考：</p><p><a href="https://redis.io/commands/keys" target="_blank" rel="external">https://redis.io/commands/keys</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis命令del不支持模式匹配，但是keys支持，如果需要通过模式匹配来删除一批，可以执行：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;/usr/local/redis/bin/redis-cli -h xx -p xx -a xx KEYS “test_*” | xargs /usr/local/redis/bin/redis-cli -h xx-p xx -a xx DEL&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://renqiangme.github.io/categories/Linux/"/>
    
      <category term="Redis" scheme="https://renqiangme.github.io/categories/Linux/Redis/"/>
    
    
      <category term="Redis" scheme="https://renqiangme.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>在Centos上面源码安装TensorFlow</title>
    <link href="https://renqiangme.github.io/2017/03/18/%E5%9C%A8Centos%E4%B8%8A%E9%9D%A2%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85TensorFlow/"/>
    <id>https://renqiangme.github.io/2017/03/18/在Centos上面源码安装TensorFlow/</id>
    <published>2017-03-18T03:28:19.000Z</published>
    <updated>2018-11-08T02:10:48.227Z</updated>
    
    <content type="html"><![CDATA[<p>最先一开始用pip安装，但是总是在运行的时有源码安装效果更好的提示，所以索性源码安装，整个编译过程还真的是蛮久的。</p><a id="more"></a><p>源码安装<strong>TensorFlow</strong>需要先安装<strong>Bazel</strong>这个google推出的自动化构建工具。</p><p>1：安装Bazel之前先安装JDK</p><p>2：下载源码zip包<br><a href="https://github.com/bazelbuild/bazel/releases/" title="https://github.com/bazelbuild/bazel/releases/" target="_blank" rel="external">https://github.com/bazelbuild/bazel/releases/</a></p><p>3：然后直接执行./compile.sh等待出现安装成功后<br>4：把bazel导入到环境变量。<br>:vim /etc/profile<br>加入export PATH=/home/yangrenqiang/bazel/output:$PATH<br>source /etc/profile</p><p>5：测试bazel是否安装成功<br>bazel help</p><p>6：在github上面下载tensorflow的源码<br>7：执行./configure<br>8：<br>bazel build --config=opt //tensorflow/tools/pip_package:build_pip_package<br>9：<br>bazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg<br>10:<br>sudo pip install /tmp/tensorflow_pkg/tensorflow-1.0.1-py2-none-any.whl</p><p>具体参考：<br><a href="https://www.tensorflow.org/install/install_sources" title="https://www.tensorflow.org/install/install_sources" target="_blank" rel="external">https://www.tensorflow.org/install/install_sources</a></p><p>关于TensorFlow的中文文档：<a href="http://docs.pythontab.com/tensorflow/" title="http://docs.pythontab.com/tensorflow/" target="_blank" rel="external">http://docs.pythontab.com/tensorflow/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最先一开始用pip安装，但是总是在运行的时有源码安装效果更好的提示，所以索性源码安装，整个编译过程还真的是蛮久的。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://renqiangme.github.io/categories/Linux/"/>
    
    
      <category term="TensorFlow" scheme="https://renqiangme.github.io/tags/TensorFlow/"/>
    
      <category term="Centos" scheme="https://renqiangme.github.io/tags/Centos/"/>
    
      <category term="AI" scheme="https://renqiangme.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>Linux禁止某些用户和组SSH登录</title>
    <link href="https://renqiangme.github.io/2017/02/08/Linux%E7%A6%81%E6%AD%A2%E6%9F%90%E4%BA%9B%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84SSH%E7%99%BB%E5%BD%95/"/>
    <id>https://renqiangme.github.io/2017/02/08/Linux禁止某些用户和组SSH登录/</id>
    <published>2017-02-08T04:10:02.000Z</published>
    <updated>2018-11-08T03:04:58.602Z</updated>
    
    <content type="html"><![CDATA[<p>Linux系统可以通过sshd的配置项，禁止某些用户SSH登录，方法如下：</p><a id="more"></a><p>1、打开sshd的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/ssh/sshd_config</div></pre></td></tr></table></figure><p>2、修改该配置文件，增加或修改如下行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#禁止用户user1登陆，多个用户空格分隔</div><div class="line"></div><div class="line">DenyUsers user1</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#禁止用户组group1的所有用户登录，多个空格分隔</div><div class="line"></div><div class="line">DenyGroups group1</div></pre></td></tr></table></figure><p>3、保存配置后，重启sshd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/rc.d/init.d/sshd restart</div></pre></td></tr></table></figure><p>完成上面的配置后，就可以禁止用户或用户组的用户进行SSH登录</p><p>4、配置完毕后，在其它linux机器上使用如下命令进行测试</p><p>使用ssh测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ssh user1@192.168.1.168</div><div class="line">user1@192.168.1.168&apos;s password:</div><div class="line">Permission denied, please try again.</div></pre></td></tr></table></figure><p>授权被拒绝，已经实现禁用该用户使用SSH登录</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux系统可以通过sshd的配置项，禁止某些用户SSH登录，方法如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://renqiangme.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://renqiangme.github.io/tags/Linux/"/>
    
      <category term="SSH" scheme="https://renqiangme.github.io/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>Linux禁止root账户远程SSH登录</title>
    <link href="https://renqiangme.github.io/2017/02/08/Linux%E7%A6%81%E6%AD%A2root%E8%B4%A6%E6%88%B7%E8%BF%9C%E7%A8%8BSSH%E7%99%BB%E5%BD%95/"/>
    <id>https://renqiangme.github.io/2017/02/08/Linux禁止root账户远程SSH登录/</id>
    <published>2017-02-08T03:25:42.000Z</published>
    <updated>2018-11-08T02:57:25.814Z</updated>
    
    <content type="html"><![CDATA[<p>为增强服务器的安全,我们通常会禁止root账户远程SSH登录。</p><p>首先增加一个普通权限的用户：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">useradd demo</div><div class="line">passwd demo123</div></pre></td></tr></table></figure><p>修改配置文件/etc/ssh/sshd_config，禁止root远程SSH登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/ssh/sshd_config</div></pre></td></tr></table></figure><p>把PermitRootLogin改为no</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PermitRootLogin yes</div><div class="line">PermitRootLogin no</div></pre></td></tr></table></figure><p>重启sshd服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service sshd restart</div></pre></td></tr></table></figure><p>然后远程管理，用普通用户demo登录，然后用 su root 切换到root用户拿到最高权限，来保障服务器的安全。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为增强服务器的安全,我们通常会禁止root账户远程SSH登录。&lt;/p&gt;
&lt;p&gt;首先增加一个普通权限的用户：&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://renqiangme.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://renqiangme.github.io/tags/Linux/"/>
    
      <category term="SSH" scheme="https://renqiangme.github.io/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>通过nginx代理nodejs支持websocket</title>
    <link href="https://renqiangme.github.io/2017/01/20/%E9%80%9A%E8%BF%87nginx%E4%BB%A3%E7%90%86nodejs%E6%94%AF%E6%8C%81websocket/"/>
    <id>https://renqiangme.github.io/2017/01/20/通过nginx代理nodejs支持websocket/</id>
    <published>2017-01-20T04:05:42.000Z</published>
    <updated>2018-11-08T02:10:15.102Z</updated>
    
    <content type="html"><![CDATA[<p>NGINX自从1.3版本就开始支持WebSocket了，并且可以为WebSocket应用程序做反向代理和负载均衡。</p><p>WebSocket 和HTTP协议不同，但是WebSocket中的握手和HTTP中的握手兼容，它使用HTTP中的Upgrade协议头将连接从HTTP升级到WebSocket。这使得WebSocket程序可以更容易的使用现已存在的基础设施。例如，WebSocket可以使用标准的HTTP端口 80 和 443，因此，现存的防火墙规则也同样适用。</p><a id="more"></a><p>一个WebSockets的应用程序会在客户端和服务端保持一个长时间工作的连接。用来将连接从HTTP升级到WebSocket的HTTP升级机制使用HTTP的Upgrade和Connection协议头。反向代理服务器在支持WebSocket方面面临着一些挑战。一项挑战是WebSocket是一个hop-by-hop协议，所以，当代理服务器拦截到一个客户端发来的Upgrade请求时，它(指服务器)需要将它自己的Upgrade请求发送给后端服务器，也包括合适的请求头。此外，由于WebSocket连接是长时间保持的，所以代理服务器需要允许这些连接处于打开状态，而不是像对待HTTP使用的短连接那样将其关闭。</p><p>NGINX 通过在客户端和后端服务器之间建立起一条隧道来支持WebSocket。为了使NGINX可以将来自客户端的Upgrade请求发送给后端服务器，Upgrade和Connection的头信息必须被显式的设置。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">proxy_set_header Upgrade $http_upgrade;</div><div class="line">proxy_set_header Connection &quot;upgrade&quot;;</div></pre></td></tr></table></figure><p>完整配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">upstream wsbackend &#123;</div><div class="line">       server 127.0.0.1:3000;#nodejs启动的本地端口</div><div class="line">       keepalive 8;</div><div class="line">&#125;</div><div class="line">server</div><div class="line">    &#123;</div><div class="line">        listen 80;</div><div class="line">        server_name xxx.com;</div><div class="line">        index index.html index.htm index.php default.html default.htm default.php;</div><div class="line">        root  /home/wwwroot/xxx.com;</div><div class="line">        location / &#123;</div><div class="line">                proxy_pass http://wsbackend;</div><div class="line">#这两个HTTP头是因为采用了nginx作为代理后，后端可以通过 X-real-ip 或 X-Forwarded-For取得用户IP地址</div><div class="line">                proxy_set_header X-Real-IP $remote_addr;</div><div class="line">                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</div><div class="line">                proxy_set_header Host $http_host;</div><div class="line">                proxy_set_header X-NginX-Proxy true;</div><div class="line">                proxy_http_version 1.1;</div><div class="line">                proxy_set_header Upgrade $http_upgrade;#  声明支持websocket</div><div class="line">                proxy_set_header Connection &quot;upgrade&quot;;#  声明支持websocket</div><div class="line">                proxy_redirect off;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NGINX自从1.3版本就开始支持WebSocket了，并且可以为WebSocket应用程序做反向代理和负载均衡。&lt;/p&gt;
&lt;p&gt;WebSocket 和HTTP协议不同，但是WebSocket中的握手和HTTP中的握手兼容，它使用HTTP中的Upgrade协议头将连接从HTTP升级到WebSocket。这使得WebSocket程序可以更容易的使用现已存在的基础设施。例如，WebSocket可以使用标准的HTTP端口 80 和 443，因此，现存的防火墙规则也同样适用。&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://renqiangme.github.io/categories/Nginx/"/>
    
      <category term="NodeJS" scheme="https://renqiangme.github.io/categories/Nginx/NodeJS/"/>
    
    
      <category term="Nginx" scheme="https://renqiangme.github.io/tags/Nginx/"/>
    
      <category term="NodeJS" scheme="https://renqiangme.github.io/tags/NodeJS/"/>
    
      <category term="Websocket" scheme="https://renqiangme.github.io/tags/Websocket/"/>
    
  </entry>
  
  <entry>
    <title>网页加载优化-PHP压缩网页进Redis,Openresty端直接输出</title>
    <link href="https://renqiangme.github.io/2016/12/25/%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96-PHP%E5%8E%8B%E7%BC%A9%E7%BD%91%E9%A1%B5%E8%BF%9BRedis-Openresty%E7%AB%AF%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%87%BA/"/>
    <id>https://renqiangme.github.io/2016/12/25/网页加载优化-PHP压缩网页进Redis-Openresty端直接输出/</id>
    <published>2016-12-25T14:07:30.000Z</published>
    <updated>2018-11-08T02:09:44.016Z</updated>
    
    <content type="html"><![CDATA[<p>其实商城项目的网页端，观察京东，淘宝他们有很多活动页面或者商品详情页，推广力度很多，流量也就比较多，通常一个页面很大很大，整个网页内容也很多，单纯考虑从webserver到走进php,java连接数据库等等读取数据拼装，再渲染视图输出到浏览器，整个过程下来，并发不大的情况还好，一大起来的就会性能大大的降低。</p><p>对于中小型项目，解决的方案肯定没有淘宝京东的方案多。</p><a id="more"></a><p>于是就要想解决优化的方案，像商品详情页有商品相关的静态数据，同时掺杂着一些评论，购买数量等等的动态数据，其实可以把整个网页动静分离，动态数据走接口，静态数据直接gzip压缩存进缓存，通过Openresty在nginx层面通过lua直接读取就输出,然后浏览器自动解压gzip。由于页面数据是压缩了的可以节省网络IO,大大提升页面的加载速度。但是像一些活动页面，动态数据可能没有那么多,改动商品相关的价格库存…等等改动那么频繁，其实可以直接扔进CDN,动态数据也走接口。</p><p>下面来看下PHP的几个GZIP压缩相关的函数，都是基于ZLIB库。</p><p>gzcompress gzdeflate gzencode函数的区别在于它们压缩的数据格式不同：</p><p>gzcompress使用的是ZLIB格式；</p><p>gzdeflate使用的是纯粹的DEFLATE格式；</p><p>gzencode使用的是GZIP格式；</p><p>但是有一点是相同的，它们压缩数据时都使用了DEFLATE压缩算法（理论上ZLIB和GZIP格式可以使用其他的压缩算法，但是目前实践中只使用DEFLATE算法），ZLIB和GZIP只不过是在DEFLATE的基础之上加了一些头部和尾部而已。</p><p>顺便提一下，HTTP协议中的Content-Encoding: deflate使用的是ZLIB格式而不是纯DEFLATE格式。</p><p>通过测试发现，gzencode和gzdeflate浏览器可以自动解压出来，前提是：http的请求头里面有accept-encoding:gzip, deflate，说明方案是可行的，但是对于一些浏览器可能不支持自动解压，所以需要判断下请求头，如果不支持，就需要lua解压之后再输出。</p><p>既然使用Openresty就在社区搜索了下。<br>lua的zlib库有两个：<br>–<a href="https://github.com/brimworks/lua-zlib" title="lua-zlib" target="_blank" rel="external">lua-zlib</a><br>–通过LuaJIT的FFI库来包装ZLIB模块</p><p>选择的是：lua-zlib</p><p>lua输出判断函数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">echoPage</span><span class="params">(index_page)</span></span></div><div class="line"><span class="comment">--如果index_page=nil 就继续让nginx执行下一阶段，走进php让php自己处理</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> index_page <span class="keyword">then</span></div><div class="line">ngx.exit(ngx.OK)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="keyword">local</span> accept_encoding_table = ngx.req.get_headers()</div><div class="line"><span class="keyword">local</span> accept_encoding = accept_encoding_table[<span class="string">"accept-encoding"</span>]</div><div class="line"><span class="keyword">local</span> need_uncompress = <span class="number">0</span></div><div class="line"><span class="keyword">if</span> accept_encoding ~= <span class="keyword">nil</span> <span class="keyword">and</span> #accept_encoding&gt;<span class="number">0</span> <span class="keyword">then</span></div><div class="line"><span class="keyword">local</span> begin,stop = ngx.re.find(accept_encoding,<span class="string">'gzip'</span>)</div><div class="line"><span class="keyword">if</span> begin ~= <span class="keyword">nil</span>  <span class="keyword">then</span></div><div class="line">need_uncompress = <span class="number">0</span></div><div class="line"><span class="keyword">else</span></div><div class="line">need_uncompress = <span class="number">1</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="keyword">else</span></div><div class="line">need_uncompress = <span class="number">1</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="keyword">if</span> need_uncompress == <span class="number">1</span> <span class="keyword">then</span></div><div class="line"><span class="keyword">local</span> zlib = <span class="built_in">require</span> <span class="string">"zlib"</span></div><div class="line"><span class="keyword">local</span> stream = zlib.inflate()</div><div class="line"><span class="keyword">local</span> inflated,stream_eof,bytes_in,bytes_out = stream(res)</div><div class="line">ngx.say(inflated)</div><div class="line"><span class="keyword">else</span></div><div class="line">ngx.header[<span class="string">"Content-Encoding"</span>] = <span class="string">"gzip"</span><span class="comment">--避免Nginx再去压缩，需要发送一个响应头，告诉Nginx是一个gzip压缩的</span></div><div class="line">ngx.send_headers()</div><div class="line">ngx.say(res)</div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>注释：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ngx.exit(ngx.OK)<span class="comment">--因为openresty有执行阶段这一个说法，是告诉openresty执行下一阶段</span></div><div class="line">ngx.exit(<span class="number">200</span>)<span class="comment">--意思是直接返回200，不再向下执行。也可以是其他的http状态码。</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实商城项目的网页端，观察京东，淘宝他们有很多活动页面或者商品详情页，推广力度很多，流量也就比较多，通常一个页面很大很大，整个网页内容也很多，单纯考虑从webserver到走进php,java连接数据库等等读取数据拼装，再渲染视图输出到浏览器，整个过程下来，并发不大的情况还好，一大起来的就会性能大大的降低。&lt;/p&gt;
&lt;p&gt;对于中小型项目，解决的方案肯定没有淘宝京东的方案多。&lt;/p&gt;
    
    </summary>
    
      <category term="Openresty" scheme="https://renqiangme.github.io/categories/Openresty/"/>
    
    
      <category term="PHP" scheme="https://renqiangme.github.io/tags/PHP/"/>
    
      <category term="Openresty" scheme="https://renqiangme.github.io/tags/Openresty/"/>
    
      <category term="Redis" scheme="https://renqiangme.github.io/tags/Redis/"/>
    
      <category term="zlib" scheme="https://renqiangme.github.io/tags/zlib/"/>
    
  </entry>
  
  <entry>
    <title>Openresty中获取和设置cookie</title>
    <link href="https://renqiangme.github.io/2016/12/24/Openresty%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AEcookie/"/>
    <id>https://renqiangme.github.io/2016/12/24/Openresty中获取和设置cookie/</id>
    <published>2016-12-24T14:27:52.000Z</published>
    <updated>2018-11-08T02:09:28.465Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1获取cookie"><a class="markdownIt-Anchor" href="#1获取cookie"></a> 1：获取cookie</h3><p>local cookie_xx_value = ngx.var.cookie_xx</p><a id="more"></a><h3 id="2设置cookie"><a class="markdownIt-Anchor" href="#2设置cookie"></a> 2：设置cookie</h3><p>因为cookie的过期时间格是林尼治时间需要注意转下。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">local</span> expires = <span class="number">3600</span> * <span class="number">24</span>  <span class="comment">-- cookie expires = 1 day</span></div><div class="line">ngx.header[<span class="string">"Set-Cookie"</span>] = <span class="string">"hello=world; Path=/; Expires="</span> .. ngx.cookie_time(ngx.time() + expires)</div></pre></td></tr></table></figure><p>如果想同时设置多个cookie，可以传一个table</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">local</span> expires = <span class="number">3600</span> * <span class="number">24</span>  <span class="comment">-- cookie expires = 1 day</span></div><div class="line"><span class="keyword">local</span> cookie_table = &#123;</div><div class="line"><span class="string">"hello=world; Path=/;Domain=/; Expires="</span> .. ngx.cookie_time(ngx.time() + expires),</div><div class="line"><span class="string">"hello2=world2; Path=/;Domain=/; Expires="</span> .. ngx.cookie_time(ngx.time() + expires),</div><div class="line"><span class="string">"hello3=world3; Path=/;Domain=/; Expires="</span> .. ngx.cookie_time(ngx.time() + expires)</div><div class="line">&#125;</div><div class="line">ngx.header[<span class="string">"Set-Cookie"</span>] = cookie_table</div></pre></td></tr></table></figure><p>更多cookie相关可以参考wikipedia:<a href="https://en.wikipedia.org/wiki/HTTP_cookie" title="https://en.wikipedia.org/wiki/HTTP_cookie" target="_blank" rel="external">https://en.wikipedia.org/wiki/HTTP_cookie</a></p><p>也可以直接使用github上面分享的lua的cookie封装好的库。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1获取cookie&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1获取cookie&quot;&gt;&lt;/a&gt; 1：获取cookie&lt;/h3&gt;
&lt;p&gt;local cookie_xx_value = ngx.var.cookie_xx&lt;/p&gt;
    
    </summary>
    
      <category term="Openresty" scheme="https://renqiangme.github.io/categories/Openresty/"/>
    
    
      <category term="Openresty" scheme="https://renqiangme.github.io/tags/Openresty/"/>
    
      <category term="Cookie" scheme="https://renqiangme.github.io/tags/Cookie/"/>
    
  </entry>
  
  <entry>
    <title>Openresty中使用lua的mongodb库，使用连接池节省连接认证时间</title>
    <link href="https://renqiangme.github.io/2016/11/20/Openresty%E4%B8%AD%E4%BD%BF%E7%94%A8lua%E7%9A%84mongodb%E5%BA%93%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%BF%9E%E6%8E%A5%E6%B1%A0%E8%8A%82%E7%9C%81%E8%BF%9E%E6%8E%A5%E8%AE%A4%E8%AF%81%E6%97%B6%E9%97%B4/"/>
    <id>https://renqiangme.github.io/2016/11/20/Openresty中使用lua的mongodb库，使用连接池节省连接认证时间/</id>
    <published>2016-11-20T01:36:37.000Z</published>
    <updated>2018-11-08T02:09:14.301Z</updated>
    
    <content type="html"><![CDATA[<p>因为服务器的mongodb开启了auth认证的，所以每次连接都要验证密码，测试了下GitHub上面的几个lua的mongodb库，无论是官方的<a href="https://github.com/mongodb-labs/mongorover" title="mongorover" target="_blank" rel="external">mongorover</a>，还是纯的lua库：<a href="https://github.com/LuaDist2/lua-resty-mongol3" title="lua-resty-mongol3" target="_blank" rel="external">lua-resty-mongol3</a>，一个简单的insert操作都比php耗费的时间更长，如果业务用lua来做的优势就没有那么明显了，单纯的不认证的insert操作lua的优势很是明显的，所以要么取消认证，要么就是可以结合openresty的连接池。而且发现使用连接池后，纯的lua mongodb库竟然比mongorover更快。</p><a id="more"></a><p>下面是动态判断该连接是否是连接池里面的一些判断，把连接与认证封装在一起,减少不必要认证次数。同时修改了仓库的源码，以支持支持自定义连接池，这样可以让不同 用户名、密码、数据库 的连接分开，不相互干扰。</p><p>新建一个lua文件，只做连接操作。<br>local mongo = require “resty.mongol”<br>local _M = {}</p><pre><code>--把连接与认证封装在一起,减少不必要认证次数local function connect(config)    local db = mongo:new()    if not db then        return nil,nil, &quot;db not initialized&quot;    end    if config.host == nil or config.host == '' or config.port == nil or config.port == '' or config.database == nil or config.database == '' then        return nil,nil, &quot;host,port,database can't empty&quot;    end    local user = config.user    if(user == nil or user == '') thenuser = ''    end    --支持自定义连接池，这样可以让不同 用户名、密码、数据库 的连接分开，不相互干扰，mongol库本身是没有实现的，所以修改了源码    local pool = user .. &quot;:&quot; .. config.database .. &quot;:&quot; .. config.host .. &quot;:&quot; .. config.port    local ok, err = db:connect(config.host, config.port, {pool = pool})     if not ok thenreturn nil,nil,err    end    --选择数据库    local select_db = db:new_db_handle(config.database)    --获取连接池里面的已经auth过连接的数量    local times,err =db:get_reused_times()    if((times == 0 or times == nil) and #user &gt; 0) then ok,err = select_db:auth_scram_sha1(config.user,config.password)if not ok thenreturn nil,nil,err     end    end    return db,select_db,nilendreturn _M</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为服务器的mongodb开启了auth认证的，所以每次连接都要验证密码，测试了下GitHub上面的几个lua的mongodb库，无论是官方的&lt;a href=&quot;https://github.com/mongodb-labs/mongorover&quot; title=&quot;mongorover&quot;&gt;mongorover&lt;/a&gt;，还是纯的lua库：&lt;a href=&quot;https://github.com/LuaDist2/lua-resty-mongol3&quot; title=&quot;lua-resty-mongol3&quot;&gt;lua-resty-mongol3&lt;/a&gt;，一个简单的insert操作都比php耗费的时间更长，如果业务用lua来做的优势就没有那么明显了，单纯的不认证的insert操作lua的优势很是明显的，所以要么取消认证，要么就是可以结合openresty的连接池。而且发现使用连接池后，纯的lua mongodb库竟然比mongorover更快。&lt;/p&gt;
    
    </summary>
    
      <category term="Openresty" scheme="https://renqiangme.github.io/categories/Openresty/"/>
    
    
      <category term="MongoDB" scheme="https://renqiangme.github.io/tags/MongoDB/"/>
    
      <category term="Openresty" scheme="https://renqiangme.github.io/tags/Openresty/"/>
    
      <category term="Lua" scheme="https://renqiangme.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>Composer与__autoload自动加载冲突问题</title>
    <link href="https://renqiangme.github.io/2016/11/04/Composer%E4%B8%8E-autoload%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/"/>
    <id>https://renqiangme.github.io/2016/11/04/Composer与-autoload自动加载冲突问题/</id>
    <published>2016-11-04T08:53:08.000Z</published>
    <updated>2018-11-08T02:09:06.652Z</updated>
    
    <content type="html"><![CDATA[<p>最近改一些旧的项目遇到的一个有意思的问题。<br>一个项目从入口文件进来，定义了自动加载函数__autoload()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function __autoload($className)&#123;</div><div class="line">$class = $className . &apos;.class.php&apos;;</div><div class="line">require_once(CLASS_DIR.$class);</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><p>然后这个旧的项目在程序某个操作类下面引入了composer来自动加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">require BASIC_PATH.&apos;vendor/autoload.php&apos;;</div><div class="line">print_r(spl_autoload_functions());</div><div class="line">class Testtest&#123;</div><div class="line">public function __construct($upload_type,$act_id,$img_name=&apos;&apos;)&#123;</div><div class="line">        print_r(spl_autoload_functions());</div><div class="line">        echo &apos;&lt;br/&gt;&lt;br/&gt;&apos;;</div><div class="line">        $client = new MongoDB\Client($GLOBALS[&apos;config&apos;][&apos;mongodb_loho&apos;]);</div><div class="line">        var_dump($client);</div><div class="line">        echo &apos;&lt;br/&gt;&lt;br/&gt;&apos;;</div><div class="line">        $upload = new Upload();</div><div class="line">        var_dump($upload);</div><div class="line">        echo &apos;&lt;br/&gt;&lt;br/&gt;&apos;;</div><div class="line">        $client2 = new MongoDB\Client($GLOBALS[&apos;config&apos;][&apos;mongodb_loho&apos;]);</div><div class="line">        var_dump($client2);</div><div class="line">        echo &apos;&lt;br/&gt;&lt;br/&gt;&apos;;</div><div class="line">        $upload2 = new Upload();</div><div class="line">        var_dump($upload2);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">Array</div><div class="line">(</div><div class="line">    [0] =&gt; Array</div><div class="line">        (</div><div class="line">            [0] =&gt; Composer\Autoload\ClassLoader Object</div><div class="line">                (</div><div class="line">                    [prefixLengthsPsr4:Composer\Autoload\ClassLoader:private] =&gt; Array</div><div class="line">                        (</div><div class="line">                            [M] =&gt; Array</div><div class="line">                                (</div><div class="line">                                    [MongoDB\] =&gt; 8</div><div class="line">                                )</div><div class="line"></div><div class="line">                        )</div><div class="line"></div><div class="line">                    [prefixDirsPsr4:Composer\Autoload\ClassLoader:private] =&gt; Array</div><div class="line">                        (</div><div class="line">                            [MongoDB\] =&gt; Array</div><div class="line">                                (</div><div class="line">                                    [0] =&gt; E:\UPUPW_NP5.5_64\htdocs\tupian\vendor/mongodb/mongodb/src</div><div class="line">                                )</div><div class="line"></div><div class="line">                        )</div><div class="line"></div><div class="line">                    [fallbackDirsPsr4:Composer\Autoload\ClassLoader:private] =&gt; Array</div><div class="line">                        (</div><div class="line">                        )</div><div class="line"></div><div class="line">                    [prefixesPsr0:Composer\Autoload\ClassLoader:private] =&gt; Array</div><div class="line">                        (</div><div class="line">                        )</div><div class="line"></div><div class="line">                    [fallbackDirsPsr0:Composer\Autoload\ClassLoader:private] =&gt; Array</div><div class="line">                        (</div><div class="line">                        )</div><div class="line"></div><div class="line">                    [useIncludePath:Composer\Autoload\ClassLoader:private] =&gt; </div><div class="line">                    [classMap:Composer\Autoload\ClassLoader:private] =&gt; Array</div><div class="line">                        (</div><div class="line">                        )</div><div class="line"></div><div class="line">                    [classMapAuthoritative:Composer\Autoload\ClassLoader:private] =&gt; </div><div class="line">                    [missingClasses:Composer\Autoload\ClassLoader:private] =&gt; Array</div><div class="line">                        (</div><div class="line">                        )</div><div class="line"></div><div class="line">                )</div><div class="line"></div><div class="line">            [1] =&gt; loadClass</div><div class="line">        )</div><div class="line"></div><div class="line">)</div><div class="line">Array</div><div class="line">(</div><div class="line">    [0] =&gt; __autoload</div><div class="line">)</div><div class="line">&lt;br/&gt;&lt;br/&gt;MongoDB\Client.class.php</div></pre></td></tr></table></figure><p>我们会发现，上面的代码，进行到构造函数里面的时候，打印出返回所有已注册的__autoload()函数的时候，只有入口文件定义的，这是为什么呢?按理说使用了require包含的类库文件作用是全局的，手册上面有：<br>When a file is included, the code it contains inherits the variable scope of the line on which the include occurs. Any variables available at that line in the calling file will be available within the called file, from that point forward. However, all functions and classes defined in the included file have the global scope!<br>使用get_included_files()函数打印出来的时候也是看得到的。<br>然后在在网上搜索了下，这篇文章恰好能够解释：<a href="http://www.jb51.net/article/31279.htm" title="http://www.jb51.net/article/31279.htm" target="_blank" rel="external">http://www.jb51.net/article/31279.htm</a></p><p>把require BASIC_PATH.‘vendor/autoload.php’;放在外面，使用spl_autoload_functions函数打印的时候，发现并没有把composer的加入到类里面，估计是scope的问题，程序执行到这里，发现已经定义了全局的自动加载函数__autoload，就执行执行这个自动加载的函数，然后找不到直接抛出一个严重错误，中断执行，但是在构造函数开头添加一句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spl_autoload_register(&apos;__autoload&apos;);</div></pre></td></tr></table></figure><p>把定义的全局构造函数加入到全局变量autoload_functions的hash table中，就既可以自动找到composer引入的类，又可以自动找到全局的autoload定义的类。从而实现自动加载。</p><p>加入把文件开头包含composer的入口文件移动到构造函数里面，就会发现全局的自动加载的函数的类找不到了，因为：<br>__autoload 方法在 spl_autoload_register 后会失效，因为 autoload_func 函数指针已指向 spl_autoload 方法。</p><p>解决办法也是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spl_autoload_register( &apos;__autoload&apos; );</div></pre></td></tr></table></figure><p>把__autoload 方法加入 autoload_functions list</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近改一些旧的项目遇到的一个有意思的问题。&lt;br /&gt;
一个项目从入口文件进来，定义了自动加载函数__autoload()&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function __autoload($className)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	$class = $className . &amp;apos;.class.php&amp;apos;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	require_once(CLASS_DIR.$class);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://renqiangme.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://renqiangme.github.io/tags/PHP/"/>
    
      <category term="Composer" scheme="https://renqiangme.github.io/tags/Composer/"/>
    
  </entry>
  
  <entry>
    <title>PHP遍历某个目录下面的文件并使用多进程记录到数据库的几种方法比较</title>
    <link href="https://renqiangme.github.io/2016/10/10/PHP%E9%81%8D%E5%8E%86%E6%9F%90%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%96%87%E4%BB%B6%E5%B9%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%AE%B0%E5%BD%95%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/"/>
    <id>https://renqiangme.github.io/2016/10/10/PHP遍历某个目录下面的文件并使用多进程记录到数据库的几种方法比较/</id>
    <published>2016-10-10T08:00:30.000Z</published>
    <updated>2018-11-08T02:09:06.656Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作需要写一个脚本去跑某个目录下面的文件然后记录到数据库，比较了下三种遍历目录的方法.</p><p>打印了测试目录weixin下面有多少文件,文件一共3千多，层级深度还是比较深的。<br><img src="/static/upload/55262d40-30af-4485-95a3-ec46dc31b012.png" alt=""></p><a id="more"></a><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * php import.php xxx目录 比如：php import.php images</div><div class="line"> * 此目录是跟脚本同级顶级的目录</div><div class="line"> */</div><div class="line">$t1 = microtime(<span class="keyword">true</span>);</div><div class="line">define(<span class="string">'BASIC_PATH'</span>,P(dirname(<span class="keyword">__FILE__</span>)).<span class="string">'/'</span>);</div><div class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($argv))&#123;</div><div class="line">    <span class="keyword">exit</span>(<span class="string">"请在命令行执行此脚本\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(count($argv) &lt;= <span class="number">1</span> || <span class="keyword">empty</span>($argv[<span class="number">1</span>]))&#123;</div><div class="line">   <span class="keyword">exit</span>(<span class="string">"请输入需要导入的文件夹,比如php import.php images\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//默认只取第一个参数，暂不多个文件夹处理</span></div><div class="line">$need_import_dir = BASIC_PATH.$argv[<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="comment">//调用法1</span></div><div class="line">getFiles1($need_import_dir);</div><div class="line"><span class="comment">//调用法2</span></div><div class="line">getFiles2($need_import_dir);</div><div class="line"><span class="comment">//调用法3</span></div><div class="line">$directory = <span class="keyword">new</span> RecursiveDirectoryIterator($need_import_dir);</div><div class="line">getFiles3($directory);</div><div class="line"></div><div class="line">$t2 = microtime(<span class="keyword">true</span>);</div><div class="line"><span class="keyword">echo</span> <span class="string">'耗时'</span>.round($t2-$t1,<span class="number">3</span>).<span class="string">"秒\n"</span>;</div><div class="line"><span class="comment">//自定义函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span><span class="params">($path)</span></span>&#123;<span class="keyword">return</span> str_replace(<span class="string">'\\'</span>,<span class="string">'/'</span>,$path);&#125;</div><div class="line"><span class="comment">//法1：传统遍历目录</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFiles1</span><span class="params">($dir)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(!is_dir($dir))&#123;</div><div class="line">                <span class="keyword">exit</span>(<span class="string">'不是dir'</span>);</div><div class="line">        &#125;</div><div class="line">        $handle = opendir($dir);</div><div class="line">        <span class="keyword">if</span>($handle)&#123;</div><div class="line">                <span class="keyword">while</span>(<span class="keyword">false</span> !== ($file = readdir($handle)))&#123;</div><div class="line">                        <span class="keyword">if</span>($file != <span class="string">'.'</span> &amp;&amp; $file != <span class="string">'..'</span>)&#123;</div><div class="line">                                $filename = $dir.<span class="string">"/"</span>.$file;</div><div class="line">                                <span class="keyword">if</span>(is_file($filename))&#123;</div><div class="line">                                        <span class="keyword">echo</span> <span class="string">'File path = '</span>.$filename.<span class="string">"\n"</span>;</div><div class="line">                                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                                        getFiles1($filename);</div><div class="line">                                &#125;</div><div class="line">                        &#125;</div><div class="line">                &#125;</div><div class="line">                closedir($handle);</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//法2：迭代器遍历目录,并将这个树形结构的迭代器展开为一维结构</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFiles2</span><span class="params">($dir)</span></span>&#123;</div><div class="line">        $directory = <span class="keyword">new</span> RecursiveDirectoryIterator($dir,RecursiveDirectoryIterator::SKIP_DOTS);</div><div class="line">        $ierator = <span class="keyword">new</span> RecursiveIteratorIterator($directory,RecursiveIteratorIterator::LEAVES_ONLY);</div><div class="line">        <span class="keyword">foreach</span>($ierator <span class="keyword">as</span> $fileinfo)&#123;</div><div class="line">                <span class="keyword">echo</span> <span class="string">'File path = '</span> .$fileinfo-&gt;getPathname(). <span class="string">"\n"</span>;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//法3：迭代器+递归函数遍历目录，$dir为RecursiveDirectoryIterator迭代器对象</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFiles3</span><span class="params">($dir)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(;$dir-&gt;valid();$dir-&gt;next())&#123;</div><div class="line">                <span class="keyword">if</span>($dir-&gt;isDir() &amp;&amp; !$dir-&gt;isDot()) &#123;</div><div class="line">                        <span class="keyword">if</span>($dir-&gt;haschildren()) &#123;</div><div class="line">                                getFiles3($dir-&gt;getChildren());</div><div class="line">                        &#125;</div><div class="line">                &#125;<span class="keyword">elseif</span>($dir-&gt;isFile())&#123;</div><div class="line">                        <span class="keyword">echo</span> <span class="string">'File path = '</span>.$dir-&gt;getPathName().<span class="string">"\n"</span>;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>法1：测试打印了几次，耗时分别在0.048,0.062,0.078<br>法2：测试打印了几次，耗时分别在0.092，0.103，0.151，0.065<br>法3：测试打印了几次，耗时分别在0.037，0.044，0.039,0.045</p><p>法2：主要是使用了迭代器RecursiveIteratorIterator,作用是把多维的树形数组转成一维，耗时较多</p><p>法1相对法3，传统的不断打开文件句柄也会耗时些</p><p>所以建议还是使用法3，关于SPL（PHP标准类库）的了解文章：<a href="http://www.ruanyifeng.com/blog/2008/07/php_spl_notes.html" title="文章地址" target="_blank" rel="external">文章地址</a></p><p>在编码中我们可以多使用SPL标准类库提供给我们的类，告别一些传统的方法，使用一些新的解决方法和思维。</p><hr><p>现在已经能够遍历出某个目录下面的所有文件了。如果还想追求速度，可以使用多进程pcntl相关函数来完成。<br>我其中使用了LimitIterator这个迭代器来控制每个进程的处理的遍历出来文件的偏移，这样子来加快任务处理速度，进程的数量我是通过命令find weixin -type f -print | wc -l查看目录下面的文件个数计算的来设置每个进程处理文件个数偏移的。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//$need_import_dir需要导入文件的目录</span></div><div class="line">$directory = <span class="keyword">new</span> RecursiveDirectoryIterator($need_import_dir,RecursiveDirectoryIterator::SKIP_DOTS);</div><div class="line">$ierator = <span class="keyword">new</span> RecursiveIteratorIterator($directory,RecursiveIteratorIterator::LEAVES_ONLY);</div><div class="line"><span class="comment">//PHP多进程</span></div><div class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; <span class="number">2</span>; $i++) &#123;</div><div class="line">    $pid = pcntl_fork();</div><div class="line">    <span class="keyword">if</span> ($pid == <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"Could not fork!\n"</span>;</div><div class="line">        <span class="keyword">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!$pid) &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"child process $i running\n"</span>;</div><div class="line">        $offset = $i*<span class="number">1800</span>;</div><div class="line">        $limit_iterator = <span class="keyword">new</span> LimitIterator($ierator,$offset,<span class="number">1800</span>);</div><div class="line">        <span class="keyword">foreach</span>($limit_iterator <span class="keyword">as</span> $file=&gt;$fileinfo)&#123;</div><div class="line">              <span class="comment">//传文件路径，记录到数据库</span></div><div class="line">              recordFile($fileinfo-&gt;getPathname());</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//子进程执行完毕之后就退出，以免继续fork出新的子进程</span></div><div class="line">        <span class="keyword">exit</span>($i);</div><div class="line">    &#125;</div><div class="line">    usleep(<span class="number">1</span>);<span class="comment">//歇一微秒避免并发记录</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//等待子进程执行完毕，避免出现僵尸进程</span></div><div class="line"><span class="keyword">while</span> (pcntl_waitpid(<span class="number">0</span>, $status) != <span class="number">-1</span>) &#123;</div><div class="line">    $status = pcntl_wexitstatus($status);</div><div class="line">    <span class="keyword">echo</span> <span class="string">"Child $status completed\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样子处理速度直接快接近一半了。<br>也可以不用上面的方法，可以使用法3把所有文件路径跑出来存到一个数组里面，再创建多个进程通过数组偏移来处理。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">$directory = <span class="keyword">new</span> RecursiveDirectoryIterator($need_import_dir,RecursiveDirectoryIterator::SKIP_DOTS);</div><div class="line"><span class="comment">//把法3改成返回一个数组里面存着所有的文件</span></div><div class="line">$total_files = getFiles3($directory);</div><div class="line">$chunk_size = <span class="number">1800</span>;<span class="comment">//分割下，每个数组大小可以具体设置。</span></div><div class="line">$chunk_list = array_chunk($total_files,$chunk_size);</div><div class="line"><span class="comment">//PHP多进程</span></div><div class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; count($chunk_list); $i++) &#123;</div><div class="line">    $pid = pcntl_fork();</div><div class="line">    <span class="keyword">if</span> ($pid == <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"Could not fork!\n"</span>;</div><div class="line">        <span class="keyword">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!$pid) &#123;</div><div class="line">        <span class="keyword">foreach</span>($chunk_list[$i] <span class="keyword">as</span> $value)&#123;</div><div class="line">                recordFile($value);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//子进程执行完毕之后就退出，以免继续fork出新的子进程</span></div><div class="line">        <span class="keyword">exit</span>($i);</div><div class="line">    &#125;</div><div class="line">    usleep(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//等待子进程执行完毕，避免出现僵尸进程</span></div><div class="line"><span class="keyword">while</span> (pcntl_waitpid(<span class="number">0</span>, $status) != <span class="number">-1</span>) &#123;</div><div class="line">    $status = pcntl_wexitstatus($status);</div><div class="line">    <span class="keyword">echo</span> <span class="string">"Child $status completed\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>经过测试还是第一种通过LimitIterator迭代器偏移开启两个进程更快一些。<br><img src="/static/upload/e69ed799-9782-41a5-a67e-0f9d8df5274e.png" alt=""></p><p><em>——————2016-10-10</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近工作需要写一个脚本去跑某个目录下面的文件然后记录到数据库，比较了下三种遍历目录的方法.&lt;/p&gt;
&lt;p&gt;打印了测试目录weixin下面有多少文件,文件一共3千多，层级深度还是比较深的。&lt;br /&gt;
&lt;img src=&quot;/static/upload/55262d40-30af-4485-95a3-ec46dc31b012.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://renqiangme.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://renqiangme.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>修改mongodb3.x版本的auth认证方式为2.x版本的认证方式</title>
    <link href="https://renqiangme.github.io/2016/10/01/mongodb3.x%E7%89%88%E6%9C%AC%E7%9A%84auth%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F%E4%B8%BA2.x%E7%89%88%E6%9C%AC%E7%9A%84%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F/"/>
    <id>https://renqiangme.github.io/2016/10/01/mongodb3.x版本的auth认证方式为2.x版本的认证方式/</id>
    <published>2016-10-01T05:02:30.000Z</published>
    <updated>2018-11-08T03:05:26.870Z</updated>
    
    <content type="html"><![CDATA[<p>最近在用openresty的做一些任务，其中在使用mongo的Lua库的时候，因为mongodb开启了auth，需要账号密码才能连接。</p><p>mongodb 2.xx的认证方式，使用的是md5加密,认证耗时更短，如果使用3.xx认证处耗时很严重在lua中。</p><a id="more"></a><p>怎么改呢？</p><p>mongo改验证方式：<br>1、停mongodb,<br>2、以不验证模式启动<br>3、删除原有用户名密码<br>4、<br>use admin;<br>db.system.version.insert({“_id”:”authSchema”,”currentVersion”:3})<br>5、新增用户名密码！<br>6、停mongodb<br>7、以验证方式启动mongdb</p><p>如果insert不行就update</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在用openresty的做一些任务，其中在使用mongo的Lua库的时候，因为mongodb开启了auth，需要账号密码才能连接。&lt;/p&gt;
&lt;p&gt;mongodb 2.xx的认证方式，使用的是md5加密,认证耗时更短，如果使用3.xx认证处耗时很严重在lua中。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://renqiangme.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://renqiangme.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>内部微信授权code解决多个域名的脚本</title>
    <link href="https://renqiangme.github.io/2016/03/25/%E5%86%85%E9%83%A8%E5%BE%AE%E4%BF%A1%E6%8E%88%E6%9D%83code%E8%A7%A3%E5%86%B3%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <id>https://renqiangme.github.io/2016/03/25/内部微信授权code解决多个域名的脚本/</id>
    <published>2016-03-25T15:42:04.000Z</published>
    <updated>2018-11-08T03:05:39.816Z</updated>
    
    <content type="html"><![CDATA[<h5 id="内部调用微信授权脚本-解决一个域名想授权多个域名获取微信授权code"><a class="markdownIt-Anchor" href="#内部调用微信授权脚本-解决一个域名想授权多个域名获取微信授权code"></a> 内部调用微信授权脚本－解决一个域名想授权多个域名获取微信授权code</h5><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$access_key = &apos;123qwe&apos;;</div><div class="line">$innder_key = $_GET[&apos;inner_key&apos;];</div><div class="line">//内部调用</div><div class="line">if (isset($inner_key) &amp;&amp; !empty($inner_key)) &#123;</div><div class="line">    if ($inner_key != sha1($access_key)) &#123;</div><div class="line">        exit(&apos;access error!&apos;);</div><div class="line">    &#125;</div><div class="line">    $current_url = &apos;http://www.xxx.com/code.php&apos;;</div><div class="line">    $redirect_uri = $current_url.&apos;?url=&apos;.urlencode($_GET[&apos;redirect_url&apos;]);</div><div class="line">    $oauth_url = getOauthRedirect($redirect_uri);</div><div class="line">    header(&apos;Location:&apos;.$oauth_url);</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line">//微信授权回调</div><div class="line">if(isset($_GET[&apos;code&apos;]))&#123;</div><div class="line">    $url = urldecode($_GET[&apos;url&apos;]);</div><div class="line">    $new_url = $url.&apos;&amp;code=&apos;.$_GET[&apos;code&apos;];</div><div class="line">    header(&apos;Location:&apos;.$new_url);</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * oauth 授权跳转接口</div><div class="line"> * @param string $callback 回调URI</div><div class="line"> * @return string 返回 用户同意授权，获取code的URL 外部调用直接header重定向这个链接</div><div class="line"> */</div><div class="line">function getOauthRedirect($callback, $state = &apos;&apos;, $scope = &apos;snsapi_base&apos;) &#123;</div><div class="line">    $appid = &apos;xxxx&apos;;//微信公众号服务号的appid</div><div class="line">    return &apos;https://open.weixin.qq.com/connect/oauth2/authorize?appid=&apos; . $appid . &apos;&amp;redirect_uri=&apos; . urlencode($callback) . &apos;&amp;response_type=code&amp;scope=&apos; . $scope . &apos;&amp;state=&apos; . $state . &apos;#wechat_redirect&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;内部调用微信授权脚本-解决一个域名想授权多个域名获取微信授权code&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#内部调用微信授权脚本-解决一个域名想授权多个域名获取微信授权code&quot;&gt;&lt;/a&gt; 内部调用微信授权脚本－解决一个域名想授权多个域名获取微信授权code&lt;/h5&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://renqiangme.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://renqiangme.github.io/tags/PHP/"/>
    
      <category term="微信公众号" scheme="https://renqiangme.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
  </entry>
  
</feed>
