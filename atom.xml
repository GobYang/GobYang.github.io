<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GobYang</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-12-24T16:02:56.053Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>GobYang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP遍历某个目录下面的文件并使用多进程记录到数据库的几种方法比较</title>
    <link href="http://yoursite.com/2016/10/10/PHP%E9%81%8D%E5%8E%86%E6%9F%90%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%96%87%E4%BB%B6%E5%B9%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%AE%B0%E5%BD%95%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/"/>
    <id>http://yoursite.com/2016/10/10/PHP遍历某个目录下面的文件并使用多进程记录到数据库的几种方法比较/</id>
    <published>2016-10-10T08:00:30.000Z</published>
    <updated>2016-12-24T16:02:56.053Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作需要写一个脚本去跑某个目录下面的文件然后记录到数据库，比较了下三种遍历目录的方法.</p>
<p>打印了测试目录weixin下面有多少文件,文件一共3千多，层级深度还是比较深的。<br><img src="/static/upload/55262d40-30af-4485-95a3-ec46dc31b012.png" alt=""><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * php import.php xxx目录 比如：php import.php images</div><div class="line"> * 此目录是跟脚本同级顶级的目录</div><div class="line"> */</div><div class="line">$t1 = microtime(<span class="keyword">true</span>);</div><div class="line">define(<span class="string">'BASIC_PATH'</span>,P(dirname(<span class="keyword">__FILE__</span>)).<span class="string">'/'</span>);</div><div class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($argv))&#123;</div><div class="line">    <span class="keyword">exit</span>(<span class="string">"请在命令行执行此脚本\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(count($argv) &lt;= <span class="number">1</span> || <span class="keyword">empty</span>($argv[<span class="number">1</span>]))&#123;</div><div class="line">   <span class="keyword">exit</span>(<span class="string">"请输入需要导入的文件夹,比如php import.php images\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//默认只取第一个参数，暂不多个文件夹处理</span></div><div class="line">$need_import_dir = BASIC_PATH.$argv[<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="comment">//调用法1</span></div><div class="line">getFiles1($need_import_dir);</div><div class="line"><span class="comment">//调用法2</span></div><div class="line">getFiles2($need_import_dir);</div><div class="line"><span class="comment">//调用法3</span></div><div class="line">$directory = <span class="keyword">new</span> RecursiveDirectoryIterator($need_import_dir);</div><div class="line">getFiles3($directory);</div><div class="line"></div><div class="line">$t2 = microtime(<span class="keyword">true</span>);</div><div class="line"><span class="keyword">echo</span> <span class="string">'耗时'</span>.round($t2-$t1,<span class="number">3</span>).<span class="string">"秒\n"</span>;</div><div class="line"><span class="comment">//自定义函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span><span class="params">($path)</span></span>&#123;<span class="keyword">return</span> str_replace(<span class="string">'\\'</span>,<span class="string">'/'</span>,$path);&#125;</div><div class="line"><span class="comment">//法1：传统遍历目录</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFiles1</span><span class="params">($dir)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(!is_dir($dir))&#123;</div><div class="line">                <span class="keyword">exit</span>(<span class="string">'不是dir'</span>);</div><div class="line">        &#125;</div><div class="line">        $handle = opendir($dir);</div><div class="line">        <span class="keyword">if</span>($handle)&#123;</div><div class="line">                <span class="keyword">while</span>(<span class="keyword">false</span> !== ($file = readdir($handle)))&#123;</div><div class="line">                        <span class="keyword">if</span>($file != <span class="string">'.'</span> &amp;&amp; $file != <span class="string">'..'</span>)&#123;</div><div class="line">                                $filename = $dir.<span class="string">"/"</span>.$file;</div><div class="line">                                <span class="keyword">if</span>(is_file($filename))&#123;</div><div class="line">                                        <span class="keyword">echo</span> <span class="string">'File path = '</span>.$filename.<span class="string">"\n"</span>;</div><div class="line">                                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                                        getFiles1($filename);</div><div class="line">                                &#125;</div><div class="line">                        &#125;</div><div class="line">                &#125;</div><div class="line">                closedir($handle);</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//法2：迭代器遍历目录,并将这个树形结构的迭代器展开为一维结构</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFiles2</span><span class="params">($dir)</span></span>&#123;</div><div class="line">        $directory = <span class="keyword">new</span> RecursiveDirectoryIterator($dir,RecursiveDirectoryIterator::SKIP_DOTS);</div><div class="line">        $ierator = <span class="keyword">new</span> RecursiveIteratorIterator($directory,RecursiveIteratorIterator::LEAVES_ONLY);</div><div class="line">        <span class="keyword">foreach</span>($ierator <span class="keyword">as</span> $fileinfo)&#123;</div><div class="line">                <span class="keyword">echo</span> <span class="string">'File path = '</span> .$fileinfo-&gt;getPathname(). <span class="string">"\n"</span>;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//法3：迭代器+递归函数遍历目录，$dir为RecursiveDirectoryIterator迭代器对象</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFiles3</span><span class="params">($dir)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(;$dir-&gt;valid();$dir-&gt;next())&#123;</div><div class="line">                <span class="keyword">if</span>($dir-&gt;isDir() &amp;&amp; !$dir-&gt;isDot()) &#123;</div><div class="line">                        <span class="keyword">if</span>($dir-&gt;haschildren()) &#123;</div><div class="line">                                getFiles3($dir-&gt;getChildren());</div><div class="line">                        &#125;</div><div class="line">                &#125;<span class="keyword">elseif</span>($dir-&gt;isFile())&#123;</div><div class="line">                        <span class="keyword">echo</span> <span class="string">'File path = '</span>.$dir-&gt;getPathName().<span class="string">"\n"</span>;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>法1：测试打印了几次，耗时分别在0.048,0.062,0.078<br>法2：测试打印了几次，耗时分别在0.092，0.103，0.151，0.065<br>法3：测试打印了几次，耗时分别在0.037，0.044，0.039,0.045</p>
<p>法2：主要是使用了迭代器RecursiveIteratorIterator,作用是把多维的树形数组转成一维，耗时较多</p>
<p>法1相对法3，传统的不断打开文件句柄也会耗时些</p>
<p>所以建议还是使用法3，关于SPL（PHP标准类库）的了解文章：<a href="http://www.ruanyifeng.com/blog/2008/07/php_spl_notes.html" title="文章地址" target="_blank" rel="external">文章地址</a></p>
<p>在编码中我们可以多使用SPL标准类库提供给我们的类，告别一些传统的方法，使用一些新的解决方法和思维。</p>
<hr>
<p>现在已经能够遍历出某个目录下面的所有文件了。如果还想追求速度，可以使用多进程pcntl相关函数来完成。<br>我其中使用了LimitIterator这个迭代器来控制每个进程的处理的遍历出来文件的偏移，这样子来加快任务处理速度，进程的数量我是通过命令find weixin -type f -print | wc -l查看目录下面的文件个数计算的来设置每个进程处理文件个数偏移的。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//$need_import_dir需要导入文件的目录</span></div><div class="line">$directory = <span class="keyword">new</span> RecursiveDirectoryIterator($need_import_dir,RecursiveDirectoryIterator::SKIP_DOTS);</div><div class="line">$ierator = <span class="keyword">new</span> RecursiveIteratorIterator($directory,RecursiveIteratorIterator::LEAVES_ONLY);</div><div class="line"><span class="comment">//PHP多进程</span></div><div class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; <span class="number">2</span>; $i++) &#123;</div><div class="line">    $pid = pcntl_fork();</div><div class="line">    <span class="keyword">if</span> ($pid == <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"Could not fork!\n"</span>;</div><div class="line">        <span class="keyword">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!$pid) &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"child process $i running\n"</span>;</div><div class="line">        $offset = $i*<span class="number">1800</span>;</div><div class="line">        $limit_iterator = <span class="keyword">new</span> LimitIterator($ierator,$offset,<span class="number">1800</span>);</div><div class="line">        <span class="keyword">foreach</span>($limit_iterator <span class="keyword">as</span> $file=&gt;$fileinfo)&#123;</div><div class="line">              <span class="comment">//传文件路径，记录到数据库</span></div><div class="line">              recordFile($fileinfo-&gt;getPathname());</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//子进程执行完毕之后就退出，以免继续fork出新的子进程</span></div><div class="line">        <span class="keyword">exit</span>($i);</div><div class="line">    &#125;</div><div class="line">    usleep(<span class="number">1</span>);<span class="comment">//歇一微秒避免并发记录</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//等待子进程执行完毕，避免出现僵尸进程</span></div><div class="line"><span class="keyword">while</span> (pcntl_waitpid(<span class="number">0</span>, $status) != <span class="number">-1</span>) &#123;</div><div class="line">    $status = pcntl_wexitstatus($status);</div><div class="line">    <span class="keyword">echo</span> <span class="string">"Child $status completed\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样子处理速度直接快接近一半了。<br>也可以不用上面的方法，可以使用法3把所有文件路径跑出来存到一个数组里面，再创建多个进程通过数组偏移来处理。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">$directory = <span class="keyword">new</span> RecursiveDirectoryIterator($need_import_dir,RecursiveDirectoryIterator::SKIP_DOTS);</div><div class="line"><span class="comment">//把法3改成返回一个数组里面存着所有的文件</span></div><div class="line">$total_files = getFiles3($directory);</div><div class="line">$chunk_size = <span class="number">1800</span>;<span class="comment">//分割下，每个数组大小可以具体设置。</span></div><div class="line">$chunk_list = array_chunk($total_files,$chunk_size);</div><div class="line"><span class="comment">//PHP多进程</span></div><div class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; count($chunk_list); $i++) &#123;</div><div class="line">    $pid = pcntl_fork();</div><div class="line">    <span class="keyword">if</span> ($pid == <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"Could not fork!\n"</span>;</div><div class="line">        <span class="keyword">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!$pid) &#123;</div><div class="line">        <span class="keyword">foreach</span>($chunk_list[$i] <span class="keyword">as</span> $value)&#123;</div><div class="line">                recordFile($value);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//子进程执行完毕之后就退出，以免继续fork出新的子进程</span></div><div class="line">        <span class="keyword">exit</span>($i);</div><div class="line">    &#125;</div><div class="line">    usleep(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//等待子进程执行完毕，避免出现僵尸进程</span></div><div class="line"><span class="keyword">while</span> (pcntl_waitpid(<span class="number">0</span>, $status) != <span class="number">-1</span>) &#123;</div><div class="line">    $status = pcntl_wexitstatus($status);</div><div class="line">    <span class="keyword">echo</span> <span class="string">"Child $status completed\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>经过测试还是第一种通过LimitIterator迭代器偏移开启两个进程更快一些。<br><img src="/static/upload/e69ed799-9782-41a5-a67e-0f9d8df5274e.png" alt=""></p>
<p><em>——————2016-10-10</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近工作需要写一个脚本去跑某个目录下面的文件然后记录到数据库，比较了下三种遍历目录的方法.&lt;/p&gt;
&lt;p&gt;打印了测试目录weixin下面有多少文件,文件一共3千多，层级深度还是比较深的。&lt;br&gt;&lt;img src=&quot;/static/upload/55262d40-30af-4
    
    </summary>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>修改mongodb3.x版本的auth认证方式为2.x版本的认证方式</title>
    <link href="http://yoursite.com/2016/10/01/mongodb3.x%E7%89%88%E6%9C%AC%E7%9A%84auth%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F%E4%B8%BA2.x%E7%89%88%E6%9C%AC%E7%9A%84%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/10/01/mongodb3.x版本的auth认证方式为2.x版本的认证方式/</id>
    <published>2016-10-01T05:02:30.000Z</published>
    <updated>2016-12-24T15:57:35.457Z</updated>
    
    <content type="html"><![CDATA[<p>最近在用openresty的做一些任务，其中在使用mongo的Lua库的时候，因为mongodb开启了auth，需要账号密码才能连接。</p>
<p>mongodb 2.xx的认证方式，使用的是md5加密,认证耗时更短，如果使用3.xx认证处耗时很严重在lua中。</p>
<p>怎么改呢？</p>
<p>mongo改验证方式：<br>1、停mongodb,<br>2、以不验证模式启动<br>3、删除原有用户名密码<br>4、<br>use admin;<br>db.system.version.insert({“_id”:”authSchema”,”currentVersion”:3})<br>5、新增用户名密码！<br>6、停mongodb<br>7、以验证方式启动mongdb</p>
<p>如果insert不行就update</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在用openresty的做一些任务，其中在使用mongo的Lua库的时候，因为mongodb开启了auth，需要账号密码才能连接。&lt;/p&gt;
&lt;p&gt;mongodb 2.xx的认证方式，使用的是md5加密,认证耗时更短，如果使用3.xx认证处耗时很严重在lua中。&lt;/p&gt;

    
    </summary>
    
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>内部微信授权code解决多个域名的脚本</title>
    <link href="http://yoursite.com/2016/03/25/%E5%86%85%E9%83%A8%E5%BE%AE%E4%BF%A1%E6%8E%88%E6%9D%83code%E8%A7%A3%E5%86%B3%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2016/03/25/内部微信授权code解决多个域名的脚本/</id>
    <published>2016-03-25T15:42:04.000Z</published>
    <updated>2016-12-24T15:46:02.105Z</updated>
    
    <content type="html"><![CDATA[<h5 id="内部调用微信授权脚本－解决一个域名想授权多个域名获取微信授权code"><a href="#内部调用微信授权脚本－解决一个域名想授权多个域名获取微信授权code" class="headerlink" title="内部调用微信授权脚本－解决一个域名想授权多个域名获取微信授权code"></a>内部调用微信授权脚本－解决一个域名想授权多个域名获取微信授权code</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$access_key = &apos;123qwe&apos;;</div><div class="line">$innder_key = $_GET[&apos;inner_key&apos;];</div><div class="line">//内部调用</div><div class="line">if (isset($inner_key) &amp;&amp; !empty($inner_key)) &#123;</div><div class="line">    if ($inner_key != sha1($access_key)) &#123;</div><div class="line">        exit(&apos;access error!&apos;);</div><div class="line">    &#125;</div><div class="line">    $current_url = &apos;http://www.xxx.com/code.php&apos;;</div><div class="line">    $redirect_uri = $current_url.&apos;?url=&apos;.urlencode($_GET[&apos;redirect_url&apos;]);</div><div class="line">    $oauth_url = getOauthRedirect($redirect_uri);</div><div class="line">    header(&apos;Location:&apos;.$oauth_url);</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line">//微信授权回调</div><div class="line">if(isset($_GET[&apos;code&apos;]))&#123;</div><div class="line">    $url = urldecode($_GET[&apos;url&apos;]);</div><div class="line">    $new_url = $url.&apos;&amp;code=&apos;.$_GET[&apos;code&apos;];</div><div class="line">    header(&apos;Location:&apos;.$new_url);</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * oauth 授权跳转接口</div><div class="line"> * @param string $callback 回调URI</div><div class="line"> * @return string 返回 用户同意授权，获取code的URL 外部调用直接header重定向这个链接</div><div class="line"> */</div><div class="line">function getOauthRedirect($callback, $state = &apos;&apos;, $scope = &apos;snsapi_base&apos;) &#123;</div><div class="line">    $appid = &apos;xxxx&apos;;//微信公众号服务号的appid</div><div class="line">    return &apos;https://open.weixin.qq.com/connect/oauth2/authorize?appid=&apos; . $appid . &apos;&amp;redirect_uri=&apos; . urlencode($callback) . &apos;&amp;response_type=code&amp;scope=&apos; . $scope . &apos;&amp;state=&apos; . $state . &apos;#wechat_redirect&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;内部调用微信授权脚本－解决一个域名想授权多个域名获取微信授权code&quot;&gt;&lt;a href=&quot;#内部调用微信授权脚本－解决一个域名想授权多个域名获取微信授权code&quot; class=&quot;headerlink&quot; title=&quot;内部调用微信授权脚本－解决一个域名想授权多个域名
    
    </summary>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="微信公众号" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>Github的SSH和HTTPS记住账号密码方法</title>
    <link href="http://yoursite.com/2015/12/24/Github%E7%9A%84SSH%E5%92%8CHTTPS%E8%AE%B0%E4%BD%8F%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2015/12/24/Github的SSH和HTTPS记住账号密码方法/</id>
    <published>2015-12-24T07:58:08.000Z</published>
    <updated>2016-12-24T08:43:17.484Z</updated>
    
    <content type="html"><![CDATA[<p>其实关于这两种认证方式也是适用于Gitlab等相关git.<br>很多时候，我们在打算克隆一个仓库到本地的时候，有两种方式可以选择，即：SSH和HTTPS.<br>克隆还好，但是需要推送的时候，也许会遇到权限，需要账号密码啊。</p>
<p><strong>通过HTTPS方式克隆的代码到本地</strong><br>如果遇到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error: The requested URL returned error: 403 Forbidden while accessing</div></pre></td></tr></table></figure></p>
<p>这是权限问题，可以修改.git/config文件追加用户名和密码，也可以直接敲下面命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote set-url origin https://youruser:password@github.com/user/repo.git</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p><strong>其实更常用的是SSH的方式来推送代码：</strong></p>
<p><strong>首先需要生成 SSH Keys，需要用到 ssh-keygen 命令。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;xxx@qq.com&quot; -f ~/.ssh/git-github</div></pre></td></tr></table></figure></p>
<p>简单介绍下参数含义：</p>
<p>-t 指定密钥类型，默认即 rsa ，可以省略<br>-C 设置注释文字，比如你的邮箱<br>-f 指定密钥文件存储文件名，会生成 git-github 和 git-github.pub 两个密钥文件</p>
<p>回车后，遇到提示输入 yes 即可，剩下一路回车，密钥文件就在指定路径下生成了。</p>
<p><strong>接下来就去git管理界面的设置里面将 SSH 公钥添加到 Github</strong><br>设置里面把git-github.pub公钥的内容复制进去添加就行了。</p>
<p><strong>本地添加SSH别名</strong><br>如果本机有其它密钥，连接 github 时可能不会自动使用刚生成的密钥，需要设置别名：</p>
<p>$ sudo vi ~/.ssh/config<br>加入类似的一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">host git-github</div><div class="line">	user git</div><div class="line">	hostname github.com</div><div class="line">	port 22</div><div class="line">	identityfile ~/.ssh/git-github</div></pre></td></tr></table></figure>
<p>保存退出。</p>
<p><strong>测试连接</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -T git-github</div></pre></td></tr></table></figure></p>
<p>Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
<p>表示设置的 SSH Keys 认证通过，但 Github 不提供 shell 访问。<br>此时就可以正常使用 Github 了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实关于这两种认证方式也是适用于Gitlab等相关git.&lt;br&gt;很多时候，我们在打算克隆一个仓库到本地的时候，有两种方式可以选择，即：SSH和HTTPS.&lt;br&gt;克隆还好，但是需要推送的时候，也许会遇到权限，需要账号密码啊。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过HTTPS方式克隆的代码到本地&lt;/strong&gt;&lt;br&gt;如果遇到：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;error: The requested URL returned error: 403 Forbidden while accessing&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这是权限问题，可以修改.git/config文件追加用户名和密码，也可以直接敲下面命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git remote set-url origin https://youruser:password@github.com/user/repo.git&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
      <category term="GitHub" scheme="http://yoursite.com/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>JS如何判断一个页面是否已经打开?</title>
    <link href="http://yoursite.com/2015/01/23/JS%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%98%AF%E5%90%A6%E5%B7%B2%E7%BB%8F%E6%89%93%E5%BC%80/"/>
    <id>http://yoursite.com/2015/01/23/JS如何判断一个页面是否已经打开/</id>
    <published>2015-01-23T07:18:28.000Z</published>
    <updated>2016-12-24T09:18:49.352Z</updated>
    
    <content type="html"><![CDATA[<p>一种是刷新之后又会重新打开页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;&lt;/title&gt;</div><div class="line">      &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        var objWin;</div><div class="line">        function openPage() &#123;</div><div class="line">            var target = &quot;http://www.baidu.com&quot;;</div><div class="line">              //判断是否打开</div><div class="line">            if (objWin == null || objWin.closed) &#123;</div><div class="line">                objWin = window.open(target);</div><div class="line">            &#125; else &#123;</div><div class="line">                objWin.location.replace(target);</div><div class="line">            &#125;</div><div class="line">            //objWin.focus();</div><div class="line">        &#125;     </div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt; </div><div class="line">    &lt;a href=&quot;javascript:openPage();&quot;&gt;打开页面&lt;/a&gt;</div><div class="line">  </div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>一种更完美一点的方案(刷新之后也不会再重新打开)：</p>
<p>index.html</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!doctype html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Document&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;input type=&quot;button&quot; value=&quot;open&quot; onclick=&quot;window.open(&apos;proxy.html&apos;,&apos;tag&apos;)&quot;&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>proxy.html</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;target页面&lt;/title&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">        if(window.parent.name!=&quot;msg&quot;)</div><div class="line">        &#123;</div><div class="line">            window.location.href=&quot;target.html&quot;;//这才是你的显示页面</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            window.parent.focus();</div><div class="line">        &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">proxy</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>target.html</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;&lt;/title&gt;</div><div class="line"></div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;h3&gt;target页面&lt;/h3&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    window.name=&quot;msg&quot;;</div><div class="line">&lt;/script&gt;</div><div class="line">message page</div><div class="line">&lt;iframe src=&quot;&quot; name=&quot;tag&quot; style=&quot;display:none&quot;&gt;&lt;/iframe&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一种是刷新之后又会重新打开页面：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;html&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;head&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        var objWin;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        function openPage() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            var target = &amp;quot;http://www.baidu.com&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;              //判断是否打开&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            if (objWin == null || objWin.closed) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                objWin = window.open(target);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125; else &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                objWin.location.replace(target);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            //objWin.focus();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;     &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/head&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;body&amp;gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;a href=&amp;quot;javascript:openPage();&amp;quot;&amp;gt;打开页面&amp;lt;/a&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/body&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/html&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>linux学习之用户管理</title>
    <link href="http://yoursite.com/2014/03/20/linux%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2014/03/20/linux学习之用户管理/</id>
    <published>2014-03-20T12:14:09.000Z</published>
    <updated>2016-12-24T15:24:18.471Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用户配置文件"><a href="#用户配置文件" class="headerlink" title="用户配置文件"></a>用户配置文件</h3><h5 id="用户管理简介"><a href="#用户管理简介" class="headerlink" title="用户管理简介"></a>用户管理简介</h5><p> .越是对服务器安全性要求高的服务器，越需要建立合理的用户权限等级制度和服务器操作规范</p>
<p> .在linux中主要是通过用户配置文件来查看和修改用户信息</p>
<a id="more"></a>
<h5 id="用户信息文件-etc-passwd"><a href="#用户信息文件-etc-passwd" class="headerlink" title="用户信息文件/etc/passwd"></a>用户信息文件/etc/passwd</h5><p>vim /etc/passwd<br>如果不知道这个文件是干什么的 可以执行 man 5 passwd 查看帮助<br>用户很多：如 root:x:0:0:root:/root:/bin/bash</p>
<p>第1个字段：用户名称</p>
<p>第2个字段：密码标志 （直接一个x 并没有直接列出密码 而是放在了/etc/shadow下面 原因/etc/passwd 各个用户都是可读的，就可能被暴力拆解 而/etc/shadow也是通过加密的 只有管理员有权限！）</p>
<p>第3个字段：UID（用户ID） 0:超级用户 1-499系统用户（伪用户）500-65535：普通用户</p>
<p>第4个字段：GID（用户初始组ID） 组：相同类型的集合</p>
<pre><code>初始组：linux用户一建立就默认属于一个组 跟window不一样 window每添加一个用户就会放入到user组里面。而linux你创建一个user1就会创建一个跟用户名相同名的user1用户组。每个用户必须要有一个初始组且只能有一个。建议：虽然初始组能够改，但并不建议改，原因：改了初始组把所建立的文件搞糊涂！

附加组：指用户可以加入多个其他的用户组，并拥有这些组的权限，附加组可以有多个。
</code></pre><p>第5个字段：用户说明</p>
<p>第6个字段：家目录<br>        普通用户：/home/用户名<br>        超级用户：/root/</p>
<p>第7个字段：登录之后的Shell<br>               Shell 就是Linux的命令解释器<br>        在/etc/passwd当中，除了标准Shell是/bin/bash之外，还可以写如/sbin/nologin</p>
<h5 id="影子文件-etc-shadow"><a href="#影子文件-etc-shadow" class="headerlink" title="影子文件/etc/shadow"></a>影子文件/etc/shadow</h5><p>实际就是 /etc/passwd的影子文件 只是权限更低 都是000000000<br>例如：<br>    root:$6$JmdhYiD4y7zwPiMu$kq9iu9C.0on1X1Ia14QZslgSWRy1pK8sQsVmCauGykqOFAyawpvFkaVM83nuqum4oJ92Y3sPPIXlpw5Fksp3m/:16326:0:99999:7:::<br>第一个字段：用户名<br>第二个字段：加密密码<br>         加密算法升级为SHA512散列加密算法<br>         如果密码位是“!!”或“*”代表没有密码，不能登录<br>第三个字段：密码最后一次修改日期<br>                使用1970年1月1日作为标准时间，每过一天时间戳加1<br>第四个字段：两次密码的修改间隔时间（和第3个字段相比）<br>第五个字段：密码有效期（和第3个字段相比）<br>第六个字段：密码修改到期前的警告天数（和第5字段相比）<br>第七个字段：密码过期后的宽限天数（和第五个字段相比）<br>         0:代表密码过期后立即失效<br>         1:代表密码永远不会失效<br>第八个字段：账号失效时间<br>         要用时间戳表示<br>         把时间戳换算为日期 date -d “1970-01-01 16066 days”<br>         把日期换算为时间戳 echo $((date –date=”2014/01/06” +%s)/86400+1)<br>第九个字段：保留</p>
<h5 id="组信息文件-etc-group和组密码文件-etc-gshadow"><a href="#组信息文件-etc-group和组密码文件-etc-gshadow" class="headerlink" title="组信息文件/etc/group和组密码文件/etc/gshadow"></a>组信息文件/etc/group和组密码文件/etc/gshadow</h5><pre><code>组信息文件/etc/group 例如：root:x:0:
第一个字段：组名 第二个字段：组密码标志 第三个字段：GID 第四个字段：组中附加用户
组密码文件/etc/gshadow
第一个字段：组名 第二个字段：组密码 第三个字段：组管理员用户名 第四个字段：组中附加用户
</code></pre><h3 id="用户管理相关文件"><a href="#用户管理相关文件" class="headerlink" title="用户管理相关文件"></a>用户管理相关文件</h3><h5 id="用户的家目录"><a href="#用户的家目录" class="headerlink" title="用户的家目录"></a>用户的家目录</h5><pre><code>普通用户：/home/用户名，所有者和所属组都是此用户，权限是700
超级用户：/root/ 所有者和所属组都是root用户，权限是550 

如果你想把普通用户变为超级用户 家目录并不会修改 只是权限变为了超级权限。
普通用户变为超级用户的方法：修改用户信息文件/etc/passwd 把uid变为0 这样我们再登录的时候就会发现输入命令前面如果是#就说明是超级用户 如果是$就是普通用户
</code></pre><h5 id="用户的邮箱"><a href="#用户的邮箱" class="headerlink" title="用户的邮箱"></a>用户的邮箱</h5><pre><code>/var/spool/mail/用户名
是不是和我们用的QQ邮箱一样呢？QQ邮箱之所以能够转发是靠QQ自带的服务器进行转发，linux虽然可以作为客户端收发邮件，但是也要依赖服务器去发送邮件。QQ邮箱有专门的服务器去发送邮件，在linux中用户之间可以传递邮件，利用linux的内存直接转发，每个用户都有邮箱，我们用的只是邮箱的客户端，并没有搭建服务器。
</code></pre><h5 id="用户模板目录"><a href="#用户模板目录" class="headerlink" title="用户模板目录"></a>用户模板目录</h5><pre><code>/etc/skel
在用户家目录执行 ls -a 会发现出现了一些隐藏文件，这是在用户创建的时候自动创建的。这些自动创建的文件是从/etc/skel自动拷贝过去的。如果我想让所有用户一添加就在家目录出现某个文件，比如你登陆的我的系统要遵守xx规则，几点关机，警告信息...等等。只需要在/etc/skel下面添加文件就行了！
</code></pre><h3 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h3><h5 id="用户添加命令-useradd"><a href="#用户添加命令-useradd" class="headerlink" title="用户添加命令   useradd"></a>用户添加命令   useradd</h5><p>  格式：useradd [选项] 用户名<br>  选项：<br> -u UID：  手工指定用户的UID号<br> -d 家目录：  手工指定用户的家目录<br>        -c 用户说明：  手工指定用户的说明<br> -g 组名：  手工指定用户的初始组<br>        -G 组名：  指定用户的附加组<br> -s shell:  手工指定用户的登录shell 。默认是/bin/bash<br>  设置用户默认值的文件 /etc/default/useradd   和 /etc/login.defs</p>
<h5 id="修改用户密码-passwd"><a href="#修改用户密码-passwd" class="headerlink" title="修改用户密码   passwd"></a>修改用户密码   passwd</h5><p>   passwd [选项] 用户名<br>   选项：<br> -S 查询用户密码的密码状态。仅root用户可用。</p>
<pre><code>eg: passwd -S qingwa
qingwa PS 2014-09-14 0 99999 7 -1 
#用户名密码设定时间2014-09-14 密码修改间隔时间（0）密码有效期（99999）
#警告时间（7） 密码不失效（-1）
</code></pre><p> 实际上就跟 /etc/shadow里面看到的一样</p>
<p> -l 暂时锁定用户。仅root用户可用。在密码前面加上!! 让其密码失效<br> -u 解锁用户。仅root用户可用。<br> –stdin 可以通过管道符输出的数据作为用户的密码<br> echo “123” | passwd –stdin qingwa<br> 管道符:直接将前面的输出作为后面的输入</p>
<h5 id="修改用户信息-usermod"><a href="#修改用户信息-usermod" class="headerlink" title="修改用户信息   usermod"></a>修改用户信息   usermod</h5><pre><code>usermod -c &quot;test user&quot; lamp #修改用户的说明
usermod -G root lamp #把lamp用户加入root组
usermod -L lamp #锁定用户
usermod -U lamp #解锁用户
</code></pre><h5 id="修改用户密码状态-chage"><a href="#修改用户密码状态-chage" class="headerlink" title="修改用户密码状态 chage"></a>修改用户密码状态 chage</h5><p> chage [选项] 用户名<br> 选项：<br> -l 列出用户的详细密码状态<br> -d 日期 修改密码最后一次更改日期（shadow第3字段）<br> -m 天数 两次密码修改间隔（shadow第4字段）<br> -M 天数 密码有效期（shadow第5字段）<br> -W 天数 密码过期前警告天数（shadow第6字段）<br> -I 天数 密码过后宽限天数（shadow第7字段）<br> -E 日期 账号失效时间（shadow第8字段）<br> 因为选项过多直接修改vim /etc/shadow文件就行了<br> 常用的一个：chage -d 0 qingwa #这个命令其实是把密码修改日期归0了 这样用户一登陆就要修改密码</p>
<h5 id="删除用户-userdel"><a href="#删除用户-userdel" class="headerlink" title="删除用户 userdel"></a>删除用户 userdel</h5><p> userdel [-r] 用户名<br> 选项：<br>      -r 删除用户的同时删除用户家目录<br> id 用户名 #查看用户的uid 组id </p>
<h5 id="用户切换命令-su"><a href="#用户切换命令-su" class="headerlink" title="用户切换命令 su"></a>用户切换命令 su</h5><pre><code>su [选项] 用户名
选项：
    - #选项只使用“-”代表连带用户的环境变量一起切换
    -c 命令  #仅执行一次命令，而不切换用户身份
eg: su - root #切换成root
su - root -c &quot;useradd qinwa&quot; 不切换成root，但是执行useradd命令添加qingw用户
</code></pre><h3 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h3><h5 id="添加用户组"><a href="#添加用户组" class="headerlink" title="添加用户组"></a>添加用户组</h5><pre><code>groupadd [选项] 组名
       选项：-g GID   #指定组ID
</code></pre><h5 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h5><pre><code>groupmod [选项] 组名
-g GID #修改组ID
-n 新组名 #修改组名  eg:groupmod -n testgrp group1 #把组名group1修改为testgrp
</code></pre><h5 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组"></a>删除用户组</h5><pre><code>groupdel 组名
</code></pre><h5 id="把用户添加入组或从组中删除"><a href="#把用户添加入组或从组中删除" class="headerlink" title="把用户添加入组或从组中删除"></a>把用户添加入组或从组中删除</h5><pre><code>gpasswd 选项  组名
选项：-a 用户名 #把用户加入组
      -d 用户名 #把用户从组中删除
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;用户配置文件&quot;&gt;&lt;a href=&quot;#用户配置文件&quot; class=&quot;headerlink&quot; title=&quot;用户配置文件&quot;&gt;&lt;/a&gt;用户配置文件&lt;/h3&gt;&lt;h5 id=&quot;用户管理简介&quot;&gt;&lt;a href=&quot;#用户管理简介&quot; class=&quot;headerlink&quot; title=&quot;用户管理简介&quot;&gt;&lt;/a&gt;用户管理简介&lt;/h5&gt;&lt;p&gt; .越是对服务器安全性要求高的服务器，越需要建立合理的用户权限等级制度和服务器操作规范&lt;/p&gt;
&lt;p&gt; .在linux中主要是通过用户配置文件来查看和修改用户信息&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>linux学习之权限管理</title>
    <link href="http://yoursite.com/2014/03/19/linux%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2014/03/19/linux学习之权限管理/</id>
    <published>2014-03-19T15:03:47.000Z</published>
    <updated>2016-12-24T15:10:27.370Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h3><h5 id="1：ACL权限简介和开启"><a href="#1：ACL权限简介和开启" class="headerlink" title="1：ACL权限简介和开启"></a>1：ACL权限简介和开启</h5><pre><code>A：不再考虑身份。用户或用户组直接拿过来给它改权限

B：查看分区ACL权限是否开启
  dumpe2fs -h /dev/sda3  #dump2fs命令是查询指定分区详细文件系统信息的命令
  选项：-h 仅显示超级块中信息，而不显示磁盘块组的详细信息

  (步骤1：df -h  #查看当前系统分区使用情况，容量，已用，可用，挂载点，找到用户所在分区。)
  (步骤2：dumpe2fs -h /dev/sda3)
C：临时开启分区ACL权限
  mount -o remount,acl /  #重新挂载根分区，并载入acl权限
D：永久开启分区ACL权限
  步骤1：vi /etc/fstab  #加入acl
   UUID=c2cq6f57-b15c-43ea-bca0-f239083d8bd2 / ext4 defaults,acl 1 1
 #defaults后面加了一个acl
  步骤2：mount -o remount / #重新挂载文件系统或重启动系统，使修改生效 
</code></pre><a id="more"></a> 
<h5 id="2：查看与设定ACL权限"><a href="#2：查看与设定ACL权限" class="headerlink" title="2：查看与设定ACL权限"></a>2：查看与设定ACL权限</h5><pre><code>  A：查看ACL命令 getfacl 文件名 #查看ACL权限

  B:设定ACL权限 setfacl 选项 文件名
  选项：-m   设定ACL权限                  
给用户设置ACL权限       setfacl -m u:qingwa:rx /project/
       给用户组设定ACL权限     setfacl -m g:xxgroup:rwx project/

        -x   删除指定的ACL权限 setfacl -x g:xxgroup /project/ #删除xxgroup在project下面的ACL权限
        -b   删除所有的ACL权限 setfacl -b /project/ #会删除在project下面所有用户用户组的ACL权限
        -d   设定默认的ACL权限
        -k   删除默认ACL权限
        -R   递归设定ACL权限
</code></pre><h5 id="3-最大有效权限与删除ACL权限"><a href="#3-最大有效权限与删除ACL权限" class="headerlink" title="3:最大有效权限与删除ACL权限"></a>3:最大有效权限与删除ACL权限</h5><p>最大有效权限mask<br>mask是用来指定最大有效权限的。如果我给用户赋予了ACL权限，是需要和mask的权限“相与”才能得到用户的真正权限。(相与—相当于逻辑的与 一个为假就都为假)</p>
<h5 id="4：默认ACL权限和递归ACL权限"><a href="#4：默认ACL权限和递归ACL权限" class="headerlink" title="4：默认ACL权限和递归ACL权限"></a>4：默认ACL权限和递归ACL权限</h5><p>递归是父目录在设定ACL权限时，所有的子文件和子目录也会拥有相同的ACL权限。<br>setfacl -m u:用户名:权限 -R 文件名</p>
<p>默认ACL权限<br>默认ACL权限的作用是如果给父目录设定了ACL权限，那么父目录中所有新建的子文件都会继承父目录的ACL权限<br>。<br>setfacl -m d:u用户名：权限 文件名</p>
<h3 id="文件特殊权限"><a href="#文件特殊权限" class="headerlink" title="文件特殊权限"></a>文件特殊权限</h3><h5 id="1-SetUID"><a href="#1-SetUID" class="headerlink" title="1:  SetUID"></a>1:  SetUID</h5><p><strong>SetUID的功能</strong></p>
<pre><code>.只有可以执行的二进制程序才能设定SUID权限
.命令执行者要对该程序拥有x（执行）权限
.命令执行者在执行该程序时获得该程序文件宿主的身份（在执行程序的过程中灵魂附体为文件的属主）
.SetUID权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效。

---设置SUID---
4代表SUID
-    chmod 4755 文件名
-    chmod u+s 文件名
---取消SUID---
-    chmod 755 文件名
-    chmod u-s 文件名
---危险的SetUID---
.关键目录应该严格控制写权限，比如“/”、“/usr”等。
.用户的密码设置要严格遵守密码三原则。
.对系统中默认应该是具有SetUID权限的文件作一列表，定时检查有没有这之外的文件被设置了SetUID权限。
</code></pre><h5 id="2-SetGID"><a href="#2-SetGID" class="headerlink" title="2:  SetGID"></a>2:  SetGID</h5><pre><code>SetGID针对文件的作用
.只有可执行的二进制程序才能设置SGID权限
.命令执行者要对该程序拥有x(执行)权限
.命令执行在执行程序的时候，组身份升级为该程序文件的属组
.SetGID权限同样只在该程序执行过程中有效，也就是说组身份改变只在程序执行过程中有效

SetGID针对目录的作用
.普通用户必须对此目录拥有r和x权限，才能进入此目录
.普通用户在此目录中的有效组会变成此目录的属组
.若普通用户对此目录拥有w权限时，新建的文件的默认属组是这个目录的属组

--设定SetGID--
2代表SGID
-chmod 2755 文件名
-chmod g+s 文件名
</code></pre><h5 id="3-Sticky-BIT"><a href="#3-Sticky-BIT" class="headerlink" title="3:  Sticky BIT"></a>3:  Sticky BIT</h5><p><strong>SBIT粘着位作用</strong><br>    .粘着位目前只对目录有效<br>    .普通用户对该目录拥有w和x权限，即普通用户可以在此目录拥有写入权限<br>    .如果没有粘着位，因为普通用户拥有w权限，所以可以删除此目录下所有文件，包括其他用户建立的文件。一旦赋予了粘着位，除了root可以删除所有文件，普通用户就算拥有w权限，也只能删除自己建立的文件，但是不能删除其他用户建立的文件。</p>
<pre><code>设置与取消粘着位
1代表SBIT
设置粘着位
.chmod 1755 目录名
.chmod o+t 目录名
取消粘着位
.chmod 777 目录名
.chmod o-t 目录名
</code></pre><h3 id="文件系统属性chattr权限"><a href="#文件系统属性chattr权限" class="headerlink" title="文件系统属性chattr权限"></a>文件系统属性chattr权限</h3><p>chattr[+-=][选项]文件或目录名</p>
<pre><code>+：增加权限
-：删除权限
=：等于某权限

选项：
    i:如果对文件设置i属性，那么不允许对文件进行删除，改名，也不能添加和修改数据；如果对目录设置i属性，那么只能修改目录下文件的数据，但不允许建立和删除文件。
    a:如果对文件设置a属性，那么只能在文件中增加数据，但是不能删除也不能修改数据；如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许删除。
</code></pre><p>2、查看文件系统属性：lsattr 选项 文件名</p>
<p>选项：-a 显示所有文件和目录   -d若目标是目录，仅列出目录本身的属性，而不是子文件的。</p>
<h3 id="系统命令sudo权限"><a href="#系统命令sudo权限" class="headerlink" title="系统命令sudo权限"></a>系统命令sudo权限</h3><p>1：<br>-root把本来只能超级用户执行的命令赋予普通用户执行<br>-sudo的操作对象是系统命令<br>2：sudo使用<br>visudo #需要超级管理员执行这个命令  实际修改的是/etc/sudoers文件 </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ACL权限&quot;&gt;&lt;a href=&quot;#ACL权限&quot; class=&quot;headerlink&quot; title=&quot;ACL权限&quot;&gt;&lt;/a&gt;ACL权限&lt;/h3&gt;&lt;h5 id=&quot;1：ACL权限简介和开启&quot;&gt;&lt;a href=&quot;#1：ACL权限简介和开启&quot; class=&quot;headerlink&quot; title=&quot;1：ACL权限简介和开启&quot;&gt;&lt;/a&gt;1：ACL权限简介和开启&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;A：不再考虑身份。用户或用户组直接拿过来给它改权限

B：查看分区ACL权限是否开启
  dumpe2fs -h /dev/sda3  #dump2fs命令是查询指定分区详细文件系统信息的命令
  选项：-h 仅显示超级块中信息，而不显示磁盘块组的详细信息

  (步骤1：df -h  #查看当前系统分区使用情况，容量，已用，可用，挂载点，找到用户所在分区。)
  (步骤2：dumpe2fs -h /dev/sda3)
C：临时开启分区ACL权限
  mount -o remount,acl /  #重新挂载根分区，并载入acl权限
D：永久开启分区ACL权限
  步骤1：vi /etc/fstab  #加入acl
   UUID=c2cq6f57-b15c-43ea-bca0-f239083d8bd2 / ext4 defaults,acl 1 1
 #defaults后面加了一个acl
  步骤2：mount -o remount / #重新挂载文件系统或重启动系统，使修改生效 
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>linux学习笔记之常用命令之目录处理命令</title>
    <link href="http://yoursite.com/2014/03/18/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B9%8B%E7%9B%AE%E5%BD%95%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2014/03/18/linux学习笔记之常用命令之目录处理命令/</id>
    <published>2014-03-18T10:35:29.000Z</published>
    <updated>2016-12-24T14:25:27.253Z</updated>
    
    <content type="html"><![CDATA[<p><strong>————————常用命令—————</strong></p>
<pre><code>1文件处理命令
 1.1命令格式与目录处理命令
 1.2目录处理命令
 1.3文件处理命令
 1.4链接命令
2权限管理命令
3文件搜索命令
4帮助命令
5用户管理命令
6压缩解压命令
7网络命令
8关机重启命令
</code></pre><a id="more"></a>
<h3 id="1、文件处理命令"><a href="#1、文件处理命令" class="headerlink" title="1、文件处理命令"></a>1、文件处理命令</h3><p>1.1 命令格式：命令 [-选项][参数]   方括号是可选的</p>
<pre><code>例：ls -la /etc
</code></pre><p>说明：<br>    1、个别命令使用不遵循此格式<br>    2、当有多个选项时，可以写在一起 -l a—&gt;-la<br>    3、简化选项与完整选项 -a等于–all linux简化的习惯一个-  完整的得用两个–</p>
<h3 id="1-2-目录处理命令："><a href="#1-2-目录处理命令：" class="headerlink" title="1.2 目录处理命令："></a>1.2 目录处理命令：</h3><p><code>ls</code></p>
<p>英文原意：list<br>命令所在路径：/bin/ls<br>执行权限：所有用户<br>功能描述：显示目录文件</p>
<p>语法：ls 选项[-ald][文件或目录]</p>
<pre><code>      -a 显示所有文件，包括隐藏文件 [all]
      -l 详细信息显示 [long]  
      -h 人性化显示把文件大小显示为KB MB [human]
      -d 查看目录属性 [directory]
      -i 查看文件的i节点,可以理解为系统会给每个文件一个ID号 [inode]

任何一个文件的详细信息：
-rw-r--r--
文件类型：- 二进制文件   d 目录[directory]     l 软链接文件[link]
rw- r-- r--
u   g   o 
u所有者 g所有组 o其他人 (在上面rw-三个一组)
r读 w写 x执行
</code></pre><hr>
<p><code>mkdir</code></p>
<p>英文原意：make directories<br>命令所在路径：/bin/mkdir<br>执行权限：所有用户<br>语法：mkdir-p[目录名]<br>功能描述：创建根目录 -p递归创建</p>
<pre><code>范例：mkdir -p /tmp/Japan/boduo
      mkdir /tmp/Japan/longze/tmp/Japan/canjing 这个会报错 应该如果不-p递归 你在一个本来不存在的目录里面再去创建目录 肯定是不行的
</code></pre><hr>
<p><code>cd</code></p>
<p>英文原意：change directory;<br>命令所在路径：shell内置命令；<br>执行权限：所有用户；<br>语法：cd[目录]；<br>功能描述：切换目录</p>
<pre><code>范例：cd /tem/Japan/boduo切换到指定目录
     cd .. 回到上一级目录
</code></pre><hr>
<p><code>rmdir</code></p>
<p>英文原意：remove empty directories<br>命令所在路径：/bin/rmdir<br>执行权限：所有用户<br>语法：rmdir[目录名]<br>功能描述：删除空目录</p>
<pre><code>如果不为空得用rm -r xxx
范例：rmdir /tmp/Japan/boduo
</code></pre><hr>
<p><code>cp</code></p>
<p>英文原意：copy ; 命令所在路径：/bin/cp ；执行权限：所有用户;<br>语法：cp -rp [原文件或目录][目标目录]<br>         -r  复制目录<br>         -p 保留文件属性<br>功能描述：复制文件或目录(可以同时复制多个文件或目录 只要指定目标位置)</p>
<pre><code>例子：mv -r /tmp/Japan /root/riben 把tmp目录下面的Japan复制到root目录下面并且更改名字为riben
</code></pre><hr>
<p><code>mv</code></p>
<p>英文原意：move<br>命令所在路径:/bin/mv<br>执行权限：所有用户；<br>语法：mv[原文件或目录][目标目录]<br>功能描述:剪切文件或改名<br>    例子：mv /tmp/Japan /root/riben 把tmp目录下面的Japan剪切到root目录下面并且更改名字为riben<br>    改名:<br>    cd /root<br>    mv Japan riben 如果在当前目录下面mv不就是在改名么！ </p>
<hr>
<p><code>rm</code><br>英文原意：remove<br>命令所在路径:/bin/rm<br>执行权限：所有用户<br>语法：rm -rf[文件或目录]<br>         -r 删除目录<br>         -f 强制执行<br>功能描述:删除文件<br>    rm grub.config</p>
<hr>
<h3 id="1-3-文件处理命令"><a href="#1-3-文件处理命令" class="headerlink" title="1.3 文件处理命令"></a>1.3 文件处理命令</h3><hr>
<p><code>touch</code><br>命令所在路径:/bin/touch<br>执行权限：所有用户<br>语法：touch[文件名]<br>功能描述：创建空文件</p>
<pre><code>范例：touch Japanlovestory.list //在当前路径下面创建文件
      touch /root/Japanlovestory.list  //如果加了完整路径则在root路径下面创建一个空文件
linux中并不像window中对特殊符号不允许 但是建议在Linux中也别用
另外注意空格：
      touch program files  因为在window中可以在文件命名的时候 中间去敲一个空格 但是注意！！这条命令会创建两个文件 program files
如果真的需要创建一个“program files”的文件，可以用引号引起来
      touch &quot;program files&quot;
虽然可以敲一个空白符 但是并不建议这么做，因为在以后查找的时候 会产生很多麻烦 
</code></pre><hr>
<p><code>cat</code><br>命令所在路径：/bin/cat<br>执行权限：所有用户<br>语法：cat[文件名]<br>功能描述：显示文件内容<br>  -n显示行号</p>
<pre><code>范例：cat /etc/issue
     cat -n /etc/services
</code></pre><p>此命令并适合浏览很长很长的文件！要用more</p>
<hr>
<p><code>tac</code><br>命令所在路径：/usr/bin/tac<br>执行权限：所有用户<br>语法：tac [文件名]<br>功能描述：显示文件内容（反向列示）—反过来倒着显示 但是并不支持显示行号</p>
<pre><code>范例：tac /etc/services
</code></pre><hr>
<p><code>more</code><br>命令所在路径：/bin/more<br>执行权限：所有用户<br>语法：more [文件名]<br>      空格或者f  翻页<br>      enter      换行<br>      q或Q       退出<br>功能描述：分页显示文件内容<br>    范例：more /etc/services<br>不足：只可以按往下面翻页 不能往上面翻页 所以得用：less</p>
<hr>
<p><code>less</code><br>命令所在路径：/usr/bin/less<br>执行权限：所有用户<br>    语法：less [文件名]<br>          pageup向上翻页<br>          空格或者f  翻页<br>          enter      换行<br>          向上方向箭头 上面一行<br>          q或Q       退出<br>          /xxx    搜索关键词xxx  n向下切换搜索的结果所在位置[next]<br>功能描述：分页显示文件内容（可向上翻页 并且可以查找）</p>
<pre><code>范例：less /etc/services
</code></pre><hr>
<p><code>head</code><br>命令所在路径：/usr/bin/head<br>执行权限：所有用户<br>语法：head [文件名]<br>功能描述：显示文件前面几行<br>              -n指定行数<br>    范例：head -n 20 /etc/services<br>如果你不指定行号，会默认显示10行。</p>
<hr>
<p><code>tail</code><br>命令所在路径：/usr/bin/tail<br>执行权限：所有用户<br>语法：tail [文件名]<br>功能描述：显示文件后面几行<br>              -n指定行数<br>       -f动态显示文件末尾内容 常用来监控日志 因为它会动态显示<br>    范例：tail -n 18 /etc/services<br>如果你不指定行号，会默认显示10行。</p>
<hr>
<h3 id="1-4链接命令"><a href="#1-4链接命令" class="headerlink" title="1.4链接命令"></a>1.4链接命令</h3><hr>
<p><code>ln</code><br>英文原意：link<br>命令所在路径：/bin/ln<br>执行权限：所有用户<br>    语法：ln -s [原文件][目标文件]<br>             -s 创建软链接<br>功能描述：生成链接文件</p>
<pre><code>范例：ln -s /etc/issue /tmp/issue.soft
      创建文件/etc/issue的软链接/tmp/issue.soft

      ln /etc/issue /tmp/issue.hard
      创建文件/etc/issue的硬链接/tmp/issue.hard  硬链接没有 -s选项
</code></pre><p>软链接特征：类似windows快捷方式</p>
<pre><code>1：lrwxrwxrwx l开头表示文件类型为软链接 软链接所有用户的文件权限均为可读可写可执行
2：文件大小 当我们创建一个软链接的时候 跟原文件相比 大小相比原文件小很多，因为它只是一个符号链接
3：/tmp/issue.soft -&gt; /etc/issue 箭头指向源文件

什么时候用软链接即什么时候在window中用快捷方式
</code></pre><p>硬链接特征：</p>
<pre><code>1：拷贝 cp-p + 同步更新
echo &quot;www.thaibl.com&quot; &gt;&gt; /etc/issue
(相当于拷贝并保留原文件属性（最后修改时间，大小，内容）外加同步更新,就算一个文件删除了，另外一个依然存在)
2：通过i节点识别。 当给某个文件创建一个硬链接的时候 我们会发现硬链接文件的节点跟原文件的节点一样。[所以才会实时更新][ls -i]
3：不能跨分区 比如不能把都在 /tmp目录下面的文件 创建到/bin目录下面去 而软链接没有这个限制
4：不能针对目录使用[不能跟某个目录创建硬链接，而软链接没有这个限制]
</code></pre><hr>
<h3 id="2、权限管理命令"><a href="#2、权限管理命令" class="headerlink" title="2、权限管理命令"></a>2、权限管理命令</h3><hr>
<p>代表字符 权限 对文件的含义 对目录的含义</p>
<p>r 读权限 可以查看文件的内容 可以列出目录中的内容</p>
<p>w 写权限 可以修改文件内容 可以在目录中创建删除文件</p>
<p>x 执行权限 可以执行文件 可以进入目录</p>
<hr>
<p>注意：对所属用户来说 一个文件是否有删除权限，要看文件所在的目录是否有写权限<br>假如我们在 root下面创建一个temp目录 然后touch /temp/testfile 然后chmod 777 /temp 再去创建useradd qingwa passwd qingwa 创建一个普通用户qingwa之后再去登录，执行rw /temp/testfile 由于我们设置了temp目录对普通用户来说也是有写的权限，所以能删除！！</p>
<hr>
<p><code>chmod</code><br>命令英文原意：change the permissions mode of a file<br>命令所在路径：/bin/chmode<br>执行权限：所有用户</p>
<pre><code>语法：
一、chmod [{ugoa}{+-=}{rwx}][文件或目录]   

          //u所有者 g所有组 o其他人 +增加权限 -减少权限 =不管你之前有什么权限，现在必须是这个权限 rwx可读可写可执行

    例子：chmod u+x /tmp/test.html 即给test.html 所有者增加x可执行的权限
          chmod g+x,o-r /tmp/text/html 可以给多个用户修改多个权限，用逗号隔开就行了

  二、[mode=421][文件或目录]   -------通常用这个

      //权限的数字表示,r--4 w---2  x---1
      rwxrw-r--
      7  6  4
例子：假如我们想要这个权限640 rw-r----- 可以这样：chmod 640 /tmp/test.html

  三、-R 递归修改

  假如在tmp/a/b
  thmod -R 777 /tmp/a
  因为是递归修改 我们ls -lh的时候会发现b目录的权限也会被递归修改为777
</code></pre><p>功能描述：改变文件或目录权限</p>
<hr>
<p><code>chown</code><br>命令英文原意：change file ownership<br>命令所在路径：/bin/chown<br>执行权限：所有用户<br>语法：chown[用户][文件或目录]<br>功能描述：改变文件或目录的所有者</p>
<pre><code>范例：chown qingwa yang  //改变文件qingwa的所有者为yang
</code></pre><hr>
<p><code>chgrp</code><br>命令英文原意：change file group ownership<br>命令所在路径：/bin/chgrp<br>执行权限：所有用户<br>语法：chgrp[用户组][文件或目录]<br>功能描述：改变文件或目录的所属组<br>    范例：chgrp lampbrother fengjie //改变文件fengjie的所属组为lampbrother </p>
<p>[groupadd 添加用户组]</p>
<hr>
<p><code>umask</code><br>英文原意:the user file-creation mask<br>命令所在路径:Shell内置命令<br>执行权限：所有用户<br>语法：umask [-S]<br>      -S 以rwx形式显示新建文件缺省权限<br>功能描述：显示、设置文件的缺省权限<br><code>范例：umask -S</code><br>注意：linux中创建一个新文件默认是rw-r–r–出于安全考虑是不让新建的文件有可执行的权限644<br>假如我想修改默认新建文件的权限，就是以后创建的新文件的权限为rwxr-xr– 754<br>需要这么做：777-754=023<br>umask 023<br>以后新建的文件的权限就是：rwxr-xr– 754</p>
<hr>
<h3 id="3、文件搜索命令"><a href="#3、文件搜索命令" class="headerlink" title="3、文件搜索命令"></a>3、文件搜索命令</h3><hr>
<p>在linux中，最重要的事情不是搜索你能找得到文件，而是应该规划好目录结构，放好位置，因为搜索会很占用系统资源，如果在服务器访问高发期间，小心崩溃。</p>
<hr>
<p><code>find</code><br>命令所在路径：/bin/find<br>执行权限：所有用户<br>语法：find [搜索范围][匹配条件]<br>功能描述：文件搜索</p>
<pre><code>A：find /etc -name init  在目录/etc中查找文件名为 init  [-iname不区分大小写]
B：find /etc -size +204800 在目录/etc下查找大于100M的文件  +n 大于 -n小于  n等于  
注意：在linux中得换算为数据块 1数据块等于512字节即0.5k--100M=102400kb=204800kb
C：find / -user qingwa 在根目录下面查找所有者为qingwa的文件
       -group根据所属组查找
D：find /etc -cmin -5 在/etc下查找5分钟内被修改过属性的文件和目录
             -amin 访问时间[access]
      -cmin 文件属性[change]
      -mmin 文件内容[modify]
    +xx表示超过时间 -xx表示多少时间以内
E：find /etc -size +163840 -a -size -204800 在/etc下查找大于80MB小于100MB的文件
   -a两个条件同时满足 [and]
   -o两个条件满足任意一个即可
F：find /etc -name inittab -exec ls -l {}\; 在/etc下查找inittab文件并显示其详细信息
   -exec/ok 命令 {}\; 对搜索结果执行操作
G：-type根据文件类型查找 f文件 d目录 l软链接文件
H: 根据i节点查找
   find . -inum 31531 -exec rm {}\;查找节点为31531的文件并立即执行删除命令
</code></pre><hr>
<p><code>locate</code><br>命令所在路径：/usr/bin/locate<br>执行权限：所有用户<br>语法：locate 文件名<br>功能描述：在文件资料库中查找文件<br>    范例：locate inittab</p>
<pre><code>-i 选项不区分大小写

注意1：locate搜索速度很快 相当于window那个everything那个软件。原因是：用locate locate 会得到很多行信息，系统会定期把信息存放到mlocate.db文件里，不像find会在某个分区某个文件去查找，只需要搜索mlocate.db这个文件就行了。
但是有一个问题，新建的文件实际上是没有被收录到这个文件里的，所以用locate去查找的时候，是查找不了的。解决办法：执行下update命令 回去更新这个文件资料库，再去查找就会找到了。
注意2：locate是无法找到临时目录下面的文件的 比如/tmp
</code></pre><hr>
<p><code>which</code><br>命令所在路径：/usr/bin/which<br>执行权限：所有用户<br>语法：which命令<br>功能描述：搜索命令所在目录及别名信息<br>    范例：which ls</p>
<hr>
<pre><code>whereis
</code></pre><p>命令所在路径：/usr/bin/whereis<br>执行权限：所有用户<br>语法：whereis [命令名称]<br>功能描述：搜索命令所在目录及帮助文档路径<br>    范例：whereis ls</p>
<hr>
<p><code>grep</code><br>命令所在路径：/bin/grep<br>执行权限：所有用户<br>语法：grep -iv[指定字串][文件]<br>功能描述：在文件中搜寻字串匹配的行并输出<br> -i 不区分大小写<br> -v 排除指定字串<br>    范例:grep -i mysql /root/install.log 在/root/install.log文件中不区分大小写的查找mysql<br>         grep -v ^# /etc.initab排除以#开头的行的字符串</p>
<hr>
<h3 id="4、帮助命令"><a href="#4、帮助命令" class="headerlink" title="4、帮助命令"></a>4、帮助命令</h3><hr>
<p><code>man</code><br>英文原意：manual<br>命令所在路径：/usr/bin/man<br>执行权限：所在用户<br>语法：man[命令或配置文件]<br>功能描述：获得帮助信息<br>    范例：man ls<br>          查看ls命令的帮助信息<br>          man services<br>          查看配置文件services的帮助信息<br>          man 5 passwd 查看用户信息</p>
<pre><code>Linux中,执行man命令查询帮助文档时,是以vi形式打开帮助文档,所以退出时应该键入:q命令
</code></pre><hr>
<p><code>whatis</code> 命令<br>查看到命令简短的介绍信息[该命令是干什么的]</p>
<hr>
<p><code>apropos</code> 配置文件的名称<br>查看配置文件的简短信息</p>
<hr>
<p>技巧：<br><strong>命令 –help</strong> 会把该命令常见的选项列出来<br>    touch –help</p>
<hr>
<p><code>info</code> 跟 man差不多也是显示帮助信息</p>
<hr>
<p><code>help</code><br>命令所在路径：Shell内置命令<br>执行权限：所有用户<br>语法：help命令<br>功能描述：获得Shell内置命令的帮助信息<br>范例：help umask   查看umask命令的帮助信息</p>
<p>用which找不到的命令都是Shell内置命令</p>
<hr>
<h3 id="5、用户管理命令"><a href="#5、用户管理命令" class="headerlink" title="5、用户管理命令"></a>5、用户管理命令</h3><hr>
<p><code>useradd</code></p>
<p>命令所在路径：/usr/sbin/useradd<br>执行权限：root<br>语法：useradd用户名<br>功能描述：添加新用户<br>    范例：useradd qingwa</p>
<hr>
<p><code>passwd</code><br>命令所在路径：/usr/bin/passwd<br>执行权限：所有用户<br>语法：passwd用户名<br>功能描述：设置用户密码<br>    范例 passwd amdin888</p>
<p>普通用户只能更改自己的密码 而root可以更改所有用户的密码</p>
<hr>
<p><code>who</code><br>命令所在路径：/usr/bin/who<br>执行权限：所有用户<br>语法：who<br>功能描述：查看登录用户信息<br>    范例：who </p>
<p>显示规则：<br>登录用户名  登录终端  tty本地终端  pts表示远程终端（用不同的数字，终端号来区分不同的登录终端） 登录时间（什么时候登录的）</p>
<hr>
<p><code>w</code><br>命令所在路径：/usr/bin/w<br>执行权限：所有用户<br>语法：w<br>功能描述：查看登录用户详细信息</p>
<pre><code>范例：w

up linux连续运行多少时间了([uptime命令也行]) ；
load average负载均衡的三个值 ；
IDLE表示用户登录过来空闲了多久了 ；
JCPU当前用户登录过来累计的占用时间；
PCPU表示当前登录过来用户当前操作占用的时间 ；
WHAT表示当前执行的什么操作、命令
</code></pre><hr>
<h3 id="6、压缩解压命令"><a href="#6、压缩解压命令" class="headerlink" title="6、压缩解压命令"></a>6、压缩解压命令</h3><hr>
<p>.gz(window中很少)<br>.zip（linux window中都有）<br>.rar(在linux中在需要装一个rar for linux的解压软件)</p>
<hr>
<p><code>gzip</code><br>命令所在路径：/bin/gzip<br>执行权限：所有用户<br>语法：gzip [文件]<br>功能描述：压缩文件 注意：跟window是不一样的，只能压缩文件，不能压缩目录，而且压缩完不保留原文件 只剩压缩包了<br>压缩后文件的格式：.gz</p>
<hr>
<p><code>gunzip</code><br>命令英文原意：GUNunzip<br>命令所在路径：/bin/gunzip<br>执行权限：所有用户<br>语法：gunzip[压缩文件]<br>功能描述：解压.gz的压缩文件</p>
<pre><code>范例：gunzip buduo.gz
</code></pre><hr>
<p><code>tar</code>压缩<br>命令所在路径：/bin/tar<br>执行权限：所有用户<br>    语法：tar 选项[-zcf][压缩后文件名][目录]<br>       -c打包 ！！！<br>       -v显示详细信息<br>       -f指定文件名<br>       -z打包同时压缩<br>功能描述：打包目录<br>压缩后文件格式：.tar.gz<br>    例子：tar -cvf Japan.tar.gz Japan  把Japan这个目录压缩成Japan.tar</p>
<pre><code>tar解压
 -x解包 !!!!
 -v显示详细信息
 -f指定解压软件
 -z解压缩
范例：tar -zxvf Japan.tar.gz
</code></pre><hr>
<p><code>zip</code><br>命令所在路径：/usr/bin/zip<br>执行权限：所有用户<br>语法：<br>zip 选项[-r] [压缩后文件名] [文件或目录]<br>    -r 压缩目录<br>功能描述：压缩文件或目录<br>压缩后文件格式：.zip</p>
<p>压缩原文件仍未保留 还会显示压缩比 但是压缩比并没有 gzip tar 那么强</p>
<p>解压：unzip [压缩文件]</p>
<hr>
<p><code>bzip2</code><br>命令所在路径：/usr/bin/bzip2<br>执行权限：所有用户<br>语法：bzip2 选项 [-k][文件]<br>      -k 产生压缩文件后保留原文件<br>功能描述：压缩文件<br>压缩文件格式：.bz2<br>    范例：bzip2 -k boduo<br>          tar -cjf Japan.tar.bz2 Japan  把-z换成-j就可以利用tar压缩成.tar.bz2格式</p>
<p>这个压缩格式比率惊人。</p>
<hr>
<p><code>bunzip2</code><br>命令所在路径：/usr/bin/bunzip2<br>执行权限：所有用户<br>语法：bunzip2 选项[-k][压缩文件]<br>      -k解压后保留原文件<br>功能描述：解压<br>    范例：bunzip2 -k boduo.bz2<br>          tar -xjf Japan.tar.bz2</p>
<hr>
<h3 id="7、网络命令"><a href="#7、网络命令" class="headerlink" title="7、网络命令"></a>7、网络命令</h3><hr>
<p><code>write</code><br>指令所在路径：/usr/bin/write<br>执行权限：所有用户<br>语法：write &lt;用户名&gt;<br>功能描述：给在线用户发信息（w可以看到哪些用户在线）,ctrl+D保存结束<br>    范例：# write linzhiling<br>    xxxxxxxxxxxxx<br>    ctrl+D保存结束</p>
<hr>
<p><code>wall</code><br>命令英文原意：write all<br>命令所在路径：/usr/bin/wall<br>执行权限：所有用户<br>语法：wall [message]<br>功能描述：发广播信息(给所有在线用户)<br>    范例：# wall qingwa is a animal</p>
<hr>
<p><code>ping</code><br>命令所在路径：/bin/ping<br>执行权限：所有用户<br>语法：ping 选项 IP地址<br>      -c 指定发送次数<br>功能描述：测试网络连通性<br>    范例：# ping 192.168.88.99</p>
<p>ctrl+c结束</p>
<hr>
<p><code>ifconfig</code><br>命令英文原意：interface configure<br>命令所在路径：/sbin/ifconfig<br>执行权限：root<br>语法：ifconfig 网卡名称 IP地址<br>功能描述：查看和设置网卡信息<br>    范例：# ifconfig eth0 192.168.88.99</p>
<p><em>linux有两套网卡<br>eth0|eth1…本地真实的网卡，按照数字方式一次后推<br>lo 回环网卡，用来本机通信和测试的，地址也是固定的 都是127.0.0.1</em></p>
<hr>
<p><code>mail</code><br>命令所在路径：/bin/mail<br>执行权限：所有用户<br>语法：mail[用户名]<br>功能描述：查看发送电子邮件<br>    范例：mail root</p>
<p>这个就不像write命令 可以用户不在线  </p>
<p>ctrl+D保存结束</p>
<hr>
<p><code>last</code></p>
<p>命令所在路径：/usr/bin/last<br>执行权限：所有用户<br>语法：last<br>功能描述：列出目前与过去登入系统的用户信息<br>    范例：# last</p>
<p>[运用非常广泛]<br>这个命令非常有效常用的命令！！可以看 有什么其他用户登录了服务器.</p>
<p>如果有时候我们不想那么多信息，想看到用户最后一次登录的时间，可以用lastlog命令！！</p>
<hr>
<p><code>traceroute</code><br>命令所在路径：/bin/traceroute<br>执行权限：所有用户<br>语法：traceroute<br>功能描述：显示数据包到主机间的路径<br>    范例：traceroute www.thaibl.com<br>[运用非常广泛]</p>
<hr>
<p><code>netstat</code><br>命令所在路径：/bin/netstat<br>执行权限：所有用户<br>语法：netstat [选项]<br>功能描述：显示网络相关信息</p>
<pre><code>选项：
 -t:TCP协议 传输控制协议的简称【三次握手 安全】相当于A打电话B A你是？B你是？ AB要通话了 
 -u:UDP协议 用户数据报协议【快 不管你在不在线 直接甩给你】相当于发短信  不管你是谁、关机与否、可能被谁看到不管
 -l:监听
 -r:路由
 -n:显示IP地址和端口号
范例：
 # netstat -tlun 查看本机监听的端口
 # netstat -an 查看本机所有的网络连接
 # netstat -rn 查看本机路由表
</code></pre><p>[运用非常广泛，非常重要]</p>
<hr>
<p><code>setup</code><br>命令所在路径：/usr/bin/setup<br>执行权限：root<br>语法：setup<br>功能描述：配置网络<br>    范例：# setup</p>
<hr>
<p>挂载命令<br><code>mount</code><br>命令所在位置：/bin/mount<br>执行权限：所有用户<br>命令语法：mount [-t 文件系统] 设备文件名 挂载点<br>    范例： # mount -t iso9660 /dev/sr0/ /mnt/cdrom<br>             = mount /dev/sr0/ /mnt/cdrom </p>
<p>umount 设备文件名|挂载点<br>umount /dev/sr0 卸载光盘<br>需要跳到宿主目录去执行卸载命令</p>
<hr>
<h3 id="8、关机重启命令"><a href="#8、关机重启命令" class="headerlink" title="8、关机重启命令"></a>8、关机重启命令</h3><hr>
<p><code>shutdown</code></p>
<p>命令语法：shutdown [选项] 时间<br>    选项：-c 取消前一个关机命令<br>          -h 关机<br>          -r 重启</p>
<pre><code>eg：shutdown -h now 马上关机 shutdown -h 20:30 晚上八点关机
    shutdown -r now 马上重启
    shutdown -c 取消前一个关机命令
</code></pre><p>linux中还有其他重启关机命令，但是早期只有shutdown保存原来开启的服务 现在其他的也有了 但还是推荐这个老命令</p>
<p>提醒：<br>关机或重启之前必须先把服务停掉！这样才能保证用户不能碰触我，硬盘才会空闲下来，才会重启。</p>
<p>服务器不能关机 只能重启！！！</p>
<pre><code>其他关机命令：halt  
            poweroff 这个就不要用了 直接断电!!!
            init 0
其他重启命令：reboot
            init 6
</code></pre><hr>
<pre><code>系统运行级别：
0：关机
1：单用户（类似windows启动时按F8进入安全模式，其实就是启动最小的服务，其他多余附加的程序都不用，只启动核心的程序，用来做一些修复。只能root登录进去）
2：不完全多用户，不含NFS服务
3：完全多用户
4：未分配
5：图形界面
6：重启

cat /etc/inittab
#修改系统默认运行级别
id:3:initdefault:

`runlevel`
#查询系统运行级别 
</code></pre><hr>
<p>退出登录命令：<br><code>logout</code></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;————————常用命令—————&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1文件处理命令
 1.1命令格式与目录处理命令
 1.2目录处理命令
 1.3文件处理命令
 1.4链接命令
2权限管理命令
3文件搜索命令
4帮助命令
5用户管理命令
6压缩解压命令
7网络命令
8关机重启命令
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>linux学习笔记之vim</title>
    <link href="http://yoursite.com/2014/03/17/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bvim/"/>
    <id>http://yoursite.com/2014/03/17/linux学习笔记之vim/</id>
    <published>2014-03-17T14:52:07.000Z</published>
    <updated>2016-12-24T14:25:00.573Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Vim常用操作"><a href="#一、Vim常用操作" class="headerlink" title="一、Vim常用操作"></a>一、Vim常用操作</h3><p>Vim是一个功能强大的全屏幕文本编辑器。是linux/unix上最常用的文本编辑器。它的作用是建立、编辑、显示文本文件。</p>
<p>Vim没有菜单，只有命令！</p>
<p>Vim三个工作模式：<br>            命令模式<br>            vi filename 进去命令模式 输入:wq保存退出</p>
<pre><code>插入模式
当你在命令模式的时候，输入插入命令 i a o就可以进入插入模式，进入插入模式的标志是下方出现了INSERT字样。按ESC退出。        

编辑模式
当你是命令模式的时候，按一个冒号 &apos;:&apos;就可以进入编辑模式。比如set number命令设置行号 设置完就回到命令模式
</code></pre><hr>
<a id="more"></a>
<pre><code>插入命令：
命令            作用
a            在光标所在字符后插入
A            在光标所在行尾插入
i            在光标所在字符前插入
I            在光标所在行行首插入
o            在光标下面插入新行
O            在光标上面插入新行
</code></pre><hr>
<pre><code>定位命令：
命令            作用
:set nu            设置行号
:set nonu        取消行号
gg            到第一行
G            到最后一行
nG            到第n行
:n            到第n行
$            移至行尾
0            移至行首
</code></pre><hr>
<pre><code>删除命令：
命令            作用
x            删除光标所在处字符
nx            删除光标所在处后n个字符
dd            删除光标所在行  ndd删除n行
dG            删除光标所在行到文件末尾内容
D            删除光标所在处到行尾内容
:n1,n2d            删除n1行到n2行指定范围的行
</code></pre><hr>
<pre><code>复制和剪切命令
命令            作用
yy            复制当前行
nyy            复制当前行以下n行
dd            剪切当前行
ndd            复制当前行以下n行
p或P            粘贴在当前光标所在行下或行上
</code></pre><hr>
<pre><code>替换和取消命令
命令            作用
r            取代光标所在处字符
R            从光标所在处开始替换字符，按Esc结束 【下方会出现replace字符】
u            取消上一步操作
</code></pre><hr>
<pre><code>搜索和搜索替换命令
命令            作用
/string            1:搜索指定的字符串 2：搜索时忽略大小写 :set ic
n            搜索指定字符串的下一个出现位置
:%s/old/new/g        全文替换指定字符串
:n1,n2s/old/new/g    在一定范围内替换指定字符串

:替换范围
%s 全文替换
起始行,终止行 s     /要替换的字符串/替换的新的字符串/g
                             c 询问确认
</code></pre><hr>
<pre><code>保存和退出命令
命令            作用
:w            保存修改
:W new_filename        另存为指定文件
:wq            保存修改并退出
ZZ            快捷键，保存修改并退出
:q!            不保存修改退出
:wq!            保存修改并退出（文件所有者及root可使用）
</code></pre><hr>
<h3 id="二、Vim常用技巧"><a href="#二、Vim常用技巧" class="headerlink" title="二、Vim常用技巧"></a>二、Vim常用技巧</h3><h5 id="–技巧1———————————————–"><a href="#–技巧1———————————————–" class="headerlink" title="–技巧1———————————————–"></a>–技巧1———————————————–</h5><pre><code>:r 文件名 ----把文件内容导入到刚刚光标所在的位置

:! 命令 -----可以执行命令
例如 :!which ls ----可以查看ls命令所在位置

可以把以上结合起来，可以把一个命令执行结果导入文件中 :r !命令
</code></pre><h5 id="–技巧2———————————————–"><a href="#–技巧2———————————————–" class="headerlink" title="–技巧2———————————————–"></a>–技巧2———————————————–</h5><pre><code>定义快捷键 :map 快捷键 触发命令

范例：    :map ^P I#&lt;ESC&gt; 定义快捷键位ctrl+P 触发的命令为 I跳到行首并进入插入模式，然后插入#号，然后进入到命令模式
    :map ^B 0x   定义快捷键ctrl+B 触发的命令为 0光标跳到行首并删除光标所在的字符 即可实现：删除注释

注意：快捷键一般跟ctrl结合起来 这里的^不是数字6那个 实际是ctrl+v 可以结合快捷键三个键一起按！
</code></pre><h5 id="–技巧3———————————————–"><a href="#–技巧3———————————————–" class="headerlink" title="–技巧3———————————————–"></a>–技巧3———————————————–</h5><pre><code>连续行注释

    :n1,n2s/^/#/g 连续多行注释
    :n1,n2s/^#//g 去掉连续多行的注释
    :n1,n2s/^/\/\//g 有些程序我们需要//注释的时候 可以连续多行这个命令
</code></pre><h5 id="–技巧4———————————————–"><a href="#–技巧4———————————————–" class="headerlink" title="–技巧4———————————————–"></a>–技巧4———————————————–</h5><pre><code>替换
:ab mymail 763191973@qq.com
在用vim编辑器执行 以上 当我们在插入模式 的时候 输入mymail的时候 一回车就会变成了763191973@qq.com
</code></pre><hr>
<p>注意!!!!：如果有定义的快捷键 ab在重启的时候 会发现都消失 如果你想永久有效 需要写在每个用户的宿主目录下面的家目录下面的配置文件里面。如果是root就在/root目录下面，如果是其他用户就在/home/xx下面。<br>文件.vimrc 可以存放一些编辑模式的命令 快捷键 ab</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Vim常用操作&quot;&gt;&lt;a href=&quot;#一、Vim常用操作&quot; class=&quot;headerlink&quot; title=&quot;一、Vim常用操作&quot;&gt;&lt;/a&gt;一、Vim常用操作&lt;/h3&gt;&lt;p&gt;Vim是一个功能强大的全屏幕文本编辑器。是linux/unix上最常用的文本编辑器。它的作用是建立、编辑、显示文本文件。&lt;/p&gt;
&lt;p&gt;Vim没有菜单，只有命令！&lt;/p&gt;
&lt;p&gt;Vim三个工作模式：&lt;br&gt;            命令模式&lt;br&gt;            vi filename 进去命令模式 输入:wq保存退出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;插入模式
当你在命令模式的时候，输入插入命令 i a o就可以进入插入模式，进入插入模式的标志是下方出现了INSERT字样。按ESC退出。        

编辑模式
当你是命令模式的时候，按一个冒号 &amp;apos;:&amp;apos;就可以进入编辑模式。比如set number命令设置行号 设置完就回到命令模式
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="VIM" scheme="http://yoursite.com/tags/VIM/"/>
    
  </entry>
  
</feed>
